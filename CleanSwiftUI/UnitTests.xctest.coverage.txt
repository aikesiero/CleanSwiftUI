/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Interactors/CountriesInteractorTests.swift:
    1|       |//
    2|       |//  CountriesInteractorTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 31.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import SwiftUI
   11|       |import Combine
   12|       |@testable import CountriesSwiftUI
   13|       |
   14|       |class CountriesInteractorTests: XCTestCase {
   15|       |
   16|     10|    let appState = CurrentValueSubject<AppState, Never>(AppState())
   17|       |    var mockedWebRepo: MockedCountriesWebRepository!
   18|       |    var mockedDBRepo: MockedCountriesDBRepository!
   19|     10|    var subscriptions = Set<AnyCancellable>()
   20|       |    var sut: RealCountriesInteractor!
   21|       |
   22|     10|    override func setUp() {
   23|     10|        appState.value = AppState()
   24|     10|        mockedWebRepo = MockedCountriesWebRepository()
   25|     10|        mockedDBRepo = MockedCountriesDBRepository()
   26|     10|        sut = RealCountriesInteractor(webRepository: mockedWebRepo,
   27|     10|                                      dbRepository: mockedDBRepo,
   28|     10|                                      appState: appState)
   29|     10|    }
   30|       |
   31|     10|    override func tearDown() {
   32|     10|        subscriptions = Set<AnyCancellable>()
   33|     10|    }
   34|       |}
   35|       |
   36|       |// MARK: - load(countries: search: locale:)
   37|       |
   38|       |final class LoadCountriesTests: CountriesInteractorTests {
   39|       |    
   40|      1|    func test_filledDB_successfulSearch() {
   41|      1|        let list = Country.mockedData
   42|      1|        
   43|      1|        // Configuring expected actions on repositories
   44|      1|        
   45|      1|        mockedWebRepo.actions = .init(expected: [
   46|      1|        ])
   47|      1|        mockedDBRepo.actions = .init(expected: [
   48|      1|            .hasLoadedCountries,
   49|      1|            .fetchCountries(search: "abc", locale: .backendDefault)
   50|      1|        ])
   51|      1|        
   52|      1|        // Configuring responses from repositories
   53|      1|        
   54|      1|        mockedDBRepo.hasLoadedCountriesResult = .success(true)
   55|      1|        mockedDBRepo.fetchCountriesResult = .success(list.lazyList)
   56|      1|        
   57|      1|        let countries = BindingWithPublisher(value: Loadable<LazyList<Country>>.notRequested)
   58|      1|        sut.load(countries: countries.binding, search: "abc", locale: .backendDefault)
   59|      1|        let exp = XCTestExpectation(description: #function)
   60|      1|        countries.updatesRecorder.sink { updates in
   61|      1|            XCTAssertEqual(updates, [
   62|      1|                .notRequested,
   63|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
   64|      1|                .loaded(list.lazyList)
   65|      1|            ], removing: Country.prefixes)
   66|      1|            self.mockedWebRepo.verify()
   67|      1|            self.mockedDBRepo.verify()
   68|      1|            exp.fulfill()
   69|      1|        }.store(in: &subscriptions)
   70|      1|        wait(for: [exp], timeout: 2)
   71|      1|    }
   72|       |    
   73|      1|    func test_filledDB_failedSearch() {
   74|      1|        let error = NSError.test
   75|      1|        
   76|      1|        // Configuring expected actions on repositories
   77|      1|        
   78|      1|        mockedWebRepo.actions = .init(expected: [
   79|      1|        ])
   80|      1|        mockedDBRepo.actions = .init(expected: [
   81|      1|            .hasLoadedCountries,
   82|      1|            .fetchCountries(search: "abc", locale: .backendDefault)
   83|      1|        ])
   84|      1|        
   85|      1|        // Configuring responses from repositories
   86|      1|        
   87|      1|        mockedDBRepo.hasLoadedCountriesResult = .success(true)
   88|      1|        mockedDBRepo.fetchCountriesResult = .failure(error)
   89|      1|        
   90|      1|        let countries = BindingWithPublisher(value: Loadable<LazyList<Country>>.notRequested)
   91|      1|        sut.load(countries: countries.binding, search: "abc", locale: .backendDefault)
   92|      1|        let exp = XCTestExpectation(description: #function)
   93|      1|        countries.updatesRecorder.sink { updates in
   94|      1|            XCTAssertEqual(updates, [
   95|      1|                .notRequested,
   96|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
   97|      1|                .failed(error)
   98|      1|            ], removing: Country.prefixes)
   99|      1|            self.mockedWebRepo.verify()
  100|      1|            self.mockedDBRepo.verify()
  101|      1|            exp.fulfill()
  102|      1|        }.store(in: &subscriptions)
  103|      1|        wait(for: [exp], timeout: 2)
  104|      1|    }
  105|       |    
  106|      1|    func test_emptyDB_failedRequest() {
  107|      1|        let error = NSError.test
  108|      1|        
  109|      1|        // Configuring expected actions on repositories
  110|      1|        
  111|      1|        mockedWebRepo.actions = .init(expected: [
  112|      1|            .loadCountries
  113|      1|        ])
  114|      1|        mockedDBRepo.actions = .init(expected: [
  115|      1|            .hasLoadedCountries
  116|      1|        ])
  117|      1|        
  118|      1|        // Configuring responses from repositories
  119|      1|        
  120|      1|        mockedWebRepo.countriesResponse = .failure(error)
  121|      1|        mockedDBRepo.hasLoadedCountriesResult = .success(false)
  122|      1|        
  123|      1|        let countries = BindingWithPublisher(value: Loadable<LazyList<Country>>.notRequested)
  124|      1|        sut.load(countries: countries.binding, search: "abc", locale: .backendDefault)
  125|      1|        let exp = XCTestExpectation(description: #function)
  126|      1|        countries.updatesRecorder.sink { updates in
  127|      1|            XCTAssertEqual(updates, [
  128|      1|                .notRequested,
  129|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
  130|      1|                .failed(error)
  131|      1|            ], removing: Country.prefixes)
  132|      1|            self.mockedWebRepo.verify()
  133|      1|            self.mockedDBRepo.verify()
  134|      1|            exp.fulfill()
  135|      1|        }.store(in: &subscriptions)
  136|      1|        wait(for: [exp], timeout: 2)
  137|      1|    }
  138|       |    
  139|      1|    func test_emptyDB_successfulRequest_successfulStoring() {
  140|      1|        let list = Country.mockedData
  141|      1|        
  142|      1|        // Configuring expected actions on repositories
  143|      1|        
  144|      1|        mockedWebRepo.actions = .init(expected: [
  145|      1|            .loadCountries
  146|      1|        ])
  147|      1|        mockedDBRepo.actions = .init(expected: [
  148|      1|            .hasLoadedCountries,
  149|      1|            .storeCountries(list),
  150|      1|            .fetchCountries(search: "abc", locale: .backendDefault)
  151|      1|        ])
  152|      1|        
  153|      1|        // Configuring responses from repositories
  154|      1|        
  155|      1|        mockedWebRepo.countriesResponse = .success(list)
  156|      1|        mockedDBRepo.hasLoadedCountriesResult = .success(false)
  157|      1|        mockedDBRepo.storeCountriesResult = .success(())
  158|      1|        mockedDBRepo.fetchCountriesResult = .success(list.lazyList)
  159|      1|        
  160|      1|        let countries = BindingWithPublisher(value: Loadable<LazyList<Country>>.notRequested)
  161|      1|        sut.load(countries: countries.binding, search: "abc", locale: .backendDefault)
  162|      1|        let exp = XCTestExpectation(description: #function)
  163|      1|        countries.updatesRecorder.sink { updates in
  164|      1|            XCTAssertEqual(updates, [
  165|      1|                .notRequested,
  166|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
  167|      1|                .loaded(list.lazyList)
  168|      1|            ], removing: Country.prefixes)
  169|      1|            self.mockedWebRepo.verify()
  170|      1|            self.mockedDBRepo.verify()
  171|      1|            exp.fulfill()
  172|      1|        }.store(in: &subscriptions)
  173|      1|        wait(for: [exp], timeout: 2)
  174|      1|    }
  175|       |    
  176|      1|    func test_emptyDB_successfulRequest_failedStoring() {
  177|      1|        let list = Country.mockedData
  178|      1|        let error = NSError.test
  179|      1|        
  180|      1|        // Configuring expected actions on repositories
  181|      1|        
  182|      1|        mockedWebRepo.actions = .init(expected: [
  183|      1|            .loadCountries
  184|      1|        ])
  185|      1|        mockedDBRepo.actions = .init(expected: [
  186|      1|            .hasLoadedCountries,
  187|      1|            .storeCountries(list)
  188|      1|        ])
  189|      1|        
  190|      1|        // Configuring responses from repositories
  191|      1|        
  192|      1|        mockedWebRepo.countriesResponse = .success(list)
  193|      1|        mockedDBRepo.hasLoadedCountriesResult = .success(false)
  194|      1|        mockedDBRepo.storeCountriesResult = .failure(error)
  195|      1|        
  196|      1|        let countries = BindingWithPublisher(value: Loadable<LazyList<Country>>.notRequested)
  197|      1|        sut.load(countries: countries.binding, search: "abc", locale: .backendDefault)
  198|      1|        let exp = XCTestExpectation(description: #function)
  199|      1|        countries.updatesRecorder.sink { updates in
  200|      1|            XCTAssertEqual(updates, [
  201|      1|                .notRequested,
  202|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
  203|      1|                .failed(error)
  204|      1|            ], removing: Country.prefixes)
  205|      1|            self.mockedWebRepo.verify()
  206|      1|            self.mockedDBRepo.verify()
  207|      1|            exp.fulfill()
  208|      1|        }.store(in: &subscriptions)
  209|      1|        wait(for: [exp], timeout: 2)
  210|      1|    }
  211|       |}
  212|       |
  213|       |// MARK: - load(countryDetails: country: )
  214|       |
  215|       |final class LoadCountryDetailsTests: CountriesInteractorTests {
  216|       |    
  217|      1|    func test_filledDB_successfulSearch() {
  218|      1|        let country = Country.mockedData[0]
  219|      1|        let data = countryDetails(neighbors: [])
  220|      1|        
  221|      1|        // Configuring expected actions on repositories
  222|      1|        
  223|      1|        mockedWebRepo.actions = .init(expected: [
  224|      1|        ])
  225|      1|        mockedDBRepo.actions = .init(expected: [
  226|      1|            .fetchCountryDetails(country)
  227|      1|        ])
  228|      1|        
  229|      1|        // Configuring responses from repositories
  230|      1|        
  231|      1|        mockedDBRepo.fetchCountryDetailsResult = .success(data.details)
  232|      1|        
  233|      1|        let details = BindingWithPublisher(value: Loadable<Country.Details>.notRequested)
  234|      1|        sut.load(countryDetails: details.binding, country: country)
  235|      1|        let exp = XCTestExpectation(description: #function)
  236|      1|        details.updatesRecorder.sink { updates in
  237|      1|            XCTAssertEqual(updates, [
  238|      1|                .notRequested,
  239|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
  240|      1|                .loaded(data.details)
  241|      1|            ], removing: Country.prefixes)
  242|      1|            self.mockedWebRepo.verify()
  243|      1|            self.mockedDBRepo.verify()
  244|      1|            exp.fulfill()
  245|      1|        }.store(in: &subscriptions)
  246|      1|        wait(for: [exp], timeout: 2)
  247|      1|    }
  248|       |    
  249|      1|    func test_filledDB_dataNotFound_failedRequest() {
  250|      1|        let country = Country.mockedData[0]
  251|      1|        let error = NSError.test
  252|      1|        
  253|      1|        // Configuring expected actions on repositories
  254|      1|        
  255|      1|        mockedWebRepo.actions = .init(expected: [
  256|      1|            .loadCountryDetails(country)
  257|      1|        ])
  258|      1|        mockedDBRepo.actions = .init(expected: [
  259|      1|            .fetchCountryDetails(country)
  260|      1|        ])
  261|      1|        
  262|      1|        // Configuring responses from repositories
  263|      1|        
  264|      1|        mockedDBRepo.fetchCountryDetailsResult = .success(nil)
  265|      1|        mockedWebRepo.detailsResponse = .failure(error)
  266|      1|        
  267|      1|        let details = BindingWithPublisher(value: Loadable<Country.Details>.notRequested)
  268|      1|        sut.load(countryDetails: details.binding, country: country)
  269|      1|        let exp = XCTestExpectation(description: #function)
  270|      1|        details.updatesRecorder.sink { updates in
  271|      1|            XCTAssertEqual(updates, [
  272|      1|                .notRequested,
  273|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
  274|      1|                .failed(error)
  275|      1|            ], removing: Country.prefixes)
  276|      1|            self.mockedWebRepo.verify()
  277|      1|            self.mockedDBRepo.verify()
  278|      1|            exp.fulfill()
  279|      1|        }.store(in: &subscriptions)
  280|      1|        wait(for: [exp], timeout: 2)
  281|      1|    }
  282|       |    
  283|      1|    func test_filledDB_dataNotFound_successfulRequest_failedStoring() {
  284|      1|        let country = Country.mockedData[0]
  285|      1|        let data = countryDetails(neighbors: [])
  286|      1|        let error = NSError.test
  287|      1|        
  288|      1|        // Configuring expected actions on repositories
  289|      1|        
  290|      1|        mockedWebRepo.actions = .init(expected: [
  291|      1|            .loadCountryDetails(country)
  292|      1|        ])
  293|      1|        mockedDBRepo.actions = .init(expected: [
  294|      1|            .fetchCountryDetails(country),
  295|      1|            .storeCountryDetails(data.intermediate)
  296|      1|        ])
  297|      1|        
  298|      1|        // Configuring responses from repositories
  299|      1|        
  300|      1|        mockedDBRepo.fetchCountryDetailsResult = .success(nil)
  301|      1|        mockedWebRepo.detailsResponse = .success(data.intermediate)
  302|      1|        mockedDBRepo.storeCountryDetailsResult = .failure(error)
  303|      1|        
  304|      1|        let details = BindingWithPublisher(value: Loadable<Country.Details>.notRequested)
  305|      1|        sut.load(countryDetails: details.binding, country: country)
  306|      1|        let exp = XCTestExpectation(description: #function)
  307|      1|        details.updatesRecorder.sink { updates in
  308|      1|            XCTAssertEqual(updates, [
  309|      1|                .notRequested,
  310|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
  311|      1|                .failed(error)
  312|      1|            ], removing: Country.prefixes)
  313|      1|            self.mockedWebRepo.verify()
  314|      1|            self.mockedDBRepo.verify()
  315|      1|            exp.fulfill()
  316|      1|        }.store(in: &subscriptions)
  317|      1|        wait(for: [exp], timeout: 2)
  318|      1|    }
  319|       |    
  320|      1|    func test_filledDB_dataNotFound_successfulRequest_successfulStoring() {
  321|      1|        let country = Country.mockedData[0]
  322|      1|        let data = countryDetails(neighbors: [])
  323|      1|        
  324|      1|        // Configuring expected actions on repositories
  325|      1|        
  326|      1|        mockedWebRepo.actions = .init(expected: [
  327|      1|            .loadCountryDetails(country)
  328|      1|        ])
  329|      1|        mockedDBRepo.actions = .init(expected: [
  330|      1|            .fetchCountryDetails(country),
  331|      1|            .storeCountryDetails(data.intermediate)
  332|      1|        ])
  333|      1|        
  334|      1|        // Configuring responses from repositories
  335|      1|        
  336|      1|        mockedDBRepo.fetchCountryDetailsResult = .success(nil)
  337|      1|        mockedWebRepo.detailsResponse = .success(data.intermediate)
  338|      1|        mockedDBRepo.storeCountryDetailsResult = .success(data.details)
  339|      1|        
  340|      1|        let details = BindingWithPublisher(value: Loadable<Country.Details>.notRequested)
  341|      1|        sut.load(countryDetails: details.binding, country: country)
  342|      1|        let exp = XCTestExpectation(description: #function)
  343|      1|        details.updatesRecorder.sink { updates in
  344|      1|            XCTAssertEqual(updates, [
  345|      1|                .notRequested,
  346|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
  347|      1|                .loaded(data.details)
  348|      1|            ], removing: Country.prefixes)
  349|      1|            self.mockedWebRepo.verify()
  350|      1|            self.mockedDBRepo.verify()
  351|      1|            exp.fulfill()
  352|      1|        }.store(in: &subscriptions)
  353|      1|        wait(for: [exp], timeout: 2)
  354|      1|    }
  355|       |    
  356|      1|    func test_stubInteractor() {
  357|      1|        let sut = StubCountriesInteractor()
  358|      1|        sut.refreshCountriesList().sinkToResult({ _ in }).store(in: &subscriptions)
  359|      1|        let countries = BindingWithPublisher(value: Loadable<LazyList<Country>>.notRequested)
  360|      1|        sut.load(countries: countries.binding, search: "", locale: .backendDefault)
  361|      1|        let details = BindingWithPublisher(value: Loadable<Country.Details>.notRequested)
  362|      1|        sut.load(countryDetails: details.binding, country: Country.mockedData[0])
  363|      1|    }
  364|       |    
  365|       |    // MARK: - Helper
  366|       |    
  367|       |    private func recordAppStateUserDataUpdates(for timeInterval: TimeInterval = 0.5)
  368|      0|        -> AnyPublisher<[AppState.UserData], Never> {
  369|      0|        return Future<[AppState.UserData], Never> { (completion) in
  370|      0|            var updates = [AppState.UserData]()
  371|      0|            self.appState.map(\.userData)
  372|      0|                .sink { updates.append($0 )}
  373|      0|                .store(in: &self.subscriptions)
  374|      0|            DispatchQueue.main.asyncAfter(deadline: .now() + timeInterval) {
  375|      0|                completion(.success(updates))
  376|      0|            }
  377|      0|        }.eraseToAnyPublisher()
  378|      0|    }
  379|       |    
  380|       |    private func countryDetails(neighbors: [Country])
  381|      3|        -> (intermediate: Country.Details.Intermediate, details: Country.Details) {
  382|      3|        let intermediate = Country.Details.Intermediate(
  383|      3|            capital: "London",
  384|      3|            currencies: [Country.Currency(code: "12", symbol: "$", name: "US dollar")],
  385|      0|            borders: neighbors.map { $0.alpha3Code })
  386|      3|        let details = Country.Details(capital: intermediate.capital,
  387|      3|                                      currencies: intermediate.currencies,
  388|      3|                                      neighbors: neighbors)
  389|      3|        return (intermediate, details)
  390|      3|    }
  391|       |}
  392|       |
  393|       |extension Country: PrefixRemovable { }
  394|       |extension Country.Details: PrefixRemovable { }

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Interactors/ImagesInteractorTests.swift:
    1|       |//
    2|       |//  ImagesInteractorTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 10.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class ImagesInteractorTests: XCTestCase {
   14|       |    
   15|       |    var sut: RealImagesInteractor!
   16|       |    var mockedWebRepository: MockedImageWebRepository!
   17|      5|    var subscriptions = Set<AnyCancellable>()
   18|      5|    let testImageURL = URL(string: "https://test.com/test.png")!
   19|      5|    let testImage = UIColor.red.image(CGSize(width: 40, height: 40))
   20|       |    
   21|      5|    override func setUp() {
   22|      5|        mockedWebRepository = MockedImageWebRepository()
   23|      5|        sut = RealImagesInteractor(webRepository: mockedWebRepository)
   24|      5|        subscriptions = Set<AnyCancellable>()
   25|      5|    }
   26|       |    
   27|      4|    func expectRepoActions(_ actions: [MockedImageWebRepository.Action]) {
   28|      4|        mockedWebRepository.actions = .init(expected: actions)
   29|      4|    }
   30|       |    
   31|      4|    func verifyRepoActions(file: StaticString = #file, line: UInt = #line) {
   32|      4|        mockedWebRepository.verify(file: file, line: line)
   33|      4|    }
   34|       |    
   35|      1|    func test_loadImage_nilURL() {
   36|      1|        let image = BindingWithPublisher(value: Loadable<UIImage>.notRequested)
   37|      1|        expectRepoActions([])
   38|      1|        sut.load(image: image.binding, url: nil)
   39|      1|        let exp = XCTestExpectation(description: "Completion")
   40|      1|        image.updatesRecorder.sink { updates in
   41|      1|            XCTAssertEqual(updates, [
   42|      1|                .notRequested,
   43|      1|                .notRequested
   44|      1|            ])
   45|      1|            self.verifyRepoActions()
   46|      1|            exp.fulfill()
   47|      1|        }.store(in: &subscriptions)
   48|      1|        wait(for: [exp], timeout: 1)
   49|      1|    }
   50|       |    
   51|      1|    func test_loadImage_loadedFromWeb() {
   52|      1|        let image = BindingWithPublisher(value: Loadable<UIImage>.notRequested)
   53|      1|        mockedWebRepository.imageResponse = .success(testImage)
   54|      1|        expectRepoActions([.loadImage(testImageURL)])
   55|      1|        sut.load(image: image.binding, url: testImageURL)
   56|      1|        let exp = XCTestExpectation(description: "Completion")
   57|      1|        image.updatesRecorder.sink { updates in
   58|      1|            XCTAssertEqual(updates, [
   59|      1|                .notRequested,
   60|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
   61|      1|                .loaded(self.testImage)
   62|      1|            ])
   63|      1|            self.verifyRepoActions()
   64|      1|            exp.fulfill()
   65|      1|        }.store(in: &subscriptions)
   66|      1|        wait(for: [exp], timeout: 1)
   67|      1|    }
   68|       |    
   69|      1|    func test_loadImage_failed() {
   70|      1|        let image = BindingWithPublisher(value: Loadable<UIImage>.notRequested)
   71|      1|        let error = NSError.test
   72|      1|        mockedWebRepository.imageResponse = .failure(error)
   73|      1|        expectRepoActions([.loadImage(testImageURL)])
   74|      1|        sut.load(image: image.binding, url: testImageURL)
   75|      1|        let exp = XCTestExpectation(description: "Completion")
   76|      1|        image.updatesRecorder.sink { updates in
   77|      1|            XCTAssertEqual(updates, [
   78|      1|                .notRequested,
   79|      1|                .isLoading(last: nil, cancelBag: CancelBag()),
   80|      1|                .failed(error)
   81|      1|            ])
   82|      1|            self.verifyRepoActions()
   83|      1|            exp.fulfill()
   84|      1|        }.store(in: &subscriptions)
   85|      1|        wait(for: [exp], timeout: 1)
   86|      1|    }
   87|       |    
   88|      1|    func test_loadImage_hadLoadedImage() {
   89|      1|        let image = BindingWithPublisher(value: Loadable<UIImage>.loaded(testImage))
   90|      1|        let error = NSError.test
   91|      1|        mockedWebRepository.imageResponse = .failure(error)
   92|      1|        expectRepoActions([.loadImage(testImageURL)])
   93|      1|        sut.load(image: image.binding, url: testImageURL)
   94|      1|        let exp = XCTestExpectation(description: "Completion")
   95|      1|        image.updatesRecorder.sink { updates in
   96|      1|            XCTAssertEqual(updates, [
   97|      1|                .loaded(self.testImage),
   98|      1|                .isLoading(last: self.testImage, cancelBag: CancelBag()),
   99|      1|                .failed(error)
  100|      1|            ])
  101|      1|            self.verifyRepoActions()
  102|      1|            exp.fulfill()
  103|      1|        }.store(in: &subscriptions)
  104|      1|        wait(for: [exp], timeout: 1)
  105|      1|    }
  106|       |    
  107|      1|    func test_stubInteractor() {
  108|      1|        let sut = StubImagesInteractor()
  109|      1|        let image = BindingWithPublisher(value: Loadable<UIImage>.notRequested)
  110|      1|        sut.load(image: image.binding, url: testImageURL)
  111|      1|    }
  112|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Interactors/UserPermissionsInteractorTests.swift:
    1|       |//
    2|       |//  UserPermissionsInteractorTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 26.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |class UserPermissionsInteractorTests: XCTestCase {
   14|       |    
   15|      7|    var state = Store<AppState>(AppState())
   16|       |    var sut: RealUserPermissionsInteractor!
   17|       |    
   18|      7|    override func setUp() {
   19|      7|        state.bulkUpdate { $0 = AppState() }
   20|      7|    }
   21|       |    
   22|      4|    func delay(_ closure: @escaping () -> Void) {
   23|      4|        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2, execute: closure)
   24|      4|    }
   25|       |
   26|      1|    func test_noSideEffectOnInit() {
   27|      1|        let exp = XCTestExpectation(description: #function)
   28|      0|        sut = RealUserPermissionsInteractor(appState: state) {
   29|      0|            XCTFail()
   30|      0|        }
   31|      1|        delay {
   32|      1|            XCTAssertEqual(self.state.value, AppState())
   33|      1|            exp.fulfill()
   34|      1|        }
   35|      1|        wait(for: [exp], timeout: 0.5)
   36|      1|    }
   37|       |    
   38|       |    // MARK: - Push
   39|       |    
   40|      1|    func test_pushFirstResolveStatus() {
   41|      1|        XCTAssertEqual(AppState().permissions.push, .unknown)
   42|      1|        let exp = XCTestExpectation(description: #function)
   43|      0|        sut = RealUserPermissionsInteractor(appState: state) {
   44|      0|            XCTFail()
   45|      0|        }
   46|      1|        sut.resolveStatus(for: .pushNotifications)
   47|      1|        delay {
   48|      1|            XCTAssertNotEqual(self.state.value.permissions.push, .unknown)
   49|      1|            exp.fulfill()
   50|      1|        }
   51|      1|        wait(for: [exp], timeout: 0.5)
   52|      1|    }
   53|       |    
   54|      1|    func test_pushSecondResolveStatus() {
   55|      1|        XCTAssertEqual(AppState().permissions.push, .unknown)
   56|      1|        let exp = XCTestExpectation(description: #function)
   57|      0|        sut = RealUserPermissionsInteractor(appState: state) {
   58|      0|            XCTFail()
   59|      0|        }
   60|      1|        sut.resolveStatus(for: .pushNotifications)
   61|      1|        delay {
   62|      1|            self.sut.resolveStatus(for: .pushNotifications)
   63|      1|            XCTAssertNotEqual(self.state.value.permissions.push, .unknown)
   64|      1|            exp.fulfill()
   65|      1|        }
   66|      1|        wait(for: [exp], timeout: 0.5)
   67|      1|    }
   68|       |    
   69|      1|    func test_pushRequestPermissionNotDetermined() {
   70|      1|        state[\.permissions.push] = .notRequested
   71|      1|        let exp = XCTestExpectation(description: #function)
   72|      0|        sut = RealUserPermissionsInteractor(appState: state) {
   73|      0|            XCTFail()
   74|      0|        }
   75|      1|        sut.request(permission: .pushNotifications)
   76|      1|        delay {
   77|      1|            XCTAssertNotEqual(self.state.value.permissions.push, .unknown)
   78|      1|            exp.fulfill()
   79|      1|        }
   80|      1|        wait(for: [exp], timeout: 0.5)
   81|      1|    }
   82|       |    
   83|      1|    func test_pushRequestPermissionDenied() {
   84|      1|        state[\.permissions.push] = .denied
   85|      1|        let exp = XCTestExpectation(description: #function)
   86|      1|        sut = RealUserPermissionsInteractor(appState: state) {
   87|      1|            XCTAssertEqual(self.state.value.permissions.push, .denied)
   88|      1|            exp.fulfill()
   89|      1|        }
   90|      1|        sut.request(permission: .pushNotifications)
   91|      1|        wait(for: [exp], timeout: 0.5)
   92|      1|    }
   93|       |    
   94|      1|    func test_authorizationStatusMapping() {
   95|      1|        XCTAssertEqual(UNAuthorizationStatus.notDetermined.map, .notRequested)
   96|      1|        XCTAssertEqual(UNAuthorizationStatus.provisional.map, .notRequested)
   97|      1|        XCTAssertEqual(UNAuthorizationStatus.denied.map, .denied)
   98|      1|        XCTAssertEqual(UNAuthorizationStatus.authorized.map, .granted)
   99|      1|        XCTAssertEqual(UNAuthorizationStatus(rawValue: 10)?.map, .notRequested)
  100|      1|    }
  101|       |    
  102|       |    // MARK: - Stub
  103|       |    
  104|      1|    func test_stubUserPermissionsInteractor() {
  105|      1|        let sut = StubUserPermissionsInteractor()
  106|      1|        sut.request(permission: .pushNotifications)
  107|      1|        sut.resolveStatus(for: .pushNotifications)
  108|      1|    }
  109|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Mocks/Mock.swift:
    1|       |//
    2|       |//  Mock.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 07.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |@testable import CountriesSwiftUI
   11|       |
   12|       |protocol Mock {
   13|       |    associatedtype Action: Equatable
   14|       |    var actions: MockActions<Action> { get }
   15|       |    
   16|       |    func register(_ action: Action)
   17|       |    func verify(file: StaticString, line: UInt)
   18|       |}
   19|       |
   20|       |extension Mock {
   21|     62|    func register(_ action: Action) {
   22|     62|        actions.register(action)
   23|     62|    }
   24|       |    
   25|    155|    func verify(file: StaticString = #file, line: UInt = #line) {
   26|    155|        actions.verify(file: file, line: line)
   27|    155|    }
   28|       |}
   29|       |
   30|       |final class MockActions<Action> where Action: Equatable {
   31|       |    let expected: [Action]
   32|    242|    var factual: [Action] = []
   33|       |    
   34|    242|    init(expected: [Action]) {
   35|    242|        self.expected = expected
   36|    242|    }
   37|       |    
   38|     62|    fileprivate func register(_ action: Action) {
   39|     62|        factual.append(action)
   40|     62|    }
   41|       |    
   42|    155|    fileprivate func verify(file: StaticString, line: UInt) {
   43|    155|        if factual == expected { return }
   44|      2|        let factualNames = factual.map { "." + String(describing: $0) }
   45|      1|        let expectedNames = expected.map { "." + String(describing: $0) }
   46|      1|        XCTFail("\(name)\n\nExpected:\n\n\(expectedNames)\n\nReceived:\n\n\(factualNames)", file: file, line: line)
   47|      1|    }
   48|       |    
   49|      1|    private var name: String {
   50|      1|        let fullName = String(describing: self)
   51|      1|        let nameComponents = fullName.components(separatedBy: ".")
   52|      0|        return nameComponents.dropLast().last ?? fullName
   53|      1|    }
   54|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Mocks/MockedDBRepositories.swift:
    1|       |//
    2|       |//  MockedDBRepositories.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 18.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |// MARK: - CountriesWebRepository
   14|       |
   15|       |final class MockedCountriesDBRepository: Mock, CountriesDBRepository {
   16|       |    
   17|       |    enum Action: Equatable {
   18|       |        case hasLoadedCountries
   19|       |        case storeCountries([Country])
   20|       |        case fetchCountries(search: String, locale: Locale)
   21|       |        case storeCountryDetails(Country.Details.Intermediate)
   22|       |        case fetchCountryDetails(Country)
   23|       |    }
   24|     12|    var actions = MockActions<Action>(expected: [])
   25|       |    
   26|     12|    var hasLoadedCountriesResult: Result<Bool, Error> = .failure(MockError.valueNotSet)
   27|     12|    var storeCountriesResult: Result<Void, Error> = .failure(MockError.valueNotSet)
   28|     12|    var fetchCountriesResult: Result<LazyList<Country>, Error> = .failure(MockError.valueNotSet)
   29|     12|    var storeCountryDetailsResult: Result<Country.Details?, Error> = .failure(MockError.valueNotSet)
   30|     12|    var fetchCountryDetailsResult: Result<Country.Details?, Error> = .failure(MockError.valueNotSet)
   31|       |    
   32|       |    // MARK: - API
   33|       |    
   34|      6|    func hasLoadedCountries() -> AnyPublisher<Bool, Error> {
   35|      6|        register(.hasLoadedCountries)
   36|      6|        return hasLoadedCountriesResult.publish()
   37|      6|    }
   38|       |    
   39|      3|    func store(countries: [Country]) -> AnyPublisher<Void, Error> {
   40|      3|        register(.storeCountries(countries))
   41|      3|        return storeCountriesResult.publish()
   42|      3|    }
   43|       |    
   44|      4|    func countries(search: String, locale: Locale) -> AnyPublisher<LazyList<Country>, Error> {
   45|      4|        register(.fetchCountries(search: search, locale: locale))
   46|      4|        return fetchCountriesResult.publish()
   47|      4|    }
   48|       |    
   49|       |    func store(countryDetails: Country.Details.Intermediate,
   50|      3|               for country: Country) -> AnyPublisher<Country.Details?, Error> {
   51|      3|        register(.storeCountryDetails(countryDetails))
   52|      3|        return storeCountryDetailsResult.publish()
   53|      3|    }
   54|       |    
   55|      5|    func countryDetails(country: Country) -> AnyPublisher<Country.Details?, Error> {
   56|      5|        register(.fetchCountryDetails(country))
   57|      5|        return fetchCountryDetailsResult.publish()
   58|      5|    }
   59|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Mocks/MockedInteractors.swift:
    1|       |//
    2|       |//  MockedInteractors.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 07.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import SwiftUI
   11|       |import Combine
   12|       |import ViewInspector
   13|       |@testable import CountriesSwiftUI
   14|       |
   15|       |extension DIContainer.Interactors {
   16|       |    static func mocked(
   17|       |        countriesInteractor: [MockedCountriesInteractor.Action] = [],
   18|       |        imagesInteractor: [MockedImagesInteractor.Action] = [],
   19|       |        permissionsInteractor: [MockedUserPermissionsInteractor.Action] = []
   20|     29|    ) -> DIContainer.Interactors {
   21|     29|        .init(countriesInteractor: MockedCountriesInteractor(expected: countriesInteractor),
   22|     29|              imagesInteractor: MockedImagesInteractor(expected: imagesInteractor),
   23|     29|              userPermissionsInteractor: MockedUserPermissionsInteractor(expected: permissionsInteractor))
   24|     29|    }
   25|       |    
   26|     30|    func verify(file: StaticString = #file, line: UInt = #line) {
   27|     30|        (countriesInteractor as? MockedCountriesInteractor)?
   28|     30|            .verify(file: file, line: line)
   29|     30|        (imagesInteractor as? MockedImagesInteractor)?
   30|     30|            .verify(file: file, line: line)
   31|     30|        (userPermissionsInteractor as? MockedUserPermissionsInteractor)?
   32|     30|            .verify(file: file, line: line)
   33|     30|    }
   34|       |}
   35|       |
   36|       |// MARK: - CountriesInteractor
   37|       |
   38|       |struct MockedCountriesInteractor: Mock, CountriesInteractor {
   39|       |    
   40|       |    enum Action: Equatable {
   41|       |        case refreshCountriesList
   42|       |        case loadCountries(search: String, locale: Locale)
   43|       |        case loadCountryDetails(Country)
   44|       |    }
   45|       |    
   46|       |    let actions: MockActions<Action>
   47|       |    
   48|     39|    init(expected: [Action]) {
   49|     39|        self.actions = .init(expected: expected)
   50|     39|    }
   51|       |    
   52|      1|    func refreshCountriesList() -> AnyPublisher<Void, Error> {
   53|      1|        register(.refreshCountriesList)
   54|      1|        return Just<Void>.withErrorType(Error.self)
   55|      1|    }
   56|       |    
   57|      1|    func load(countries: LoadableSubject<LazyList<Country>>, search: String, locale: Locale) {
   58|      1|        register(.loadCountries(search: search, locale: locale))
   59|      1|    }
   60|       |    
   61|      2|    func load(countryDetails: LoadableSubject<Country.Details>, country: Country) {
   62|      2|        register(.loadCountryDetails(country))
   63|      2|    }
   64|       |}
   65|       |
   66|       |// MARK: - ImagesInteractor
   67|       |
   68|       |struct MockedImagesInteractor: Mock, ImagesInteractor {
   69|       |    
   70|       |    enum Action: Equatable {
   71|       |        case loadImage(URL?)
   72|       |    }
   73|       |    
   74|       |    let actions: MockActions<Action>
   75|       |    
   76|     39|    init(expected: [Action]) {
   77|     39|        self.actions = .init(expected: expected)
   78|     39|    }
   79|       |    
   80|      6|    func load(image: LoadableSubject<UIImage>, url: URL?) {
   81|      6|        register(.loadImage(url))
   82|      6|    }
   83|       |}
   84|       |
   85|       |// MARK: - ImagesInteractor
   86|       |
   87|       |class MockedUserPermissionsInteractor: Mock, UserPermissionsInteractor {
   88|       |    
   89|       |    enum Action: Equatable {
   90|       |        case resolveStatus(Permission)
   91|       |        case request(Permission)
   92|       |    }
   93|       |    
   94|       |    let actions: MockActions<Action>
   95|       |    
   96|     39|    init(expected: [Action]) {
   97|     39|        self.actions = .init(expected: expected)
   98|     39|    }
   99|       |    
  100|      2|    func resolveStatus(for permission: Permission) {
  101|      2|        register(.resolveStatus(permission))
  102|      2|    }
  103|       |    
  104|      1|    func request(permission: Permission) {
  105|      1|        register(.request(permission))
  106|      1|    }
  107|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Mocks/MockedPersistentStore.swift:
    1|       |//
    2|       |//  MockedPersistentStore.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 19.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import CoreData
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class MockedPersistentStore: Mock, PersistentStore {
   14|       |    struct ContextSnapshot: Equatable {
   15|       |        let inserted: Int
   16|       |        let updated: Int
   17|       |        let deleted: Int
   18|       |    }
   19|       |    enum Action: Equatable {
   20|       |        case count
   21|       |        case fetchCountries(ContextSnapshot)
   22|       |        case fetchCountryDetails(ContextSnapshot)
   23|       |        case update(ContextSnapshot)
   24|       |    }
   25|      7|    var actions = MockActions<Action>(expected: [])
   26|       |    
   27|       |    var countResult: Int = 0
   28|       |    
   29|      7|    deinit {
   30|      7|        destroyDatabase()
   31|      7|    }
   32|       |    
   33|       |    // MARK: - count
   34|       |    
   35|      2|    func count<T>(_ fetchRequest: NSFetchRequest<T>) -> AnyPublisher<Int, Error> {
   36|      2|        register(.count)
   37|      2|        return Just<Int>.withErrorType(countResult, Error.self).publish()
   38|      2|    }
   39|       |    
   40|       |    // MARK: - fetch
   41|       |    
   42|       |    func fetch<T, V>(_ fetchRequest: NSFetchRequest<T>,
   43|      4|                     map: @escaping (T) throws -> V?) -> AnyPublisher<LazyList<V>, Error> {
   44|      4|        do {
   45|      4|            let context = container.viewContext
   46|      4|            context.reset()
   47|      4|            let result = try context.fetch(fetchRequest)
   48|      4|            if T.self is CountryMO.Type {
   49|      3|                register(.fetchCountries(context.snapshot))
   50|      4|            } else if T.self is CountryDetailsMO.Type {
   51|      1|                register(.fetchCountryDetails(context.snapshot))
   52|      4|            } else {
   53|      0|                fatalError("Add a case for \(String(describing: T.self))")
   54|      4|            }
   55|      7|            let list = LazyList<V>(count: result.count, useCache: true, { index in
   56|      7|                try map(result[index])
   57|      7|            })
   58|      4|            return Just<LazyList<V>>.withErrorType(list, Error.self).publish()
   59|      0|        } catch {
   60|      0|            return Fail<LazyList<V>, Error>(error: error).publish()
   61|      0|        }
   62|      0|    }
   63|       |    
   64|       |    // MARK: - update
   65|       |    
   66|      2|    func update<Result>(_ operation: @escaping DBOperation<Result>) -> AnyPublisher<Result, Error> {
   67|      2|        do {
   68|      2|            let context = container.viewContext
   69|      2|            context.reset()
   70|      2|            let result = try operation(context)
   71|      2|            register(.update(context.snapshot))
   72|      2|            return Just(result).setFailureType(to: Error.self).publish()
   73|      0|        } catch {
   74|      0|            return Fail<Result, Error>(error: error).publish()
   75|      0|        }
   76|      0|    }
   77|       |    
   78|       |    // MARK: -
   79|       |    
   80|      5|    func preloadData(_ preload: (NSManagedObjectContext) throws -> Void) throws {
   81|      5|        try preload(container.viewContext)
   82|      5|        if container.viewContext.hasChanges {
   83|      5|            try container.viewContext.save()
   84|      5|        }
   85|      5|        container.viewContext.reset()
   86|      5|    }
   87|       |    
   88|       |    // MARK: - Database
   89|       |    
   90|      7|    private let dbVersion = CoreDataStack.Version(CoreDataStack.Version.actual)
   91|       |    
   92|     28|    private var dbURL: URL {
   93|     28|        guard let url = dbVersion.dbFileURL(.cachesDirectory, .userDomainMask)
   94|     28|            else { fatalError() }
   95|     28|        return url
   96|     28|    }
   97|       |    
   98|      7|    private lazy var container: NSPersistentContainer = {
   99|      7|        let container = NSPersistentContainer(name: dbVersion.modelName)
  100|      7|        try? FileManager().removeItem(at: dbURL)
  101|      7|        let store = NSPersistentStoreDescription(url: dbURL)
  102|      7|        container.persistentStoreDescriptions = [store]
  103|      7|        let group = DispatchGroup()
  104|      7|        group.enter()
  105|      7|        container.loadPersistentStores { (desc, error) in
  106|      0|            if let error = error {
  107|      0|                fatalError("\(error)")
  108|      7|            }
  109|      7|            group.leave()
  110|      7|        }
  111|      7|        group.wait()
  112|      7|        container.viewContext.mergePolicy = NSOverwriteMergePolicy
  113|      7|        container.viewContext.undoManager = nil
  114|      7|        return container
  115|      7|    }()
  116|       |    
  117|      7|    private func destroyDatabase() {
  118|      7|        try? container.persistentStoreCoordinator
  119|      7|            .destroyPersistentStore(at: dbURL, ofType: NSSQLiteStoreType, options: nil)
  120|      7|        try? FileManager().removeItem(at: dbURL)
  121|      7|    }
  122|       |}
  123|       |
  124|       |extension NSManagedObjectContext {
  125|      6|    var snapshot: MockedPersistentStore.ContextSnapshot {
  126|      6|        .init(inserted: insertedObjects.count,
  127|      6|              updated: updatedObjects.count,
  128|      6|              deleted: deletedObjects.count)
  129|      6|    }
  130|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Mocks/MockedSystemEventsHandler.swift:
    1|       |//
    2|       |//  MockedSystemEventsHandler.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 26.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |// MARK: - SystemEventsHandler
   14|       |
   15|       |final class MockedSystemEventsHandler: Mock, SystemEventsHandler {
   16|       |    enum Action: Equatable {
   17|       |        case openURL
   18|       |        case becomeActive
   19|       |        case resignActive
   20|       |        case pushRegistration
   21|       |        case recevieRemoteNotification
   22|       |    }
   23|      6|    var actions = MockActions<Action>(expected: [])
   24|       |    
   25|      6|    init(expected: [Action]) {
   26|      6|        self.actions = .init(expected: expected)
   27|      6|    }
   28|       |    
   29|      1|    func sceneOpenURLContexts(_ urlContexts: Set<UIOpenURLContext>) {
   30|      1|        register(.openURL)
   31|      1|    }
   32|       |    
   33|      1|    func sceneDidBecomeActive() {
   34|      1|        register(.becomeActive)
   35|      1|    }
   36|       |    
   37|      1|    func sceneWillResignActive() {
   38|      1|        register(.resignActive)
   39|      1|    }
   40|       |    
   41|      2|    func handlePushRegistration(result: Result<Data, Error>) {
   42|      2|        register(.pushRegistration)
   43|      2|    }
   44|       |    
   45|       |    func appDidReceiveRemoteNotification(payload: NotificationPayload,
   46|      1|                                         fetchCompletion: @escaping FetchCompletion) {
   47|      1|        register(.recevieRemoteNotification)
   48|      1|    }
   49|       |}
   50|       |
   51|       |// MARK: - PushNotificationsHandler
   52|       |
   53|       |final class DummyPushNotificationsHandler: PushNotificationsHandler { }
   54|       |
   55|       |// MARK: - DeepLinksHandler
   56|       |
   57|       |final class MockedDeepLinksHandler: Mock, DeepLinksHandler {
   58|       |    enum Action: Equatable {
   59|       |        case open(DeepLink)
   60|       |    }
   61|     13|    var actions = MockActions<Action>(expected: [])
   62|       |    
   63|     13|    init(expected: [Action]) {
   64|     13|        self.actions = .init(expected: expected)
   65|     13|    }
   66|       |    
   67|      2|    func open(deepLink: DeepLink) {
   68|      2|        register(.open(deepLink))
   69|      2|    }
   70|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Mocks/MockedWebRepositories.swift:
    1|       |//
    2|       |//  MockedWebRepositories.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 31.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |class TestWebRepository: WebRepository {
   14|     37|    let session: URLSession = .mockedResponsesOnly
   15|       |    let baseURL = "https://test.com"
   16|     37|    let bgQueue = DispatchQueue(label: "test")
   17|       |}
   18|       |
   19|       |// MARK: - CountriesWebRepository
   20|       |
   21|       |final class MockedCountriesWebRepository: TestWebRepository, Mock, CountriesWebRepository {
   22|       |    
   23|       |    enum Action: Equatable {
   24|       |        case loadCountries
   25|       |        case loadCountryDetails(Country)
   26|       |    }
   27|     12|    var actions = MockActions<Action>(expected: [])
   28|       |    
   29|     12|    var countriesResponse: Result<[Country], Error> = .failure(MockError.valueNotSet)
   30|     12|    var detailsResponse: Result<Country.Details.Intermediate, Error> = .failure(MockError.valueNotSet)
   31|       |    
   32|      4|    func loadCountries() -> AnyPublisher<[Country], Error> {
   33|      4|        register(.loadCountries)
   34|      4|        return countriesResponse.publish()
   35|      4|    }
   36|       |    
   37|      4|    func loadCountryDetails(country: Country) -> AnyPublisher<Country.Details.Intermediate, Error> {
   38|      4|        register(.loadCountryDetails(country))
   39|      4|        return detailsResponse.publish()
   40|      4|    }
   41|       |}
   42|       |
   43|       |// MARK: - ImageWebRepository
   44|       |
   45|       |final class MockedImageWebRepository: TestWebRepository, Mock, ImageWebRepository {
   46|       |    
   47|       |    enum Action: Equatable {
   48|       |        case loadImage(URL?)
   49|       |    }
   50|      7|    var actions = MockActions<Action>(expected: [])
   51|       |    
   52|      7|    var imageResponse: Result<UIImage, Error> = .failure(MockError.valueNotSet)
   53|       |    
   54|      3|    func load(imageURL: URL, width: Int) -> AnyPublisher<UIImage, Error> {
   55|      3|        register(.loadImage(imageURL))
   56|      3|        return imageResponse.publish()
   57|      3|    }
   58|       |}
   59|       |
   60|       |// MARK: - PushTokenWebRepository
   61|       |
   62|       |final class MockedPushTokenWebRepository: TestWebRepository, Mock, PushTokenWebRepository {
   63|       |    enum Action: Equatable {
   64|       |        case register(Data)
   65|       |    }
   66|     10|    var actions = MockActions<Action>(expected: [])
   67|       |    
   68|     10|    init(expected: [Action]) {
   69|     10|        self.actions = .init(expected: expected)
   70|     10|    }
   71|       |    
   72|      1|    func register(devicePushToken: Data) -> AnyPublisher<Void, Error> {
   73|      1|        register(.register(devicePushToken))
   74|      1|        return Just<Void>.withErrorType(Error.self)
   75|      1|    }
   76|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/NetworkMocking/MockedResponse.swift:
    1|       |//
    2|       |//  MockedResponse.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 30.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |@testable import CountriesSwiftUI
   11|       |
   12|       |extension RequestMocking {
   13|       |    struct MockedResponse {
   14|       |        let url: URL
   15|       |        let result: Result<Data, Swift.Error>
   16|       |        let httpCode: HTTPCode
   17|       |        let headers: [String: String]
   18|       |        let loadingTime: TimeInterval
   19|       |        let customResponse: URLResponse?
   20|       |    }
   21|       |}
   22|       |
   23|       |extension RequestMocking.MockedResponse {
   24|       |    enum Error: Swift.Error {
   25|       |        case failedMockCreation
   26|       |    }
   27|       |    
   28|       |    init<T>(apiCall: APICall, baseURL: String,
   29|       |            result: Result<T, Swift.Error>,
   30|       |            httpCode: HTTPCode = 200,
   31|       |            headers: [String: String] = ["Content-Type": "application/json"],
   32|       |            loadingTime: TimeInterval = 0.1
   33|      7|    ) throws where T: Encodable {
   34|      7|        guard let url = try apiCall.urlRequest(baseURL: baseURL).url
   35|      7|            else { throw Error.failedMockCreation }
   36|      7|        self.url = url
   37|      7|        switch result {
   38|      6|        case let .success(value):
   39|      6|            self.result = .success(try JSONEncoder().encode(value))
   40|      1|        case let .failure(error):
   41|      1|            self.result = .failure(error)
   42|      7|        }
   43|      7|        self.httpCode = httpCode
   44|      7|        self.headers = headers
   45|      7|        self.loadingTime = loadingTime
   46|      7|        customResponse = nil
   47|      7|    }
   48|       |    
   49|      1|    init(apiCall: APICall, baseURL: String, customResponse: URLResponse) throws {
   50|      1|        guard let url = try apiCall.urlRequest(baseURL: baseURL).url
   51|      1|            else { throw Error.failedMockCreation }
   52|      1|        self.url = url
   53|      1|        result = .success(Data())
   54|      1|        httpCode = 200
   55|      1|        headers = [String: String]()
   56|      1|        loadingTime = 0
   57|      1|        self.customResponse = customResponse
   58|      1|    }
   59|       |    
   60|     11|    init(url: URL, result: Result<Data, Swift.Error>) {
   61|     11|        self.url = url
   62|     11|        self.result = result
   63|     11|        httpCode = 200
   64|     11|        headers = [String: String]()
   65|     11|        loadingTime = 0
   66|     11|        customResponse = nil
   67|     11|    }
   68|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/NetworkMocking/RequestMocking.swift:
    1|       |//
    2|       |//  RequestMocking.swift
    3|       |//  CountriesSwiftUI
    4|       |//
    5|       |//  Created by Alexey Naumov on 30.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension URLSession {
   12|     48|    static var mockedResponsesOnly: URLSession {
   13|     48|        let configuration = URLSessionConfiguration.default
   14|     48|        configuration.protocolClasses = [RequestMocking.self, RequestBlocking.self]
   15|     48|        configuration.timeoutIntervalForRequest = 1
   16|     48|        configuration.timeoutIntervalForResource = 1
   17|     48|        return URLSession(configuration: configuration)
   18|     48|    }
   19|       |}
   20|       |
   21|       |extension RequestMocking {
   22|       |    static private var mocks: [MockedResponse] = []
   23|       |    
   24|     19|    static func add(mock: MockedResponse) {
   25|     19|        mocks.append(mock)
   26|     19|    }
   27|       |    
   28|     18|    static func removeAllMocks() {
   29|     18|        mocks.removeAll()
   30|     18|    }
   31|       |    
   32|     38|    static private func mock(for request: URLRequest) -> MockedResponse? {
   33|     52|        return mocks.first { $0.url == request.url }
   34|     38|    }
   35|       |}
   36|       |
   37|       |// MARK: - RequestMocking
   38|       |
   39|       |final class RequestMocking: URLProtocol {
   40|       |
   41|     19|    override class func canInit(with request: URLRequest) -> Bool {
   42|     19|        return mock(for: request) != nil
   43|     19|    }
   44|       |
   45|     19|    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
   46|     19|        return request
   47|     19|    }
   48|       |    
   49|       |    // swiftlint:disable identifier_name
   50|      0|    override class func requestIsCacheEquivalent(_ a: URLRequest, to b: URLRequest) -> Bool {
   51|      0|    // swiftlint:enable identifier_name
   52|      0|        return false
   53|      0|    }
   54|       |
   55|     19|    override func startLoading() {
   56|     19|        if let mock = RequestMocking.mock(for: request),
   57|     19|            let url = request.url,
   58|     19|            let response = mock.customResponse ??
   59|     18|                HTTPURLResponse(url: url,
   60|     18|                statusCode: mock.httpCode,
   61|     18|                httpVersion: "HTTP/1.1",
   62|     19|                headerFields: mock.headers) {
   63|     19|            DispatchQueue.main.asyncAfter(deadline: .now() + mock.loadingTime) { [weak self] in
   64|     19|                guard let self = self else { return }
   65|     19|                self.client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
   66|     19|                switch mock.result {
   67|     18|                case let .success(data):
   68|     18|                    self.client?.urlProtocol(self, didLoad: data)
   69|     18|                    self.client?.urlProtocolDidFinishLoading(self)
   70|      1|                case let .failure(error):
   71|      1|                    let failure = NSError(domain: NSURLErrorDomain, code: 1,
   72|      1|                                          userInfo: [NSUnderlyingErrorKey: error])
   73|      1|                    self.client?.urlProtocol(self, didFailWithError: failure)
   74|     19|                }
   75|     19|            }
   76|     19|        }
   77|     19|    }
   78|       |
   79|     19|    override func stopLoading() { }
   80|       |}
   81|       |
   82|       |// MARK: - RequestBlocking
   83|       |
   84|       |private class RequestBlocking: URLProtocol {
   85|       |    enum Error: Swift.Error {
   86|       |        case requestBlocked
   87|       |    }
   88|       |    
   89|      0|    override class func canInit(with request: URLRequest) -> Bool {
   90|      0|        return true
   91|      0|    }
   92|       |
   93|      0|    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
   94|      0|        return request
   95|      0|    }
   96|       |
   97|      0|    override func startLoading() {
   98|      0|        DispatchQueue(label: "").async {
   99|      0|            self.client?.urlProtocol(self, didFailWithError: Error.requestBlocked)
  100|      0|        }
  101|      0|    }
  102|      0|    override func stopLoading() { }
  103|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Persistence/CoreDataStackTests.swift:
    1|       |//
    2|       |//  CoreDataStackTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 19.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |class CoreDataStackTests: XCTestCase {
   14|       |    
   15|       |    var sut: CoreDataStack!
   16|      6|    let testDirectory: FileManager.SearchPathDirectory = .cachesDirectory
   17|      0|    var dbVersion: UInt { fatalError("Override") }
   18|      6|    var cancelBag = CancelBag()
   19|       |    
   20|      6|    override func setUp() {
   21|      6|        eraseDBFiles()
   22|      6|        sut = CoreDataStack(directory: testDirectory, version: dbVersion)
   23|      6|    }
   24|       |    
   25|      6|    override func tearDown() {
   26|      6|        cancelBag = CancelBag()
   27|      6|        sut = nil
   28|      6|        eraseDBFiles()
   29|      6|    }
   30|       |    
   31|     12|    func eraseDBFiles() {
   32|     12|        let version = CoreDataStack.Version(dbVersion)
   33|     12|        if let url = version.dbFileURL(testDirectory, .userDomainMask) {
   34|     12|            try? FileManager().removeItem(at: url)
   35|     12|        }
   36|     12|    }
   37|       |}
   38|       |
   39|       |// MARK: - Version 1
   40|       |
   41|       |final class CoreDataStackV1Tests: CoreDataStackTests {
   42|       |    
   43|     19|    override var dbVersion: UInt { 1 }
   44|       |
   45|      1|    func test_initialization() {
   46|      1|        let exp = XCTestExpectation(description: #function)
   47|      1|        let request = CountryMO.newFetchRequest()
   48|      1|        request.predicate = NSPredicate(value: true)
   49|      1|        request.fetchLimit = 1
   50|      0|        sut.fetch(request) { _ -> Int? in
   51|      0|            return nil
   52|      0|        }
   53|      1|        .sinkToResult { result in
   54|      1|            result.assertSuccess(value: LazyList<Int>.empty)
   55|      1|            exp.fulfill()
   56|      1|        }
   57|      1|        .store(in: cancelBag)
   58|      1|        wait(for: [exp], timeout: 1)
   59|      1|    }
   60|       |    
   61|      1|    func test_inaccessibleDirectory() {
   62|      1|        let sut = CoreDataStack(directory: .adminApplicationDirectory,
   63|      1|                                domainMask: .systemDomainMask, version: dbVersion)
   64|      1|        let exp = XCTestExpectation(description: #function)
   65|      1|        let request = CountryMO.newFetchRequest()
   66|      1|        request.predicate = NSPredicate(value: true)
   67|      1|        request.fetchLimit = 1
   68|      0|        sut.fetch(request) { _ -> Int? in
   69|      0|            return nil
   70|      0|        }
   71|      1|        .sinkToResult { result in
   72|      1|            result.assertFailure()
   73|      1|            exp.fulfill()
   74|      1|        }
   75|      1|        .store(in: cancelBag)
   76|      1|        wait(for: [exp], timeout: 1)
   77|      1|    }
   78|       |    
   79|      1|    func test_counting_onEmptyStore() {
   80|      1|        let request = CountryMO.newFetchRequest()
   81|      1|        request.predicate = NSPredicate(value: true)
   82|      1|        let exp = XCTestExpectation(description: #function)
   83|      1|        sut.count(request)
   84|      1|        .sinkToResult { result in
   85|      1|            result.assertSuccess(value: 0)
   86|      1|            exp.fulfill()
   87|      1|        }
   88|      1|        .store(in: cancelBag)
   89|      1|        wait(for: [exp], timeout: 1)
   90|      1|    }
   91|       |    
   92|      1|    func test_storing_and_countring() {
   93|      1|        let countries = Country.mockedData
   94|      1|        
   95|      1|        let request = CountryMO.newFetchRequest()
   96|      1|        request.predicate = NSPredicate(value: true)
   97|      1|        
   98|      1|        let exp = XCTestExpectation(description: #function)
   99|      1|        sut.update { context in
  100|      3|            countries.forEach {
  101|      3|                $0.store(in: context)
  102|      3|            }
  103|      1|        }
  104|      1|        .flatMap { _ in
  105|      1|            self.sut.count(request)
  106|      1|        }
  107|      1|        .sinkToResult { result in
  108|      1|            result.assertSuccess(value: countries.count)
  109|      1|            exp.fulfill()
  110|      1|        }
  111|      1|        .store(in: cancelBag)
  112|      1|        wait(for: [exp], timeout: 1)
  113|      1|    }
  114|       |    
  115|      1|    func test_storing_exception() {
  116|      1|        let exp = XCTestExpectation(description: #function)
  117|      1|        sut.update { context in
  118|      1|            throw NSError.test
  119|      1|        }
  120|      1|        .sinkToResult { result in
  121|      1|            result.assertFailure(NSError.test.localizedDescription)
  122|      1|            exp.fulfill()
  123|      1|        }
  124|      1|        .store(in: cancelBag)
  125|      1|        wait(for: [exp], timeout: 1)
  126|      1|    }
  127|       |    
  128|      1|    func test_fetching() {
  129|      1|        let countries = Country.mockedData
  130|      1|        let exp = XCTestExpectation(description: #function)
  131|      1|        sut
  132|      1|            .update { context in
  133|      3|                countries.forEach {
  134|      3|                    $0.store(in: context)
  135|      3|                }
  136|      1|            }
  137|      1|            .flatMap { _ -> AnyPublisher<LazyList<Country>, Error> in
  138|      1|                let request = CountryMO.newFetchRequest()
  139|      1|                request.predicate = NSPredicate(format: "alpha3code == %@", countries[0].alpha3Code)
  140|      1|                return self.sut.fetch(request) {
  141|      1|                    Country(managedObject: $0)
  142|      1|                }
  143|      1|            }
  144|      1|            .sinkToResult { result in
  145|      1|                result.assertSuccess(value: LazyList<Country>(
  146|      1|                    count: 1, useCache: false, { _ in countries[0] })
  147|      1|                )
  148|      1|                exp.fulfill()
  149|      1|            }
  150|      1|            .store(in: cancelBag)
  151|      1|        wait(for: [exp], timeout: 1)
  152|      1|    }
  153|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Repositories/CountriesDBRepositoryTests.swift:
    1|       |//
    2|       |//  CountriesDBRepositoryTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 19.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |class CountriesDBRepositoryTests: XCTestCase {
   14|       |    
   15|       |    var mockedStore: MockedPersistentStore!
   16|       |    var sut: RealCountriesDBRepository!
   17|      7|    var cancelBag = CancelBag()
   18|       |    
   19|      7|    override func setUp() {
   20|      7|        mockedStore = MockedPersistentStore()
   21|      7|        sut = RealCountriesDBRepository(persistentStore: mockedStore)
   22|      7|        mockedStore.verify()
   23|      7|    }
   24|       |    
   25|      7|    override func tearDown() {
   26|      7|        cancelBag = CancelBag()
   27|      7|        sut = nil
   28|      7|        mockedStore = nil
   29|      7|    }
   30|       |}
   31|       |
   32|       |// MARK: - Countries list
   33|       |    
   34|       |final class CountriesListDBRepoTests: CountriesDBRepositoryTests {
   35|       |
   36|      1|    func test_hasLoadedCountries() {
   37|      1|        mockedStore.actions = .init(expected: [
   38|      1|            .count,
   39|      1|            .count
   40|      1|        ])
   41|      1|        let exp = XCTestExpectation(description: #function)
   42|      1|        mockedStore.countResult = 0
   43|      1|        sut.hasLoadedCountries()
   44|      1|            .flatMap { value -> AnyPublisher<Bool, Error> in
   45|      1|                XCTAssertFalse(value)
   46|      1|                self.mockedStore.countResult = 10
   47|      1|                return self.sut.hasLoadedCountries()
   48|      1|            }
   49|      1|            .sinkToResult { result in
   50|      1|                result.assertSuccess(value: true)
   51|      1|                self.mockedStore.verify()
   52|      1|                exp.fulfill()
   53|      1|            }
   54|      1|            .store(in: cancelBag)
   55|      1|        wait(for: [exp], timeout: 0.5)
   56|      1|    }
   57|       |    
   58|      1|    func test_storeCountries() {
   59|      1|        let countries = Country.mockedData
   60|      1|        mockedStore.actions = .init(expected: [
   61|      1|            .update(.init(inserted: countries.count, updated: 0, deleted: 0))
   62|      1|        ])
   63|      1|        let exp = XCTestExpectation(description: #function)
   64|      1|        sut.store(countries: countries)
   65|      1|            .sinkToResult { result in
   66|      1|                result.assertSuccess()
   67|      1|                self.mockedStore.verify()
   68|      1|                exp.fulfill()
   69|      1|            }
   70|      1|            .store(in: cancelBag)
   71|      1|        wait(for: [exp], timeout: 0.5)
   72|      1|    }
   73|       |    
   74|      1|    func test_fetchAllCountries() throws {
   75|      1|        let countries = Country.mockedData
   76|      3|        let sortedCountries = countries.sorted(by: { $0.name < $1.name })
   77|      1|        mockedStore.actions = .init(expected: [
   78|      1|            .fetchCountries(.init(inserted: 0, updated: 0, deleted: 0))
   79|      1|        ])
   80|      1|        try mockedStore.preloadData { context in
   81|      3|            countries.forEach { $0.store(in: context) }
   82|      1|        }
   83|      1|        let exp = XCTestExpectation(description: #function)
   84|      1|        sut
   85|      1|            .countries(search: "", locale: .backendDefault)
   86|      1|            .sinkToResult { result in
   87|      1|                result.assertSuccess(value: sortedCountries.lazyList)
   88|      1|                self.mockedStore.verify()
   89|      1|                exp.fulfill()
   90|      1|            }
   91|      1|            .store(in: cancelBag)
   92|      1|        wait(for: [exp], timeout: 0.5)
   93|      1|    }
   94|       |    
   95|      1|    func test_fetchInNames() throws {
   96|      1|        let countries = Country.testLocalized
   97|      1|        mockedStore.actions = .init(expected: [
   98|      1|            .fetchCountries(.init(inserted: 0, updated: 0, deleted: 0))
   99|      1|        ])
  100|      1|        try mockedStore.preloadData { context in
  101|      3|            countries.forEach { $0.store(in: context) }
  102|      1|        }
  103|      1|        let exp = XCTestExpectation(description: #function)
  104|      1|        sut
  105|      1|            .countries(search: "nited stat", locale: Locale(identifier: "fr"))
  106|      1|            .sinkToResult { result in
  107|      1|                let expected = [countries[0]]
  108|      1|                result.assertSuccess(value: expected.lazyList)
  109|      1|                self.mockedStore.verify()
  110|      1|                exp.fulfill()
  111|      1|            }
  112|      1|            .store(in: cancelBag)
  113|      1|        wait(for: [exp], timeout: 0.5)
  114|      1|    }
  115|       |    
  116|      1|    func test_fetchInTranspaltions() throws {
  117|      1|        let countries = Country.testLocalized
  118|      1|        mockedStore.actions = .init(expected: [
  119|      1|            .fetchCountries(.init(inserted: 0, updated: 0, deleted: 0))
  120|      1|        ])
  121|      1|        try mockedStore.preloadData { context in
  122|      3|            countries.forEach { $0.store(in: context) }
  123|      1|        }
  124|      1|        let exp = XCTestExpectation(description: #function)
  125|      1|        sut
  126|      1|            .countries(search: "in frÃ©nch", locale: Locale(identifier: "fr"))
  127|      1|            .sinkToResult { result in
  128|      1|                let expected = [countries[2], countries[0]]
  129|      1|                result.assertSuccess(value: expected.lazyList)
  130|      1|                self.mockedStore.verify()
  131|      1|                exp.fulfill()
  132|      1|            }
  133|      1|            .store(in: cancelBag)
  134|      1|        wait(for: [exp], timeout: 0.5)
  135|      1|    }
  136|       |}
  137|       |
  138|       |private extension Country {
  139|      6|    static var testLocalized: [Country] {
  140|      6|        [
  141|      6|        Country(name: "United States",
  142|      6|                translations: ["fr": "United States in FrÃ©nch",
  143|      6|                               "ja": "Unitd States in Japaneese"],
  144|      6|                population: 125000000,
  145|      6|                flag: URL(string: "https://restcountries.eu/data/usa.svg"),
  146|      6|                alpha3Code: "USA"),
  147|      6|        Country(name: "Canada",
  148|      6|                translations: ["ja": "Canada not in French"],
  149|      6|                population: 57600000,
  150|      6|                flag: nil,
  151|      6|                alpha3Code: "CAN"),
  152|      6|        Country(name: "Georgia",
  153|      6|            translations: ["fr": "Georgia in French",
  154|      6|                           "ja": "United States not in Japaneese"],
  155|      6|            population: 2340000,
  156|      6|            flag: nil,
  157|      6|            alpha3Code: "GEO")
  158|      6|        ]
  159|      6|    }
  160|       |}
  161|       |
  162|       |private extension Country.Details {
  163|      2|    static var test: Country.Details {
  164|      2|        return Country.Details(
  165|      2|            capital: "Sin City",
  166|      2|            currencies: [Country.Currency(code: "code", symbol: "$", name: "USD")],
  167|      2|            neighbors: Array(Country.testLocalized[0..<2])
  168|      2|                .sorted(by: { $0.name < $1.name }))
  169|      2|    }
  170|       |}
  171|       |
  172|       |// MARK: - Countries list
  173|       |    
  174|       |final class CountryDetailsDBRepoTests: CountriesDBRepositoryTests {
  175|       |    
  176|      1|    func test_storeCountryDetails() throws {
  177|      1|        let details = Country.Details.test
  178|      1|        let intermediate = Country.Details.Intermediate(
  179|      1|            capital: details.capital, currencies: details.currencies,
  180|      2|            borders: details.neighbors.map { $0.alpha3Code })
  181|      1|        let parentCountry = Country.testLocalized[2]
  182|      1|        mockedStore.actions = .init(expected: [
  183|      1|            .update(.init(inserted: 1 + details.currencies.count, // self + currencies
  184|      1|                          updated: details.neighbors.count + 1, // neighbors + parent
  185|      1|                          deleted: 0))
  186|      1|        ])
  187|      1|        try mockedStore.preloadData { context in
  188|      1|            parentCountry.store(in: context)
  189|      2|            details.neighbors.forEach { $0.store(in: context) }
  190|      1|        }
  191|      1|        let exp = XCTestExpectation(description: #function)
  192|      1|        sut.store(countryDetails: intermediate, for: parentCountry)
  193|      1|            .sinkToResult { result in
  194|      1|                result.assertSuccess(value: details)
  195|      1|                self.mockedStore.verify()
  196|      1|                exp.fulfill()
  197|      1|            }
  198|      1|            .store(in: cancelBag)
  199|      1|        wait(for: [exp], timeout: 0.5)
  200|      1|    }
  201|       |    
  202|      1|    func test_fetchCountryDetails() throws {
  203|      1|        let details = Country.Details.test
  204|      1|        let intermediate = Country.Details.Intermediate(
  205|      1|            capital: details.capital, currencies: details.currencies,
  206|      2|            borders: details.neighbors.map { $0.alpha3Code })
  207|      1|        let parentCountry = Country.testLocalized[2]
  208|      1|        mockedStore.actions = .init(expected: [
  209|      1|            .fetchCountryDetails(.init(inserted: 0, updated: 0, deleted: 0))
  210|      1|        ])
  211|      1|        try mockedStore.preloadData { context in
  212|      1|            let parent = parentCountry.store(in: context)
  213|      2|            let neighbors = details.neighbors.compactMap { $0.store(in: context) }
  214|      1|            _ = parent.flatMap {
  215|      1|                intermediate.store(in: context, country: $0, borders: neighbors)
  216|      1|            }
  217|      1|        }
  218|      1|        let exp = XCTestExpectation(description: #function)
  219|      1|        sut.countryDetails(country: parentCountry)
  220|      1|            .sinkToResult { result in
  221|      1|                result.assertSuccess(value: details)
  222|      1|                self.mockedStore.verify()
  223|      1|                exp.fulfill()
  224|      1|            }
  225|      1|            .store(in: cancelBag)
  226|      1|        wait(for: [exp], timeout: 0.5)
  227|      1|    }
  228|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Repositories/CountriesWebRepositoryTests.swift:
    1|       |//
    2|       |//  CountriesWebRepositoryTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 30.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class CountriesWebRepositoryTests: XCTestCase {
   14|       |    
   15|       |    private var sut: RealCountriesWebRepository!
   16|      4|    private var subscriptions = Set<AnyCancellable>()
   17|       |    
   18|       |    typealias API = RealCountriesWebRepository.API
   19|       |    typealias Mock = RequestMocking.MockedResponse
   20|       |
   21|      4|    override func setUp() {
   22|      4|        subscriptions = Set<AnyCancellable>()
   23|      4|        sut = RealCountriesWebRepository(session: .mockedResponsesOnly,
   24|      4|                                         baseURL: "https://test.com")
   25|      4|    }
   26|       |
   27|      4|    override func tearDown() {
   28|      4|        RequestMocking.removeAllMocks()
   29|      4|    }
   30|       |    
   31|       |    // MARK: - All Countries
   32|       |
   33|      1|    func test_allCountries() throws {
   34|      1|        let data = Country.mockedData
   35|      1|        try mock(.allCountries, result: .success(data))
   36|      1|        let exp = XCTestExpectation(description: "Completion")
   37|      1|        sut.loadCountries().sinkToResult { result in
   38|      1|            result.assertSuccess(value: data)
   39|      1|            exp.fulfill()
   40|      1|        }.store(in: &subscriptions)
   41|      1|        wait(for: [exp], timeout: 2)
   42|      1|    }
   43|       |    
   44|      1|    func test_countryDetails() throws {
   45|      1|        let countries = Country.mockedData
   46|      1|        let value = Country.Details.Intermediate(
   47|      1|            capital: "London",
   48|      1|            currencies: [Country.Currency(code: "12", symbol: "$", name: "US dollar")],
   49|      3|            borders: countries.map({ $0.alpha3Code }))
   50|      1|        try mock(.countryDetails(countries[0]), result: .success([value]))
   51|      1|        let exp = XCTestExpectation(description: "Completion")
   52|      1|        sut.loadCountryDetails(country: countries[0]).sinkToResult { result in
   53|      1|            result.assertSuccess(value: value)
   54|      1|            exp.fulfill()
   55|      1|        }.store(in: &subscriptions)
   56|      1|        wait(for: [exp], timeout: 2)
   57|      1|    }
   58|       |    
   59|      1|    func test_countryDetails_whenDetailsAreEmpty() throws {
   60|      1|        let countries = Country.mockedData
   61|      1|        try mock(.countryDetails(countries[0]), result: .success([Country.Details.Intermediate]()))
   62|      1|        let exp = XCTestExpectation(description: "Completion")
   63|      1|        sut.loadCountryDetails(country: countries[0]).sinkToResult { result in
   64|      1|            result.assertFailure(APIError.unexpectedResponse.localizedDescription)
   65|      1|            exp.fulfill()
   66|      1|        }.store(in: &subscriptions)
   67|      1|        wait(for: [exp], timeout: 2)
   68|      1|    }
   69|       |    
   70|      1|    func test_countryDetails_countryNameEncoding() {
   71|      1|        let name = String(bytes: [0xD8, 0x00] as [UInt8], encoding: .utf16BigEndian)!
   72|      1|        let country = Country(name: name, translations: [:], population: 1, flag: nil, alpha3Code: "ABC")
   73|      1|        let apiCall = RealCountriesWebRepository.API.countryDetails(country)
   74|      1|        XCTAssertTrue(apiCall.path.hasSuffix(name))
   75|      1|    }
   76|       |    
   77|       |    // MARK: - Helper
   78|       |    
   79|       |    private func mock<T>(_ apiCall: API, result: Result<T, Swift.Error>,
   80|      3|                         httpCode: HTTPCode = 200) throws where T: Encodable {
   81|      3|        let mock = try Mock(apiCall: apiCall, baseURL: sut.baseURL, result: result, httpCode: httpCode)
   82|      3|        RequestMocking.add(mock: mock)
   83|      3|    }
   84|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Repositories/ImageWebRepositoryTests.swift:
    1|       |//
    2|       |//  ImageWebRepositoryTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 09.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class ImageWebRepositoryTests: XCTestCase {
   14|       |
   15|       |    private var sut: RealImageWebRepository!
   16|      6|    private var subscriptions = Set<AnyCancellable>()
   17|       |    private lazy var testImage = UIColor.red.image(CGSize(width: 40, height: 40))
   18|       |    private let svgToPngURL = "https://s1.ezgif.com/svg-to-png/ezgif-1-1d73ae275f02.svg?ajax=true"
   19|       |    private let pngURL = "https://im2.ezgif.com/tmp/ezgif-2-91963ddbaa7a.png"
   20|       |    
   21|       |    typealias Mock = RequestMocking.MockedResponse
   22|       |
   23|      6|    override func setUp() {
   24|      6|        subscriptions = Set<AnyCancellable>()
   25|      6|        sut = RealImageWebRepository(session: .mockedResponsesOnly,
   26|      6|                                     baseURL: "https://test.com")
   27|      6|    }
   28|       |
   29|      6|    override func tearDown() {
   30|      6|        RequestMocking.removeAllMocks()
   31|      6|    }
   32|       |    
   33|      1|    func test_loadImage_withConversion() throws {
   34|      1|        let bundle = Bundle(for: Self.self)
   35|      1|        let imageURL = try XCTUnwrap(URL(string: "https://image.service.com/myimage.svg"))
   36|      1|        let requestURL1 = try XCTUnwrap(URL(string: sut.baseURL + "/svg-to-png?url=" + imageURL.absoluteString))
   37|      1|        let requestURL2 = try XCTUnwrap(URL(string: svgToPngURL))
   38|      1|        let requestURL3 = try XCTUnwrap(URL(string: pngURL))
   39|      1|        let responseFile1 = try XCTUnwrap(bundle.url(forResource: "svg_convert_01", withExtension: "html"))
   40|      1|        let responseFile2 = try XCTUnwrap(bundle.url(forResource: "svg_convert_02", withExtension: "html"))
   41|      1|        let responseData1 = try XCTUnwrap(try? Data(contentsOf: responseFile1))
   42|      1|        let responseData2 = try XCTUnwrap(try? Data(contentsOf: responseFile2))
   43|      1|        let responseData3 = try XCTUnwrap(testImage.pngData())
   44|      1|        
   45|      1|        let mocks = [Mock(url: requestURL1, result: .success(responseData1)),
   46|      1|                     Mock(url: requestURL2, result: .success(responseData2)),
   47|      1|                     Mock(url: requestURL3, result: .success(responseData3))]
   48|      3|        mocks.forEach { RequestMocking.add(mock: $0) }
   49|      1|        
   50|      1|        let exp = XCTestExpectation(description: "Completion")
   51|      1|        sut.load(imageURL: imageURL, width: 300).sinkToResult { result in
   52|      1|            switch result {
   53|      1|            case let .success(resultValue):
   54|      1|                XCTAssertEqual(resultValue.size, self.testImage.size)
   55|      0|            case let .failure(error):
   56|      0|                XCTFail("Unexpected error: \(error)")
   57|      1|            }
   58|      1|            exp.fulfill()
   59|      1|        }.store(in: &subscriptions)
   60|      1|        wait(for: [exp], timeout: 2)
   61|      1|    }
   62|       |    
   63|      1|    func test_loadImage_withoutConversion() throws {
   64|      1|        
   65|      1|        let imageURL = try XCTUnwrap(URL(string: "https://image.service.com/myimage.png"))
   66|      1|        let responseData = try XCTUnwrap(testImage.pngData())
   67|      1|        let mock = Mock(url: imageURL, result: .success(responseData))
   68|      1|        RequestMocking.add(mock: mock)
   69|      1|        
   70|      1|        let exp = XCTestExpectation(description: "Completion")
   71|      1|        sut.load(imageURL: imageURL, width: 300).sinkToResult { result in
   72|      1|            switch result {
   73|      1|            case let .success(resultValue):
   74|      1|                XCTAssertEqual(resultValue.size, self.testImage.size)
   75|      0|            case let .failure(error):
   76|      0|                XCTFail("Unexpected error: \(error)")
   77|      1|            }
   78|      1|            exp.fulfill()
   79|      1|        }.store(in: &subscriptions)
   80|      1|        wait(for: [exp], timeout: 2)
   81|      1|    }
   82|       |    
   83|      1|    func test_loadImage_firstRequestFailure() throws {
   84|      1|        let imageURL = try XCTUnwrap(URL(string: "https://image.service.com/myimage.svg"))
   85|      1|        let requestURL1 = try XCTUnwrap(URL(string: sut.baseURL + "/svg-to-png?url=" + imageURL.absoluteString))
   86|      1|        let fakeData = "fakeData".data(using: .utf8)!
   87|      1|        let mocks = [Mock(url: requestURL1, result: .success(fakeData))]
   88|      1|        mocks.forEach { RequestMocking.add(mock: $0) }
   89|      1|        
   90|      1|        let exp = XCTestExpectation(description: "Completion")
   91|      1|        sut.load(imageURL: imageURL, width: 300).sinkToResult { result in
   92|      1|            result.assertFailure(APIError.imageProcessing([]).localizedDescription)
   93|      1|            exp.fulfill()
   94|      1|        }.store(in: &subscriptions)
   95|      1|        wait(for: [exp], timeout: 2)
   96|      1|    }
   97|       |    
   98|      1|    func test_loadImage_secondRequestFailure() throws {
   99|      1|        let bundle = Bundle(for: Self.self)
  100|      1|        let imageURL = try XCTUnwrap(URL(string: "https://image.service.com/myimage.svg"))
  101|      1|        let requestURL1 = try XCTUnwrap(URL(string: sut.baseURL + "/svg-to-png?url=" + imageURL.absoluteString))
  102|      1|        let requestURL2 = try XCTUnwrap(URL(string: svgToPngURL))
  103|      1|        let responseFile1 = try XCTUnwrap(bundle.url(forResource: "svg_convert_01", withExtension: "html"))
  104|      1|        let responseData1 = try XCTUnwrap(try? Data(contentsOf: responseFile1))
  105|      1|        let fakeData = "fakeData".data(using: .utf8)!
  106|      1|        let mocks = [Mock(url: requestURL1, result: .success(responseData1)),
  107|      1|                     Mock(url: requestURL2, result: .success(fakeData))]
  108|      2|        mocks.forEach { RequestMocking.add(mock: $0) }
  109|      1|        
  110|      1|        let exp = XCTestExpectation(description: "Completion")
  111|      1|        sut.load(imageURL: imageURL, width: 300).sinkToResult { result in
  112|      1|            result.assertFailure(APIError.imageProcessing([]).localizedDescription)
  113|      1|            exp.fulfill()
  114|      1|        }.store(in: &subscriptions)
  115|      1|        wait(for: [exp], timeout: 2)
  116|      1|    }
  117|       |    
  118|      1|    func test_loadImage_thirdRequestFailure() throws {
  119|      1|        let bundle = Bundle(for: Self.self)
  120|      1|        let imageURL = try XCTUnwrap(URL(string: "https://image.service.com/myimage.svg"))
  121|      1|        let requestURL1 = try XCTUnwrap(URL(string: sut.baseURL + "/svg-to-png?url=" + imageURL.absoluteString))
  122|      1|        let requestURL2 = try XCTUnwrap(URL(string: svgToPngURL))
  123|      1|        let requestURL3 = try XCTUnwrap(URL(string: pngURL))
  124|      1|        let responseFile1 = try XCTUnwrap(bundle.url(forResource: "svg_convert_01", withExtension: "html"))
  125|      1|        let responseFile2 = try XCTUnwrap(bundle.url(forResource: "svg_convert_02", withExtension: "html"))
  126|      1|        let responseData1 = try XCTUnwrap(try? Data(contentsOf: responseFile1))
  127|      1|        let responseData2 = try XCTUnwrap(try? Data(contentsOf: responseFile2))
  128|      1|        let responseData3 = try XCTUnwrap("fakeData".data(using: .utf8))
  129|      1|        
  130|      1|        let mocks = [Mock(url: requestURL1, result: .success(responseData1)),
  131|      1|                     Mock(url: requestURL2, result: .success(responseData2)),
  132|      1|                     Mock(url: requestURL3, result: .success(responseData3))]
  133|      3|        mocks.forEach { RequestMocking.add(mock: $0) }
  134|      1|        
  135|      1|        let exp = XCTestExpectation(description: "Completion")
  136|      1|        sut.load(imageURL: imageURL, width: 300).sinkToResult { result in
  137|      1|            result.assertFailure(APIError.imageProcessing([]).localizedDescription)
  138|      1|            exp.fulfill()
  139|      1|        }.store(in: &subscriptions)
  140|      1|        wait(for: [exp], timeout: 2)
  141|      1|    }
  142|       |    
  143|      1|    func test_loadImage_malformedURL() throws {
  144|      1|        let malformedResponse = """
  145|      1|        <form class="form ajax-form" action="https<>.svg">
  146|      1|        <input type="hidden" value="db82d45c4085be" name="token">
  147|      1|        """
  148|      1|        let imageURL = try XCTUnwrap(URL(string: "https://image.service.com/myimage.svg"))
  149|      1|        let requestURL1 = try XCTUnwrap(URL(string: sut.baseURL + "/svg-to-png?url=" + imageURL.absoluteString))
  150|      1|        let responseData1 = try XCTUnwrap(malformedResponse.data(using: .utf8))
  151|      1|        let mocks = [Mock(url: requestURL1, result: .success(responseData1))]
  152|      1|        mocks.forEach { RequestMocking.add(mock: $0) }
  153|      1|        
  154|      1|        let exp = XCTestExpectation(description: "Completion")
  155|      1|        sut.load(imageURL: imageURL, width: 300).sinkToResult { result in
  156|      1|            result.assertFailure(APIError.imageProcessing([]).localizedDescription)
  157|      1|            exp.fulfill()
  158|      1|        }.store(in: &subscriptions)
  159|      1|        wait(for: [exp], timeout: 2)
  160|      1|    }
  161|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Repositories/PushTokenWebRepositoryTests.swift:
    1|       |//
    2|       |//  PushTokenWebRepositoryTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 26.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |class PushTokenWebRepositoryTests: XCTestCase {
   14|       |
   15|       |    private var sut: RealPushTokenWebRepository!
   16|      1|    private var cancelBag = CancelBag()
   17|       |    
   18|      1|    override func setUp() {
   19|      1|        sut = RealPushTokenWebRepository(session: .mockedResponsesOnly,
   20|      1|                                         baseURL: "https://test.com")
   21|      1|    }
   22|       |    
   23|      1|    override func tearDown() {
   24|      1|        cancelBag = CancelBag()
   25|      1|    }
   26|       |    
   27|      1|    func test_register() {
   28|      1|        let exp = XCTestExpectation(description: #function)
   29|      1|        sut.register(devicePushToken: Data())
   30|      1|            .sinkToResult { result in
   31|      1|                result.assertSuccess()
   32|      1|                exp.fulfill()
   33|      1|            }
   34|      1|            .store(in: cancelBag)
   35|      1|        wait(for: [exp], timeout: 0.1)
   36|      1|    }
   37|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Repositories/WebRepositoryTests.swift:
    1|       |//
    2|       |//  WebRepositoryTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 30.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class WebRepositoryTests: XCTestCase {
   14|       |    
   15|       |    private var sut: TestWebRepository!
   16|      8|    private var subscriptions = Set<AnyCancellable>()
   17|       |    
   18|       |    private typealias API = TestWebRepository.API
   19|       |    typealias Mock = RequestMocking.MockedResponse
   20|       |
   21|      8|    override func setUp() {
   22|      8|        subscriptions = Set<AnyCancellable>()
   23|      8|        sut = TestWebRepository()
   24|      8|    }
   25|       |
   26|      8|    override func tearDown() {
   27|      8|        RequestMocking.removeAllMocks()
   28|      8|    }
   29|       |    
   30|      1|    func test_webRepository_success() throws {
   31|      1|        let data = TestWebRepository.TestData()
   32|      1|        try mock(.test, result: .success(data))
   33|      1|        let exp = XCTestExpectation(description: "Completion")
   34|      1|        sut.load(.test).sinkToResult { result in
   35|      1|            XCTAssertTrue(Thread.isMainThread)
   36|      1|            result.assertSuccess(value: data)
   37|      1|            exp.fulfill()
   38|      1|        }.store(in: &subscriptions)
   39|      1|        wait(for: [exp], timeout: 2)
   40|      1|    }
   41|       |    
   42|      1|    func test_webRepository_parseError() throws {
   43|      1|        let data = Country.mockedData
   44|      1|        try mock(.test, result: .success(data))
   45|      1|        let exp = XCTestExpectation(description: "Completion")
   46|      1|        sut.load(.test).sinkToResult { result in
   47|      1|            XCTAssertTrue(Thread.isMainThread)
   48|      1|            result.assertFailure("The data couldnât be read because it isnât in the correct format.")
   49|      1|            exp.fulfill()
   50|      1|        }.store(in: &subscriptions)
   51|      1|        wait(for: [exp], timeout: 2)
   52|      1|    }
   53|       |    
   54|      1|    func test_webRepository_httpCodeFailure() throws {
   55|      1|        let data = TestWebRepository.TestData()
   56|      1|        try mock(.test, result: .success(data), httpCode: 500)
   57|      1|        let exp = XCTestExpectation(description: "Completion")
   58|      1|        sut.load(.test).sinkToResult { result in
   59|      1|            XCTAssertTrue(Thread.isMainThread)
   60|      1|            result.assertFailure("Unexpected HTTP code: 500")
   61|      1|            exp.fulfill()
   62|      1|        }.store(in: &subscriptions)
   63|      1|        wait(for: [exp], timeout: 2)
   64|      1|    }
   65|       |    
   66|      1|    func test_webRepository_networkingError() throws {
   67|      1|        let error = NSError.test
   68|      1|        try mock(.test, result: Result<TestWebRepository.TestData, Error>.failure(error))
   69|      1|        let exp = XCTestExpectation(description: "Completion")
   70|      1|        sut.load(.test).sinkToResult { result in
   71|      1|            XCTAssertTrue(Thread.isMainThread)
   72|      1|            result.assertFailure(error.localizedDescription)
   73|      1|            exp.fulfill()
   74|      1|        }.store(in: &subscriptions)
   75|      1|        wait(for: [exp], timeout: 2)
   76|      1|    }
   77|       |    
   78|      1|    func test_webRepository_requestURLError() {
   79|      1|        let exp = XCTestExpectation(description: "Completion")
   80|      1|        sut.load(.urlError).sinkToResult { result in
   81|      1|            XCTAssertTrue(Thread.isMainThread)
   82|      1|            result.assertFailure(APIError.invalidURL.localizedDescription)
   83|      1|            exp.fulfill()
   84|      1|        }.store(in: &subscriptions)
   85|      1|        wait(for: [exp], timeout: 2)
   86|      1|    }
   87|       |    
   88|      1|    func test_webRepository_requestBodyError() {
   89|      1|        let exp = XCTestExpectation(description: "Completion")
   90|      1|        sut.load(.bodyError).sinkToResult { result in
   91|      1|            XCTAssertTrue(Thread.isMainThread)
   92|      1|            result.assertFailure(TestWebRepository.APIError.fail.localizedDescription)
   93|      1|            exp.fulfill()
   94|      1|        }.store(in: &subscriptions)
   95|      1|        wait(for: [exp], timeout: 2)
   96|      1|    }
   97|       |    
   98|      1|    func test_webRepository_loadableError() {
   99|      1|        let exp = XCTestExpectation(description: "Completion")
  100|      1|        let expected = APIError.invalidURL.localizedDescription
  101|      1|        sut.load(.urlError)
  102|      1|            .sinkToLoadable { loadable in
  103|      1|                XCTAssertTrue(Thread.isMainThread)
  104|      1|                XCTAssertEqual(loadable.error?.localizedDescription, expected)
  105|      1|                exp.fulfill()
  106|      1|            }.store(in: &subscriptions)
  107|      1|        wait(for: [exp], timeout: 2)
  108|      1|    }
  109|       |    
  110|      1|    func test_webRepository_noHttpCodeError() throws {
  111|      1|        let response = URLResponse(url: URL(fileURLWithPath: ""),
  112|      1|                                   mimeType: "example", expectedContentLength: 0, textEncodingName: nil)
  113|      1|        let mock = try Mock(apiCall: API.test, baseURL: sut.baseURL, customResponse: response)
  114|      1|        RequestMocking.add(mock: mock)
  115|      1|        let exp = XCTestExpectation(description: "Completion")
  116|      1|        sut.load(.test).sinkToResult { result in
  117|      1|            XCTAssertTrue(Thread.isMainThread)
  118|      1|            result.assertFailure(APIError.unexpectedResponse.localizedDescription)
  119|      1|            exp.fulfill()
  120|      1|        }.store(in: &subscriptions)
  121|      1|        wait(for: [exp], timeout: 2)
  122|      1|    }
  123|       |    
  124|       |    // MARK: - Helper
  125|       |    
  126|       |    private func mock<T>(_ apiCall: API, result: Result<T, Swift.Error>,
  127|      4|                         httpCode: HTTPCode = 200) throws where T: Encodable {
  128|      4|        let mock = try Mock(apiCall: apiCall, baseURL: sut.baseURL, result: result, httpCode: httpCode)
  129|      4|        RequestMocking.add(mock: mock)
  130|      4|    }
  131|       |}
  132|       |
  133|       |private extension TestWebRepository {
  134|      8|    func load(_ api: API) -> AnyPublisher<TestData, Error> {
  135|      8|        call(endpoint: api)
  136|      8|    }
  137|       |}
  138|       |
  139|       |extension TestWebRepository {
  140|       |    enum API: APICall {
  141|       |        
  142|       |        case test
  143|       |        case urlError
  144|       |        case bodyError
  145|       |        case noHttpCodeError
  146|       |        
  147|     13|        var path: String {
  148|     13|            if self == .urlError {
  149|      2|                return "ððð"
  150|     11|            }
  151|     11|            return "/test/path"
  152|     13|        }
  153|     11|        var method: String { "POST" }
  154|     11|        var headers: [String: String]? { nil }
  155|     11|        func body() throws -> Data? {
  156|     11|            if self == .bodyError { throw APIError.fail }
  157|     10|            return nil
  158|     11|        }
  159|       |    }
  160|       |}
  161|       |
  162|       |extension TestWebRepository {
  163|       |    enum APIError: Swift.Error, LocalizedError {
  164|       |        case fail
  165|      2|        var errorDescription: String? { "fail" }
  166|       |    }
  167|       |}
  168|       |
  169|       |extension TestWebRepository {
  170|       |    struct TestData: Codable, Equatable {
  171|       |        let string: String
  172|       |        let integer: Int
  173|       |        
  174|      2|        init() {
  175|      2|            string = "some string"
  176|      2|            integer = 42
  177|      2|        }
  178|       |    }
  179|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/System/AppDelegateTests.swift:
    1|       |//
    2|       |//  AppDelegateTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 26.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import UIKit
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class AppDelegateTests: XCTestCase {
   14|       |
   15|      1|    func test_didFinishLaunching() {
   16|      1|        let sut = AppDelegate()
   17|      1|        let eventsHandler = MockedSystemEventsHandler(expected: [])
   18|      1|        sut.systemEventsHandler = eventsHandler
   19|      1|        _ = sut.application(UIApplication.shared, didFinishLaunchingWithOptions: [:])
   20|      1|        eventsHandler.verify()
   21|      1|    }
   22|       |    
   23|      1|    func test_pushRegistration() {
   24|      1|        let sut = AppDelegate()
   25|      1|        let eventsHandler = MockedSystemEventsHandler(expected: [
   26|      1|            .pushRegistration, .pushRegistration
   27|      1|        ])
   28|      1|        sut.systemEventsHandler = eventsHandler
   29|      1|        sut.application(UIApplication.shared, didRegisterForRemoteNotificationsWithDeviceToken: Data())
   30|      1|        sut.application(UIApplication.shared, didFailToRegisterForRemoteNotificationsWithError: NSError.test)
   31|      1|        eventsHandler.verify()
   32|      1|    }
   33|       |    
   34|      1|    func test_didRecevieRemoteNotification() {
   35|      1|        let sut = AppDelegate()
   36|      1|        let eventsHandler = MockedSystemEventsHandler(expected: [
   37|      1|            .recevieRemoteNotification
   38|      1|        ])
   39|      1|        sut.systemEventsHandler = eventsHandler
   40|      0|        sut.application(UIApplication.shared, didReceiveRemoteNotification: [:], fetchCompletionHandler: { _ in })
   41|      1|        eventsHandler.verify()
   42|      1|    }
   43|       |    
   44|      1|    func test_systemEventsHandler() {
   45|      1|        let sut = AppDelegate()
   46|      1|        let handler = sut.systemEventsHandler
   47|      1|        XCTAssertTrue(handler is RealSystemEventsHandler)
   48|      1|    }
   49|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/System/DeepLinksHandlerTests.swift:
    1|       |//
    2|       |//  DeepLinksHandlerTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 26.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |@testable import CountriesSwiftUI
   11|       |
   12|       |class DeepLinksHandlerTests: XCTestCase {
   13|       |
   14|      1|    func test_noSideEffectOnInit() {
   15|      1|        let interactors: DIContainer.Interactors = .mocked()
   16|      1|        let container = DIContainer(appState: AppState(), interactors: interactors)
   17|      1|        _ = RealDeepLinksHandler(container: container)
   18|      1|        interactors.verify()
   19|      1|        XCTAssertEqual(container.appState.value, AppState())
   20|      1|    }
   21|       |    
   22|      1|    func test_openingDeeplinkFromDefaultRouting() {
   23|      1|        let interactors: DIContainer.Interactors = .mocked()
   24|      1|        let initialState = AppState()
   25|      1|        let container = DIContainer(appState: initialState, interactors: interactors)
   26|      1|        let sut = RealDeepLinksHandler(container: container)
   27|      1|        sut.open(deepLink: .showCountryFlag(alpha3Code: "ITA"))
   28|      1|        XCTAssertNil(initialState.routing.countriesList.countryDetails)
   29|      1|        XCTAssertFalse(initialState.routing.countryDetails.detailsSheet)
   30|      1|        var expectedState = AppState()
   31|      1|        expectedState.routing.countriesList.countryDetails = "ITA"
   32|      1|        expectedState.routing.countryDetails.detailsSheet = true
   33|      1|        interactors.verify()
   34|      1|        XCTAssertEqual(container.appState.value, expectedState)
   35|      1|    }
   36|       |    
   37|      1|    func test_openingDeeplinkFromNonDefaultRouting() {
   38|      1|        let interactors: DIContainer.Interactors = .mocked()
   39|      1|        var initialState = AppState()
   40|      1|        initialState.routing.countriesList.countryDetails = "FRA"
   41|      1|        initialState.routing.countryDetails.detailsSheet = true
   42|      1|        let container = DIContainer(appState: initialState, interactors: interactors)
   43|      1|        let sut = RealDeepLinksHandler(container: container)
   44|      1|        sut.open(deepLink: .showCountryFlag(alpha3Code: "ITA"))
   45|      1|        
   46|      1|        let resettedState = AppState()
   47|      1|        var finalState = AppState()
   48|      1|        finalState.routing.countriesList.countryDetails = "ITA"
   49|      1|        finalState.routing.countryDetails.detailsSheet = true
   50|      1|        
   51|      1|        XCTAssertEqual(container.appState.value, resettedState)
   52|      1|        let exp = XCTestExpectation(description: #function)
   53|      1|        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
   54|      1|            interactors.verify()
   55|      1|            XCTAssertEqual(container.appState.value, finalState)
   56|      1|            exp.fulfill()
   57|      1|        }
   58|      1|        wait(for: [exp], timeout: 2.5)
   59|      1|    }
   60|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/System/PushNotificationsHandlerTests.swift:
    1|       |//
    2|       |//  PushNotificationsHandlerTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 26.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import UserNotifications
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |class PushNotificationsHandlerTests: XCTestCase {
   14|       |    
   15|       |    var sut: RealPushNotificationsHandler!
   16|       |
   17|      1|    func test_isCenterDelegate() {
   18|      1|        let mockedHandler = MockedDeepLinksHandler(expected: [])
   19|      1|        sut = RealPushNotificationsHandler(deepLinksHandler: mockedHandler)
   20|      1|        let center = UNUserNotificationCenter.current()
   21|      1|        XCTAssertTrue(center.delegate === sut)
   22|      1|        mockedHandler.verify()
   23|      1|    }
   24|       |
   25|      1|    func test_emptyPayload() {
   26|      1|        let mockedHandler = MockedDeepLinksHandler(expected: [])
   27|      1|        sut = RealPushNotificationsHandler(deepLinksHandler: mockedHandler)
   28|      1|        let exp = XCTestExpectation(description: #function)
   29|      1|        sut.handleNotification(userInfo: [:]) {
   30|      1|            mockedHandler.verify()
   31|      1|            exp.fulfill()
   32|      1|        }
   33|      1|        wait(for: [exp], timeout: 0.1)
   34|      1|    }
   35|       |    
   36|      1|    func test_deepLinkPayload() {
   37|      1|        let mockedHandler = MockedDeepLinksHandler(expected: [
   38|      1|            .open(.showCountryFlag(alpha3Code: "USA"))
   39|      1|        ])
   40|      1|        sut = RealPushNotificationsHandler(deepLinksHandler: mockedHandler)
   41|      1|        let exp = XCTestExpectation(description: #function)
   42|      1|        let userInfo: [String: Any] = [
   43|      1|            "aps": ["country": "USA"]
   44|      1|        ]
   45|      1|        sut.handleNotification(userInfo: userInfo) {
   46|      1|            mockedHandler.verify()
   47|      1|            exp.fulfill()
   48|      1|        }
   49|      1|        wait(for: [exp], timeout: 0.1)
   50|      1|    }
   51|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/System/SceneDelegateTests.swift:
    1|       |//
    2|       |//  SceneDelegateTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 26.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import UIKit
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class SceneDelegateTests: XCTestCase {
   14|       |    
   15|      3|    private lazy var scene: UIScene = {
   16|      3|        UIApplication.shared.connectedScenes.first!
   17|      3|    }()
   18|       |    
   19|      1|    func test_openURLContexts() {
   20|      1|        let sut = SceneDelegate()
   21|      1|        let eventsHandler = MockedSystemEventsHandler(expected: [
   22|      1|            .openURL
   23|      1|        ])
   24|      1|        sut.systemEventsHandler = eventsHandler
   25|      1|        sut.scene(scene, openURLContexts: .init())
   26|      1|        eventsHandler.verify()
   27|      1|    }
   28|       |    
   29|      1|    func test_didBecomeActive() {
   30|      1|        let sut = SceneDelegate()
   31|      1|        let eventsHandler = MockedSystemEventsHandler(expected: [
   32|      1|            .becomeActive
   33|      1|        ])
   34|      1|        sut.systemEventsHandler = eventsHandler
   35|      1|        sut.sceneDidBecomeActive(scene)
   36|      1|        eventsHandler.verify()
   37|      1|    }
   38|       |    
   39|      1|    func test_willResignActive() {
   40|      1|        let sut = SceneDelegate()
   41|      1|        let eventsHandler = MockedSystemEventsHandler(expected: [
   42|      1|            .resignActive
   43|      1|        ])
   44|      1|        sut.systemEventsHandler = eventsHandler
   45|      1|        sut.sceneWillResignActive(scene)
   46|      1|        eventsHandler.verify()
   47|      1|    }
   48|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/System/SystemEventsHandlerTests.swift:
    1|       |//
    2|       |//  SystemEventsHandlerTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 31.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import UIKit
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class SystemEventsHandlerTests: XCTestCase {
   14|       |    
   15|       |    var sut: RealSystemEventsHandler!
   16|       |    
   17|     12|    var appState: AppState {
   18|     12|        return sut.container.appState.value
   19|     12|    }
   20|     10|    var interactors: DIContainer.Interactors {
   21|     10|        return sut.container.interactors
   22|     10|    }
   23|     10|    var deepLinksHandler: MockedDeepLinksHandler? {
   24|     10|        return sut.deepLinksHandler as? MockedDeepLinksHandler
   25|     10|    }
   26|     10|    var pushTokenWebRepository: MockedPushTokenWebRepository? {
   27|     10|        return sut.pushTokenWebRepository as? MockedPushTokenWebRepository
   28|     10|    }
   29|       |    
   30|     10|    func verify(appState: AppState = AppState(), file: StaticString = #file, line: UInt = #line) {
   31|     10|        interactors.verify(file: file, line: line)
   32|     10|        deepLinksHandler?.verify(file: file, line: line)
   33|     10|        pushTokenWebRepository?.verify(file: file, line: line)
   34|     10|        XCTAssertEqual(self.appState, appState, file: file, line: line)
   35|     10|    }
   36|       |
   37|       |    func setupSut(countries: [MockedCountriesInteractor.Action] = [],
   38|       |                  permissions: [MockedUserPermissionsInteractor.Action] = [],
   39|       |                  deepLink: [MockedDeepLinksHandler.Action] = [],
   40|     10|                  pushToken: [MockedPushTokenWebRepository.Action] = []) {
   41|     10|        let interactors = DIContainer.Interactors(
   42|     10|            countriesInteractor: MockedCountriesInteractor(expected: countries),
   43|     10|            imagesInteractor: MockedImagesInteractor(expected: []),
   44|     10|            userPermissionsInteractor: MockedUserPermissionsInteractor(expected: permissions))
   45|     10|        let container = DIContainer(appState: AppState(),
   46|     10|                                    interactors: interactors)
   47|     10|        let deepLinksHandler = MockedDeepLinksHandler(expected: deepLink)
   48|     10|        let pushNotificationsHandler = DummyPushNotificationsHandler()
   49|     10|        let pushTokenWebRepository = MockedPushTokenWebRepository(expected: pushToken)
   50|     10|        sut = RealSystemEventsHandler(container: container,
   51|     10|                                      deepLinksHandler: deepLinksHandler,
   52|     10|                                      pushNotificationsHandler: pushNotificationsHandler,
   53|     10|                                      pushTokenWebRepository: pushTokenWebRepository)
   54|     10|    }
   55|       |    
   56|      1|    func test_noSideEffectOnInit() {
   57|      1|        setupSut()
   58|      1|        sut.container.appState[\.permissions.push] = .denied
   59|      1|        let reference = sut.container.appState.value
   60|      1|        verify(appState: reference)
   61|      1|    }
   62|       |    
   63|      1|    func test_subscribesOnPushIfGranted() {
   64|      1|        setupSut(permissions: [
   65|      1|            .request(.pushNotifications)
   66|      1|        ])
   67|      1|        sut.container.appState[\.permissions.push] = .granted
   68|      1|        let reference = sut.container.appState.value
   69|      1|        verify(appState: reference)
   70|      1|    }
   71|       |
   72|      1|    func test_didBecomeActive() {
   73|      1|        setupSut(permissions: [
   74|      1|            .resolveStatus(.pushNotifications)
   75|      1|        ])
   76|      1|        sut.sceneDidBecomeActive()
   77|      1|        var reference = AppState()
   78|      1|        XCTAssertFalse(reference.system.isActive)
   79|      1|        reference.system.isActive = true
   80|      1|        verify(appState: reference)
   81|      1|    }
   82|       |    
   83|      1|    func test_willResignActive() {
   84|      1|        setupSut(permissions: [
   85|      1|            .resolveStatus(.pushNotifications)
   86|      1|        ])
   87|      1|        sut.sceneDidBecomeActive()
   88|      1|        sut.sceneWillResignActive()
   89|      1|        verify()
   90|      1|    }
   91|       |
   92|      1|    func test_openURLContexts_countryDeepLink() {
   93|      1|        let countries = Country.mockedData
   94|      1|        let code = countries[0].alpha3Code
   95|      1|        let deepLinkURL = "https://www.example.com/?alpha3code=\(code)"
   96|      1|        setupSut(deepLink: [.open(.showCountryFlag(alpha3Code: code))])
   97|      1|        let contexts = UIOpenURLContext.contexts(deepLinkURL)
   98|      1|        sut.sceneOpenURLContexts(contexts)
   99|      1|        verify()
  100|      1|    }
  101|       |    
  102|      1|    func test_openURLContexts_randomURL() {
  103|      1|        let url1 = "https://www.example.com/link/?param=USD"
  104|      1|        let contexts1 = UIOpenURLContext.contexts(url1)
  105|      1|        let url2 = "https://www.domain.com/test/?alpha3code=USD"
  106|      1|        let contexts2 = UIOpenURLContext.contexts(url2)
  107|      1|        setupSut()
  108|      1|        sut.sceneOpenURLContexts(contexts1)
  109|      1|        sut.sceneOpenURLContexts(contexts2)
  110|      1|        verify()
  111|      1|    }
  112|       |    
  113|      1|    func test_openURLContexts_emptyContexts() {
  114|      1|        setupSut()
  115|      1|        sut.sceneOpenURLContexts(Set<UIOpenURLContext>())
  116|      1|        verify()
  117|      1|    }
  118|       |    
  119|       |    #if os(iOS) && !targetEnvironment(macCatalyst)
  120|      1|    func test_keyboardHeight() throws {
  121|      1|        let textFiled = UITextField(frame: .zero)
  122|      1|        let window = try XCTUnwrap(UIApplication.shared.windows.first, "Cannot extract the host view")
  123|      1|        window.makeKeyAndVisible()
  124|      1|        window.addSubview(textFiled)
  125|      1|        setupSut()
  126|      1|        XCTAssertEqual(appState.system.keyboardHeight, 0)
  127|      1|        textFiled.becomeFirstResponder()
  128|      1|        XCTAssertGreaterThan(appState.system.keyboardHeight, 0)
  129|      1|        textFiled.removeFromSuperview()
  130|      1|        verify()
  131|      1|    }
  132|       |    #endif
  133|       |    
  134|      1|    func test_handlePushRegistration() {
  135|      1|        setupSut(pushToken: [
  136|      1|            .register(Data())
  137|      1|        ])
  138|      1|        sut.handlePushRegistration(result: .success(Data()))
  139|      1|        verify()
  140|      1|    }
  141|       |    
  142|      1|    func test_silentRemoteNotificationSuccess() {
  143|      1|        setupSut(countries: [
  144|      1|            .refreshCountriesList
  145|      1|        ])
  146|      1|        let exp = XCTestExpectation(description: #function)
  147|      1|        sut.appDidReceiveRemoteNotification(payload: [:]) { result in
  148|      1|            XCTAssertEqual(result, .newData)
  149|      1|            self.verify()
  150|      1|            exp.fulfill()
  151|      1|        }
  152|      1|        wait(for: [exp], timeout: 0.1)
  153|      1|    }
  154|       |}
  155|       |
  156|       |private extension UIOpenURLContext {
  157|      3|    static func contexts(_ urlString: String) -> Set<UIOpenURLContext> {
  158|      3|        UIOpenURLContext.createInstance()
  159|      3|        return Set([Test.create(url: urlString)])
  160|      3|    }
  161|       |}
  162|       |
  163|       |private extension UIOpenURLContext {
  164|       |    final class Test: UIOpenURLContext {
  165|       |        
  166|       |        var urlString: String = ""
  167|      3|        override var url: URL { URL(string: urlString)! }
  168|       |        
  169|      3|        static func create(url: String) -> Test {
  170|      3|            let instance = createInstance()
  171|      3|            instance.urlString = url
  172|      3|            return instance
  173|      3|        }
  174|       |    }
  175|       |
  176|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/System/UIOpenURLContext_Init.m:
    1|       |//
    2|       |//  UIOpenURLContext_Init.m
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey on 18.05.2021.
    6|       |//  Copyright Â© 2021 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "UIOpenURLContext_Init.h"
   10|       |
   11|       |@implementation UIOpenURLContext (Init)
   12|       |
   13|      6|+ (instancetype)createInstance {
   14|      6|    return [[self alloc] init];
   15|      6|}
   16|       |
   17|       |@end

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/TestHelpers.swift:
    1|       |//
    2|       |//  TestHelpers.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 30.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import SwiftUI
   11|       |import Combine
   12|       |import ViewInspector
   13|       |@testable import CountriesSwiftUI
   14|       |
   15|       |// MARK: - UI
   16|       |
   17|       |extension UIColor {
   18|     11|    func image(_ size: CGSize = CGSize(width: 1, height: 1)) -> UIImage {
   19|     11|        let format = UIGraphicsImageRendererFormat()
   20|     11|        format.scale = 1
   21|     11|        return UIGraphicsImageRenderer(size: size, format: format).image { rendererContext in
   22|     11|            setFill()
   23|     11|            rendererContext.fill(CGRect(origin: .zero, size: size))
   24|     11|        }
   25|     11|    }
   26|       |}
   27|       |
   28|       |// MARK: - Result
   29|       |
   30|       |extension Result where Success: Equatable {
   31|     13|    func assertSuccess(value: Success, file: StaticString = #file, line: UInt = #line) {
   32|     13|        switch self {
   33|     13|        case let .success(resultValue):
   34|     13|            XCTAssertEqual(resultValue, value, file: file, line: line)
   35|      0|        case let .failure(error):
   36|      0|            XCTFail("Unexpected error: \(error)", file: file, line: line)
   37|     13|        }
   38|     13|    }
   39|       |}
   40|       |
   41|       |extension Result where Success == Void {
   42|      2|    func assertSuccess(file: StaticString = #file, line: UInt = #line) {
   43|      2|        switch self {
   44|      0|        case let .failure(error):
   45|      0|            XCTFail("Unexpected error: \(error)", file: file, line: line)
   46|      2|        case .success:
   47|      2|            break
   48|      2|        }
   49|      2|    }
   50|       |}
   51|       |
   52|       |extension Result {
   53|     13|    func assertFailure(_ message: String? = nil, file: StaticString = #file, line: UInt = #line) {
   54|     13|        switch self {
   55|      0|        case let .success(value):
   56|      0|            XCTFail("Unexpected success: \(value)", file: file, line: line)
   57|     13|        case let .failure(error):
   58|     12|            if let message = message {
   59|     12|                XCTAssertEqual(error.localizedDescription, message, file: file, line: line)
   60|     13|            }
   61|     13|        }
   62|     13|    }
   63|       |}
   64|       |
   65|       |extension Result {
   66|     32|    func publish() -> AnyPublisher<Success, Failure> {
   67|     32|        return publisher.publish()
   68|     32|    }
   69|       |}
   70|       |
   71|       |extension Publisher {
   72|     40|    func publish() -> AnyPublisher<Output, Failure> {
   73|     40|        delay(for: .milliseconds(10), scheduler: RunLoop.main)
   74|     40|            .eraseToAnyPublisher()
   75|     40|    }
   76|       |}
   77|       |
   78|       |// MARK: - XCTestCase
   79|       |
   80|       |func XCTAssertEqual<T>(_ expression1: @autoclosure () throws -> T,
   81|       |                       _ expression2: @autoclosure () throws -> T,
   82|       |                       removing prefixes: [String],
   83|      9|                       file: StaticString = #file, line: UInt = #line) where T: Equatable {
   84|      9|    do {
   85|      9|        let exp1 = try expression1()
   86|      9|        let exp2 = try expression2()
   87|      9|        if exp1 != exp2 {
   88|      0|            let desc1 = prefixes.reduce(String(describing: exp1), { (str, prefix) in
   89|      0|                str.replacingOccurrences(of: prefix, with: "")
   90|      0|            })
   91|      0|            let desc2 = prefixes.reduce(String(describing: exp2), { (str, prefix) in
   92|      0|                str.replacingOccurrences(of: prefix, with: "")
   93|      0|            })
   94|      0|            XCTFail("XCTAssertEqual failed:\n\n\(desc1)\n\nis not equal to\n\n\(desc2)", file: file, line: line)
   95|      9|        }
   96|      0|    } catch {
   97|      0|        XCTFail("Unexpected exception: \(error)")
   98|      9|    }
   99|      9|}
  100|       |
  101|       |protocol PrefixRemovable { }
  102|       |
  103|       |extension PrefixRemovable {
  104|      9|    static var prefixes: [String] {
  105|      9|        let name = String(reflecting: Self.self)
  106|      9|        var components = name.components(separatedBy: ".")
  107|      9|        let module = components.removeFirst()
  108|      9|        let fullTypeName = components.joined(separator: ".")
  109|      9|        return [
  110|      9|            "\(module).",
  111|      9|            "Loadable<\(fullTypeName)>",
  112|      9|            "Loadable<LazyList<\(fullTypeName)>>"
  113|      9|        ]
  114|      9|    }
  115|       |}
  116|       |
  117|       |// MARK: - BindingWithPublisher
  118|       |
  119|       |struct BindingWithPublisher<Value> {
  120|       |    
  121|       |    let binding: Binding<Value>
  122|       |    let updatesRecorder: AnyPublisher<[Value], Never>
  123|       |    
  124|     16|    init(value: Value, recordingTimeInterval: TimeInterval = 0.5) {
  125|     16|        var value = value
  126|     16|        var updates = [value]
  127|     16|        binding = Binding<Value>(
  128|     28|            get: { value },
  129|     25|            set: { value = $0; updates.append($0) })
  130|     16|        updatesRecorder = Future<[Value], Never> { completion in
  131|     16|            DispatchQueue.main.asyncAfter(deadline: .now() + recordingTimeInterval) {
  132|     16|                completion(.success(updates))
  133|     16|            }
  134|     16|        }.eraseToAnyPublisher()
  135|     16|    }
  136|       |}
  137|       |
  138|       |// MARK: - Error
  139|       |
  140|       |enum MockError: Swift.Error {
  141|       |    case valueNotSet
  142|       |    case codeDataModel
  143|       |}
  144|       |
  145|       |extension NSError {
  146|     22|    static var test: NSError {
  147|     22|        return NSError(domain: "test", code: 0, userInfo: [NSLocalizedDescriptionKey: "Test error"])
  148|     22|    }
  149|       |}
  150|       |
  151|       |extension Inspection: InspectionEmissary where V: Inspectable { }

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/ContentViewTests.swift:
    1|       |import XCTest
    2|       |import ViewInspector
    3|       |@testable import CountriesSwiftUI
    4|       |
    5|       |extension ContentView: Inspectable { }
    6|       |
    7|       |final class ContentViewTests: XCTestCase {
    8|       |
    9|      1|    func test_content_for_tests() throws {
   10|      1|        let sut = ContentView(container: .defaultValue, isRunningTests: true)
   11|      1|        XCTAssertNoThrow(try sut.inspect().group().text(0))
   12|      1|    }
   13|       |    
   14|      1|    func test_content_for_build() throws {
   15|      1|        let sut = ContentView(container: .defaultValue, isRunningTests: false)
   16|      1|        XCTAssertNoThrow(try sut.inspect().group().view(CountriesList.self, 0))
   17|      1|    }
   18|       |    
   19|      1|    func test_change_handler_for_colorScheme() throws {
   20|      1|        var appState = AppState()
   21|      1|        appState.routing.countriesList = .init(countryDetails: "USA")
   22|      1|        let container = DIContainer(appState: .init(appState), interactors: .mocked())
   23|      1|        let sut = ContentView(container: container)
   24|      1|        sut.onChangeHandler(.colorScheme)
   25|      1|        XCTAssertEqual(container.appState.value, appState)
   26|      1|        container.interactors.verify()
   27|      1|    }
   28|       |    
   29|      1|    func test_change_handler_for_sizeCategory() throws {
   30|      1|        var appState = AppState()
   31|      1|        appState.routing.countriesList = .init(countryDetails: "USA")
   32|      1|        let container = DIContainer(appState: .init(appState), interactors: .mocked())
   33|      1|        let sut = ContentView(container: container)
   34|      1|        XCTAssertEqual(container.appState.value, appState)
   35|      1|        sut.onChangeHandler(.sizeCategory)
   36|      1|        XCTAssertEqual(container.appState.value, AppState())
   37|      1|        container.interactors.verify()
   38|      1|    }
   39|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/CountriesListTests.swift:
    1|       |//
    2|       |//  CountriesListTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 01.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import ViewInspector
   11|       |import SwiftUI
   12|       |@testable import CountriesSwiftUI
   13|       |
   14|       |extension CountriesList: Inspectable { }
   15|       |extension ActivityIndicatorView: Inspectable { }
   16|       |extension CountryCell: Inspectable { }
   17|       |extension ErrorView: Inspectable { }
   18|       |
   19|       |final class CountriesListTests: XCTestCase {
   20|       |
   21|      1|    func test_countries_notRequested() {
   22|      1|        let container = DIContainer(appState: AppState(), interactors:
   23|      1|            .mocked(
   24|      1|                countriesInteractor: [.loadCountries(search: "", locale: .current)]
   25|      1|            ))
   26|      1|        let sut = CountriesList(countries: .notRequested)
   27|      1|        let exp = sut.inspection.inspect { view in
   28|      1|            XCTAssertNoThrow(try view.content().text())
   29|      1|            XCTAssertEqual(container.appState.value, AppState())
   30|      1|            container.interactors.verify()
   31|      1|        }
   32|      1|        ViewHosting.host(view: sut.inject(container))
   33|      1|        wait(for: [exp], timeout: 2)
   34|      1|    }
   35|       |    
   36|      1|    func test_countries_isLoading_initial() {
   37|      1|        let container = DIContainer(appState: AppState(), interactors: .mocked())
   38|      1|        let sut = CountriesList(countries: .isLoading(last: nil, cancelBag: CancelBag()))
   39|      1|        let exp = sut.inspection.inspect { view in
   40|      1|            let content = try view.content()
   41|      0|            XCTAssertNoThrow(try content.view(ActivityIndicatorView.self))
   42|      0|            XCTAssertEqual(container.appState.value, AppState())
   43|      1|            container.interactors.verify()
   44|      1|        }
   45|      1|        ViewHosting.host(view: sut.inject(container))
   46|      1|        wait(for: [exp], timeout: 2)
   47|      1|    }
   48|       |    
   49|      1|    func test_countries_isLoading_refresh() {
   50|      1|        let container = DIContainer(appState: AppState(), interactors: .mocked())
   51|      1|        let sut = CountriesList(countries: .isLoading(
   52|      1|            last: Country.mockedData.lazyList, cancelBag: CancelBag()))
   53|      1|        let exp = sut.inspection.inspect { view in
   54|      1|            let content = try view.content()
   55|      0|            XCTAssertNoThrow(try content.find(SearchBar.self))
   56|      0|            XCTAssertNoThrow(try content.find(ActivityIndicatorView.self))
   57|      1|            let cell = try content.find(CountryCell.self).actualView()
   58|      0|            XCTAssertEqual(cell.country, Country.mockedData[0])
   59|      0|            XCTAssertEqual(container.appState.value, AppState())
   60|      1|            container.interactors.verify()
   61|      1|        }
   62|      1|        ViewHosting.host(view: sut.inject(container))
   63|      1|        wait(for: [exp], timeout: 2)
   64|      1|    }
   65|       |    
   66|      1|    func test_countries_loaded() {
   67|      1|        let container = DIContainer(appState: AppState(), interactors: .mocked())
   68|      1|        let sut = CountriesList(countries: .loaded(Country.mockedData.lazyList))
   69|      1|        let exp = sut.inspection.inspect { view in
   70|      1|            let content = try view.content()
   71|      0|            XCTAssertNoThrow(try content.find(SearchBar.self))
   72|      0|            XCTAssertThrowsError(try content.find(ActivityIndicatorView.self))
   73|      1|            let cell = try content.find(CountryCell.self).actualView()
   74|      0|            XCTAssertEqual(cell.country, Country.mockedData[0])
   75|      0|            XCTAssertEqual(container.appState.value, AppState())
   76|      1|            container.interactors.verify()
   77|      1|        }
   78|      1|        ViewHosting.host(view: sut.inject(container))
   79|      1|        wait(for: [exp], timeout: 2)
   80|      1|    }
   81|       |    
   82|      1|    func test_countries_failed() {
   83|      1|        let container = DIContainer(appState: AppState(), interactors: .mocked())
   84|      1|        let sut = CountriesList(countries: .failed(NSError.test))
   85|      1|        let exp = sut.inspection.inspect { view in
   86|      1|            XCTAssertNoThrow(try view.content().view(ErrorView.self))
   87|      1|            XCTAssertEqual(container.appState.value, AppState())
   88|      1|            container.interactors.verify()
   89|      1|        }
   90|      1|        ViewHosting.host(view: sut.inject(container))
   91|      1|        wait(for: [exp], timeout: 2)
   92|      1|    }
   93|       |    
   94|      1|    func test_countries_failed_retry() {
   95|      1|        let container = DIContainer(appState: AppState(), interactors: .mocked(
   96|      1|            countriesInteractor: [.loadCountries(search: "", locale: .current)]
   97|      1|        ))
   98|      1|        let sut = CountriesList(countries: .failed(NSError.test))
   99|      1|        let exp = sut.inspection.inspect { view in
  100|      1|            let errorView = try view.content().view(ErrorView.self)
  101|      1|            try errorView.vStack().button(2).tap()
  102|      0|            XCTAssertEqual(container.appState.value, AppState())
  103|      1|            container.interactors.verify()
  104|      1|        }
  105|      1|        ViewHosting.host(view: sut.inject(container))
  106|      1|        wait(for: [exp], timeout: 2)
  107|      1|    }
  108|       |    
  109|      1|    func test_countries_navigation_to_details() {
  110|      1|        let countries = Country.mockedData
  111|      1|        let container = DIContainer(appState: AppState(), interactors: .mocked())
  112|      1|        XCTAssertNil(container.appState.value.routing.countriesList.countryDetails)
  113|      1|        let sut = CountriesList(countries: .loaded(countries.lazyList))
  114|      1|        let exp = sut.inspection.inspect { view in
  115|      1|            let firstCountryRow = try view.content().find(ViewType.NavigationLink.self)
  116|      1|            try firstCountryRow.activate()
  117|      1|            let selected = container.appState.value.routing.countriesList.countryDetails
  118|      0|            XCTAssertEqual(selected, countries[0].alpha3Code)
  119|      0|            _ = try firstCountryRow.find(where: { try $0.callOnAppear(); return true })
  120|      1|            container.interactors.verify()
  121|      1|        }
  122|      1|        ViewHosting.host(view: sut.inject(container))
  123|      1|        wait(for: [exp], timeout: 2)
  124|      1|    }
  125|       |}
  126|       |
  127|       |final class LocalizationTests: XCTestCase {
  128|      1|    func test_country_localized_name() {
  129|      1|        let sut = Country(name: "Abc", translations: ["fr": "Xyz"], population: 0, flag: nil, alpha3Code: "")
  130|      1|        let locale = Locale(identifier: "fr")
  131|      1|        XCTAssertEqual(sut.name(locale: locale), "Xyz")
  132|      1|    }
  133|       |    
  134|      1|    func test_string_for_locale() throws {
  135|      1|        let sut = "Countries".localized(Locale(identifier: "fr"))
  136|      1|        XCTAssertEqual(sut, "Des pays")
  137|      1|    }
  138|       |}
  139|       |
  140|       |// MARK: - CountriesList inspection helper
  141|       |
  142|       |extension InspectableView where View == ViewType.View<CountriesList> {
  143|      8|    func content() throws -> InspectableView<ViewType.AnyView> {
  144|      8|        return try geometryReader().navigationView()
  145|      8|            .navigationBarItems(AnyView.self).anyView()
  146|      8|    }
  147|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/CountryDetailsTests.swift:
    1|       |//
    2|       |//  CountryDetailsTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 01.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import ViewInspector
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |extension CountryDetails: Inspectable { }
   14|       |extension DetailRow: Inspectable { }
   15|       |
   16|       |final class CountryDetailsTests: XCTestCase {
   17|       |    
   18|      8|    let country = Country.mockedData[0]
   19|       |
   20|      1|    func test_details_notRequested() {
   21|      1|        let interactors = DIContainer.Interactors.mocked(
   22|      1|            countriesInteractor: [.loadCountryDetails(country)]
   23|      1|        )
   24|      1|        let sut = CountryDetails(country: country, details: .notRequested)
   25|      1|        let exp = sut.inspection.inspect { view in
   26|      1|            XCTAssertNoThrow(try view.find(text: ""))
   27|      1|            interactors.verify()
   28|      1|        }
   29|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   30|      1|        wait(for: [exp], timeout: 2)
   31|      1|    }
   32|       |    
   33|      1|    func test_details_isLoading_initial() {
   34|      1|        let interactors = DIContainer.Interactors.mocked()
   35|      1|        let sut = CountryDetails(country: country, details:
   36|      1|            .isLoading(last: nil, cancelBag: CancelBag()))
   37|      1|        let exp = sut.inspection.inspect { view in
   38|      1|            XCTAssertNoThrow(try view.find(ActivityIndicatorView.self))
   39|      1|            interactors.verify()
   40|      1|        }
   41|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   42|      1|        wait(for: [exp], timeout: 2)
   43|      1|    }
   44|       |    
   45|      1|    func test_details_isLoading_refresh() {
   46|      1|        let interactors = DIContainer.Interactors.mocked()
   47|      1|        let sut = CountryDetails(country: country, details:
   48|      1|            .isLoading(last: Country.Details.mockedData[0], cancelBag: CancelBag())
   49|      1|        )
   50|      1|        let exp = sut.inspection.inspect { view in
   51|      1|            XCTAssertNoThrow(try view.find(ActivityIndicatorView.self))
   52|      1|            interactors.verify()
   53|      1|        }
   54|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   55|      1|        wait(for: [exp], timeout: 2)
   56|      1|    }
   57|       |    
   58|      1|    func test_details_isLoading_cancellation() {
   59|      1|        let interactors = DIContainer.Interactors.mocked()
   60|      1|        let sut = CountryDetails(country: country, details:
   61|      1|            .isLoading(last: Country.Details.mockedData[0], cancelBag: CancelBag())
   62|      1|        )
   63|      1|        let exp = sut.inspection.inspect { view in
   64|      1|            XCTAssertNoThrow(try view.find(ActivityIndicatorView.self))
   65|      1|            try view.find(button: "Cancel loading").tap()
   66|      1|            interactors.verify()
   67|      1|        }
   68|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   69|      1|        wait(for: [exp], timeout: 2)
   70|      1|    }
   71|       |    
   72|      1|    func test_details_loaded() {
   73|      1|        let interactors = DIContainer.Interactors.mocked(
   74|      1|            imagesInteractor: [.loadImage(country.flag)]
   75|      1|        )
   76|      1|        let sut = CountryDetails(country: country, details:
   77|      1|            .loaded(Country.Details.mockedData[0])
   78|      1|        )
   79|      1|        let exp = sut.inspection.inspect { view in
   80|      1|            XCTAssertNoThrow(try view.find(SVGImageView.self))
   81|      1|            XCTAssertNoThrow(try view.find(DetailRow.self).find(text: self.country.alpha3Code))
   82|      1|            interactors.verify()
   83|      1|        }
   84|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   85|      1|        wait(for: [exp], timeout: 3)
   86|      1|    }
   87|       |    
   88|      1|    func test_details_failed() {
   89|      1|        let interactors = DIContainer.Interactors.mocked()
   90|      1|        let sut = CountryDetails(country: country, details: .failed(NSError.test))
   91|      1|        let exp = sut.inspection.inspect { view in
   92|      1|            XCTAssertNoThrow(try view.find(ErrorView.self))
   93|      1|            interactors.verify()
   94|      1|        }
   95|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   96|      1|        wait(for: [exp], timeout: 2)
   97|      1|    }
   98|       |    
   99|      1|    func test_details_failed_retry() {
  100|      1|        let interactors = DIContainer.Interactors.mocked(
  101|      1|            countriesInteractor: [.loadCountryDetails(country)]
  102|      1|        )
  103|      1|        let sut = CountryDetails(country: country, details: .failed(NSError.test))
  104|      1|        let exp = sut.inspection.inspect { view in
  105|      1|            let errorView = try view.find(ErrorView.self)
  106|      1|            try errorView.vStack().button(2).tap()
  107|      1|            interactors.verify()
  108|      1|        }
  109|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
  110|      1|        wait(for: [exp], timeout: 2)
  111|      1|    }
  112|       |    
  113|      1|    func test_sheetPresentation() {
  114|      1|        let images: [MockedImagesInteractor.Action]
  115|      1|        if #available(iOS 14.0, *) {
  116|      1|            // Image is requested by Details sheet only:
  117|      1|            images = [.loadImage(country.flag)]
  118|      1|        } else {
  119|      0|            // Image is requested by CountryDetails and Details sheet:
  120|      0|            images = [.loadImage(country.flag), .loadImage(country.flag)]
  121|      1|        }
  122|      1|        let interactors = DIContainer.Interactors.mocked(
  123|      1|            imagesInteractor: images
  124|      1|        )
  125|      1|        let container = DIContainer(appState: .init(AppState()), interactors: interactors)
  126|      1|        XCTAssertFalse(container.appState.value.routing.countryDetails.detailsSheet)
  127|      1|        let sut = CountryDetails(country: country, details: .loaded(Country.Details.mockedData[0]))
  128|      1|        let exp1 = sut.inspection.inspect { view in
  129|      1|            try view.find(SVGImageView.self).callOnTapGesture()
  130|      1|        }
  131|      1|        let exp2 = sut.inspection.inspect(after: 0.5) { view in
  132|      1|            XCTAssertTrue(container.appState.value.routing.countryDetails.detailsSheet)
  133|      1|            interactors.verify()
  134|      1|        }
  135|      1|        ViewHosting.host(view: sut.inject(container))
  136|      1|        wait(for: [exp1, exp2], timeout: 2)
  137|      1|    }
  138|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/DeepLinkUITests.swift:
    1|       |//
    2|       |//  DeepLinkUITests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 10.01.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import ViewInspector
   11|       |import Combine
   12|       |@testable import CountriesSwiftUI
   13|       |
   14|       |final class DeepLinkUITests: XCTestCase {
   15|       |    
   16|      1|    func test_countriesList_selectsCountry() {
   17|      1|        
   18|      1|        let store = appStateWithDeepLink()
   19|      1|        let interactors = mockedInteractors(store: store)
   20|      1|        let container = DIContainer(appState: store, interactors: interactors)
   21|      1|        let sut = CountriesList()
   22|      1|        let exp = sut.inspection.inspect(after: 0.1) { view in
   23|      1|            let firstRowLink = try view.content().find(ViewType.NavigationLink.self)
   24|      0|            XCTAssertTrue(try firstRowLink.isActive())
   25|      1|        }
   26|      1|        ViewHosting.host(view: sut.inject(container))
   27|      1|        wait(for: [exp], timeout: 2)
   28|      1|    }
   29|       |    
   30|      1|    func test_countryDetails_presentsSheet() {
   31|      1|        
   32|      1|        let store = appStateWithDeepLink()
   33|      1|        let interactors = mockedInteractors(store: store)
   34|      1|        let container = DIContainer(appState: store, interactors: interactors)
   35|      1|        let sut = CountryDetails(country: Country.mockedData[0])
   36|      1|        let exp = sut.inspection.inspect(after: 0.1) { view in
   37|      1|            XCTAssertNoThrow(try view.find(ViewType.List.self))
   38|      1|            XCTAssertTrue(store.value.routing.countryDetails.detailsSheet)
   39|      1|        }
   40|      1|        ViewHosting.host(view: sut.inject(container))
   41|      1|        wait(for: [exp], timeout: 2)
   42|      1|    }
   43|       |}
   44|       |
   45|       |// MARK: - Setup
   46|       |
   47|       |private extension DeepLinkUITests {
   48|       |    
   49|      2|    func appStateWithDeepLink() -> Store<AppState> {
   50|      2|        let countries = Country.mockedData
   51|      2|        var appState = AppState()
   52|      2|        appState.routing.countriesList.countryDetails = countries[0].alpha3Code
   53|      2|        appState.routing.countryDetails.detailsSheet = true
   54|      2|        return Store(appState)
   55|      2|    }
   56|       |    
   57|      2|    func mockedInteractors(store: Store<AppState>) -> DIContainer.Interactors {
   58|      2|        
   59|      2|        let countries = Country.mockedData
   60|      2|        let testImage = UIColor.red.image(CGSize(width: 40, height: 40))
   61|      2|        let detailsIntermediate = Country.Details.Intermediate(capital: "", currencies: [], borders: [])
   62|      2|        let details = Country.Details(capital: "", currencies: [], neighbors: [])
   63|      2|        
   64|      2|        let countriesDBRepo = MockedCountriesDBRepository()
   65|      2|        let countriesWebRepo = MockedCountriesWebRepository()
   66|      2|        let imagesRepo = MockedImageWebRepository()
   67|      2|        
   68|      2|        // Mocking successful loading the list of countries:
   69|      2|        countriesDBRepo.hasLoadedCountriesResult = .success(false)
   70|      2|        countriesWebRepo.countriesResponse = .success(countries)
   71|      2|        countriesDBRepo.storeCountriesResult = .success(())
   72|      2|        countriesDBRepo.fetchCountriesResult = .success(countries.lazyList)
   73|      2|        
   74|      2|        // Mocking successful loading the country details:
   75|      2|        countriesDBRepo.fetchCountryDetailsResult = .success(nil)
   76|      2|        countriesWebRepo.detailsResponse = .success(detailsIntermediate)
   77|      2|        countriesDBRepo.storeCountryDetailsResult = .success(details)
   78|      2|        
   79|      2|        // Mocking successful loading of the flag:
   80|      2|        imagesRepo.imageResponse = .success(testImage)
   81|      2|        
   82|      2|        let countriesInteractor = RealCountriesInteractor(webRepository: countriesWebRepo,
   83|      2|                                                          dbRepository: countriesDBRepo,
   84|      2|                                                          appState: store)
   85|      2|        let imagesInteractor = RealImagesInteractor(webRepository: imagesRepo)
   86|      0|        let permissionsInteractor = RealUserPermissionsInteractor(appState: store, openAppSettings: { })
   87|      2|        return DIContainer.Interactors(countriesInteractor: countriesInteractor,
   88|      2|                                       imagesInteractor: imagesInteractor,
   89|      2|                                       userPermissionsInteractor: permissionsInteractor)
   90|      2|    }
   91|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/ModalDetailsViewTests.swift:
    1|       |//
    2|       |//  ModalDetailsViewTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 01.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import SwiftUI
   11|       |import ViewInspector
   12|       |@testable import CountriesSwiftUI
   13|       |
   14|       |extension ModalDetailsView: Inspectable { }
   15|       |
   16|       |final class ModalDetailsViewTests: XCTestCase {
   17|       |
   18|      1|    func test_modalDetails() {
   19|      1|        let country = Country.mockedData[0]
   20|      1|        let interactors = DIContainer.Interactors.mocked(
   21|      1|            imagesInteractor: [.loadImage(country.flag)]
   22|      1|        )
   23|      1|        let isDisplayed = Binding(wrappedValue: true)
   24|      1|        let sut = ModalDetailsView(country: country, isDisplayed: isDisplayed)
   25|      1|        let exp = sut.inspection.inspect { view in
   26|      1|            XCTAssertNoThrow(try view.find(SVGImageView.self))
   27|      1|            XCTAssertNoThrow(try view.find(button: "Close"))
   28|      1|            interactors.verify()
   29|      1|        }
   30|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   31|      1|        wait(for: [exp], timeout: 2)
   32|      1|    }
   33|       |    
   34|      1|    func test_modalDetails_close() {
   35|      1|        let country = Country.mockedData[0]
   36|      1|        let interactors = DIContainer.Interactors.mocked(
   37|      1|            imagesInteractor: [.loadImage(country.flag)]
   38|      1|        )
   39|      1|        let isDisplayed = Binding(wrappedValue: true)
   40|      1|        let sut = ModalDetailsView(country: country, isDisplayed: isDisplayed)
   41|      1|        let exp = sut.inspection.inspect { view in
   42|      1|            XCTAssertTrue(isDisplayed.wrappedValue)
   43|      1|            try view.find(button: "Close").tap()
   44|      0|            XCTAssertFalse(isDisplayed.wrappedValue)
   45|      1|            interactors.verify()
   46|      1|        }
   47|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   48|      1|        wait(for: [exp], timeout: 2)
   49|      1|    }
   50|       |    
   51|      1|    func test_modalDetails_close_localization() throws {
   52|      1|        let isDisplayed = Binding(wrappedValue: true)
   53|      1|        let sut = ModalDetailsView(country: Country.mockedData[0], isDisplayed: isDisplayed)
   54|      1|        let labelText = try sut.inspect().find(text: "Close")
   55|      0|        XCTAssertEqual(try labelText.string(), "Close")
   56|      0|        XCTAssertEqual(try labelText.string(locale: Locale(identifier: "fr")), "Fermer")
   57|      1|    }
   58|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/RootViewAppearanceTests.swift:
    1|       |//
    2|       |//  RootViewAppearanceTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 05.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import SwiftUI
   11|       |import ViewInspector
   12|       |@testable import CountriesSwiftUI
   13|       |
   14|       |extension RootViewAppearance: Inspectable { }
   15|       |
   16|       |final class RootViewAppearanceTests: XCTestCase {
   17|       |
   18|      1|    func test_blur_whenInactive() {
   19|      1|        let sut = RootViewAppearance()
   20|      1|        let container = DIContainer(appState: .init(AppState()),
   21|      1|                                    interactors: .mocked())
   22|      1|        XCTAssertFalse(container.appState.value.system.isActive)
   23|      1|        let exp = sut.inspection.inspect { modifier in
   24|      1|            let content = try modifier.viewModifierContent()
   25|      1|            XCTAssertEqual(try content.blur().radius, 10)
   26|      1|        }
   27|      1|        let view = EmptyView().modifier(sut)
   28|      1|            .environment(\.injected, container)
   29|      1|        ViewHosting.host(view: view)
   30|      1|        wait(for: [exp], timeout: 0.1)
   31|      1|    }
   32|       |    
   33|      1|    func test_blur_whenActive() {
   34|      1|        let sut = RootViewAppearance()
   35|      1|        let container = DIContainer(appState: .init(AppState()),
   36|      1|                                    interactors: .mocked())
   37|      1|        container.appState[\.system.isActive] = true
   38|      1|        XCTAssertTrue(container.appState.value.system.isActive)
   39|      1|        let exp = sut.inspection.inspect { modifier in
   40|      1|            let content = try modifier.viewModifierContent()
   41|      1|            XCTAssertEqual(try content.blur().radius, 0)
   42|      1|        }
   43|      1|        let view = EmptyView().modifier(sut)
   44|      1|            .environment(\.injected, container)
   45|      1|        ViewHosting.host(view: view)
   46|      1|        wait(for: [exp], timeout: 0.1)
   47|      1|    }
   48|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/SVGImageViewTests.swift:
    1|       |//
    2|       |//  SVGImageViewTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 10.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import SwiftUI
   11|       |import ViewInspector
   12|       |@testable import CountriesSwiftUI
   13|       |
   14|       |extension SVGImageView: Inspectable { }
   15|       |
   16|       |final class SVGImageViewTests: XCTestCase {
   17|       |
   18|      5|    let url = URL(string: "https://test.com/test.png")!
   19|       |
   20|      1|    func test_imageView_notRequested() {
   21|      1|        let interactors = DIContainer.Interactors.mocked(
   22|      1|            imagesInteractor: [.loadImage(url)])
   23|      1|        let sut = SVGImageView(imageURL: url, image: .notRequested)
   24|      1|        let exp = sut.inspection.inspect { view in
   25|      1|            XCTAssertNoThrow(try view.find(text: ""))
   26|      1|            interactors.verify()
   27|      1|        }
   28|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   29|      1|        wait(for: [exp], timeout: 2)
   30|      1|    }
   31|       |    
   32|      1|    func test_imageView_isLoading_initial() {
   33|      1|        let interactors = DIContainer.Interactors.mocked()
   34|      1|        let sut = SVGImageView(imageURL: url, image:
   35|      1|            .isLoading(last: nil, cancelBag: CancelBag()))
   36|      1|        let exp = sut.inspection.inspect { view in
   37|      1|            XCTAssertNoThrow(try view.find(ActivityIndicatorView.self))
   38|      1|            interactors.verify()
   39|      1|        }
   40|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   41|      1|        wait(for: [exp], timeout: 2)
   42|      1|    }
   43|       |    
   44|      1|    func test_imageView_isLoading_refresh() {
   45|      1|        let interactors = DIContainer.Interactors.mocked()
   46|      1|        let image = UIColor.red.image(CGSize(width: 10, height: 10))
   47|      1|        let sut = SVGImageView(imageURL: url, image:
   48|      1|            .isLoading(last: image, cancelBag: CancelBag()))
   49|      1|        let exp = sut.inspection.inspect { view in
   50|      1|            XCTAssertNoThrow(try view.find(ActivityIndicatorView.self))
   51|      1|            interactors.verify()
   52|      1|        }
   53|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   54|      1|        wait(for: [exp], timeout: 2)
   55|      1|    }
   56|       |    
   57|      1|    func test_imageView_loaded() {
   58|      1|        let interactors = DIContainer.Interactors.mocked()
   59|      1|        let image = UIColor.red.image(CGSize(width: 10, height: 10))
   60|      1|        let sut = SVGImageView(imageURL: url, image: .loaded(image))
   61|      1|        let exp = sut.inspection.inspect { view in
   62|      1|            let loadedImage = try view.find(ViewType.Image.self).actualImage().uiImage()
   63|      1|            XCTAssertEqual(loadedImage, image)
   64|      1|            interactors.verify()
   65|      1|        }
   66|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   67|      1|        wait(for: [exp], timeout: 3)
   68|      1|    }
   69|       |    
   70|      1|    func test_imageView_failed() {
   71|      1|        let interactors = DIContainer.Interactors.mocked()
   72|      1|        let sut = SVGImageView(imageURL: url, image: .failed(NSError.test))
   73|      1|        let exp = sut.inspection.inspect { view in
   74|      1|            XCTAssertNoThrow(try view.find(text: "Unable to load image"))
   75|      1|            interactors.verify()
   76|      1|        }
   77|      1|        ViewHosting.host(view: sut.inject(AppState(), interactors))
   78|      1|        wait(for: [exp], timeout: 2)
   79|      1|    }
   80|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/SearchBarTests.swift:
    1|       |//
    2|       |//  SearchBarTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 15.01.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import SwiftUI
   11|       |import ViewInspector
   12|       |@testable import CountriesSwiftUI
   13|       |
   14|       |extension SearchBar: Inspectable { }
   15|       |
   16|       |final class SearchBarTests: XCTestCase {
   17|       |
   18|      1|    func test_searchBarCoordinator_beginEditing() {
   19|      1|        let text = Binding(wrappedValue: "abc")
   20|      1|        let sut = SearchBar.Coordinator(text: text)
   21|      1|        let searchBar = UISearchBar(frame: .zero)
   22|      1|        searchBar.delegate = sut
   23|      1|        XCTAssertTrue(sut.searchBarShouldBeginEditing(searchBar))
   24|      1|        XCTAssertTrue(searchBar.showsCancelButton)
   25|      1|        XCTAssertEqual(text.wrappedValue, "abc")
   26|      1|    }
   27|       |    
   28|      1|    func test_searchBarCoordinator_endEditing() {
   29|      1|        let text = Binding(wrappedValue: "abc")
   30|      1|        let sut = SearchBar.Coordinator(text: text)
   31|      1|        let searchBar = UISearchBar(frame: .zero)
   32|      1|        searchBar.delegate = sut
   33|      1|        XCTAssertTrue(sut.searchBarShouldEndEditing(searchBar))
   34|      1|        XCTAssertFalse(searchBar.showsCancelButton)
   35|      1|        XCTAssertEqual(text.wrappedValue, "abc")
   36|      1|    }
   37|       |    
   38|      1|    func test_searchBarCoordinator_textDidChange() {
   39|      1|        let text = Binding(wrappedValue: "abc")
   40|      1|        let sut = SearchBar.Coordinator(text: text)
   41|      1|        let searchBar = UISearchBar(frame: .zero)
   42|      1|        searchBar.delegate = sut
   43|      1|        sut.searchBar(searchBar, textDidChange: "test")
   44|      1|        XCTAssertEqual(text.wrappedValue, "test")
   45|      1|    }
   46|       |    
   47|      1|    func test_searchBarCoordinator_cancelButtonClicked() {
   48|      1|        let text = Binding(wrappedValue: "abc")
   49|      1|        let sut = SearchBar.Coordinator(text: text)
   50|      1|        let searchBar = UISearchBar(frame: .zero)
   51|      1|        searchBar.text = text.wrappedValue
   52|      1|        searchBar.delegate = sut
   53|      1|        sut.searchBarCancelButtonClicked(searchBar)
   54|      1|        XCTAssertEqual(searchBar.text, "")
   55|      1|        XCTAssertEqual(text.wrappedValue, "")
   56|      1|    }
   57|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/UI/ViewPreviewsTests.swift:
    1|       |//
    2|       |//  ViewPreviewsTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 01.11.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import ViewInspector
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class ViewPreviewsTests: XCTestCase {
   14|       |
   15|      1|    func test_contentView_previews() {
   16|      1|        _ = ContentView_Previews.previews
   17|      1|    }
   18|       |    
   19|      1|    func test_countriesList_previews() {
   20|      1|        _ = CountriesList_Previews.previews
   21|      1|    }
   22|       |    
   23|      1|    func test_countryDetails_previews() {
   24|      1|        _ = CountryDetails_Previews.previews
   25|      1|    }
   26|       |    
   27|      1|    func test_modalDetailsView_previews() {
   28|      1|        _ = ModalDetailsView_Previews.previews
   29|      1|    }
   30|       |    
   31|      1|    func test_countryCell_previews() {
   32|      1|        _ = CountryCell_Previews.previews
   33|      1|    }
   34|       |    
   35|      1|    func test_detailRow_previews() {
   36|      1|        _ = DetailRow_Previews.previews
   37|      1|    }
   38|       |    
   39|      1|    func test_errorView_previews() throws {
   40|      1|        let view = ErrorView_Previews.previews
   41|      1|        try view.inspect().view(ErrorView.self).actualView().retryAction()
   42|      1|    }
   43|       |    
   44|      1|    func test_svgImageView_previews() {
   45|      1|        _ = SVGImageView_Previews.previews
   46|      1|    }
   47|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Utilities/HelpersTests.swift:
    1|       |//
    2|       |//  HelpersTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 27.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |@testable import CountriesSwiftUI
   11|       |
   12|       |class HelpersTests: XCTestCase {
   13|       |
   14|      1|    func test_localized_knownLocale() {
   15|      1|        let sut = "Countries".localized(Locale(identifier: "fr"))
   16|      1|        XCTAssertEqual(sut, "Des pays")
   17|      1|    }
   18|       |    
   19|      1|    func test_localized_unknownLocale() {
   20|      1|        let sut = "Countries".localized(Locale(identifier: "ch"))
   21|      1|        XCTAssertEqual(sut, "Countries")
   22|      1|    }
   23|       |    
   24|      1|    func test_result_isSuccess() {
   25|      1|        let sut1 = Result<Void, Error>.success(())
   26|      1|        let sut2 = Result<Void, Error>.failure(NSError.test)
   27|      1|        XCTAssertTrue(sut1.isSuccess)
   28|      1|        XCTAssertFalse(sut2.isSuccess)
   29|      1|    }
   30|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Utilities/LazyListTests.swift:
    1|       |//
    2|       |//  LazyListTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 18.04.2020.
    6|       |//  Copyright Â© 2020 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class LazyListTests: XCTestCase {
   14|       |
   15|      1|    func test_empty() {
   16|      1|        let list = LazyList<Int>.empty
   17|      1|        XCTAssertThrowsError(try list.element(at: 0))
   18|      1|    }
   19|       |    
   20|      1|    func test_nil_element() {
   21|      1|        let list1 = LazyList<Int>(count: 1, useCache: false, { _ in nil })
   22|      1|        XCTAssertThrowsError(try list1.element(at: 0))
   23|      1|        let list2 = [0, 1].lazyList
   24|      1|        XCTAssertThrowsError(try list2.element(at: 2))
   25|      1|    }
   26|       |    
   27|      1|    func test_nil_element_error() {
   28|      1|        let error = LazyList<Int>.Error.elementIsNil(index: 5)
   29|      1|        XCTAssertEqual(error.localizedDescription, "Element at index 5 is nil")
   30|      1|    }
   31|       |    
   32|      1|    func test_access_noCache() {
   33|      1|        var counter = 0
   34|      6|        let list = LazyList<Int>(count: 3, useCache: false) { _ in
   35|      6|            counter += 1
   36|      6|            return counter
   37|      6|        }
   38|      6|        [0, 1, 2, 0, 1, 2].forEach { index in
   39|      6|            _ = list[index]
   40|      6|        }
   41|      1|        XCTAssertEqual(counter, 6)
   42|      1|    }
   43|       |    
   44|      1|    func test_access_withCache() {
   45|      1|        var counter = 0
   46|      3|        let list = LazyList<Int>(count: 3, useCache: true) { _ in
   47|      3|            counter += 1
   48|      3|            return counter
   49|      3|        }
   50|      6|        [0, 1, 2, 0, 1, 2].forEach { index in
   51|      6|            _ = list[index]
   52|      6|        }
   53|      1|        XCTAssertEqual(counter, 3)
   54|      1|    }
   55|       |    
   56|     10|    let bgQueue1 = DispatchQueue(label: "bg1")
   57|     10|    let bgQueue2 = DispatchQueue(label: "bg2")
   58|       |    
   59|      1|    func test_concurrent_access() {
   60|      1|        let indices = Array(stride(from: 0, to: 100, by: 1))
   61|      1|        var counter = 0
   62|    100|        let list = LazyList<Int>(count: indices.count, useCache: true) { index in
   63|    100|            counter += 1
   64|    100|            return index
   65|    100|        }
   66|      1|        let exp1 = XCTestExpectation(description: "queue1")
   67|      1|        let exp2 = XCTestExpectation(description: "queue2")
   68|      1|        bgQueue1.async {
   69|    100|            let result1 = indices.map { list[$0] }
   70|      1|            XCTAssertEqual(result1, indices)
   71|      1|            XCTAssertEqual(counter, indices.count)
   72|      1|            exp1.fulfill()
   73|      1|        }
   74|      1|        bgQueue2.async {
   75|    100|            let result2 = indices.map { list[$0] }
   76|      1|            XCTAssertEqual(result2, indices)
   77|      1|            XCTAssertEqual(counter, indices.count)
   78|      1|            exp2.fulfill()
   79|      1|        }
   80|      1|        wait(for: [exp1, exp2], timeout: 0.5)
   81|      1|    }
   82|       |    
   83|      1|    func test_sequence() {
   84|      1|        let indices = Array(stride(from: 0, to: 10, by: 1))
   85|     10|        let list = LazyList<Int>(count: indices.count, useCache: true) { $0 }
   86|      1|        XCTAssertEqual(list.underestimatedCount, indices.count)
   87|      1|        XCTAssertEqual(list.reversed(), indices.reversed())
   88|      1|        
   89|      1|        let nilList = LazyList<Int>(count: 1, useCache: false) { _ in nil }
   90|      1|        var iterator = nilList.makeIterator()
   91|      1|        XCTAssertNil(iterator.next())
   92|      1|    }
   93|       |    
   94|      1|    func test_randomAccessCollection() {
   95|      4|        let list = LazyList<Int>(count: 10, useCache: true) { $0 }
   96|      1|        XCTAssertEqual(list.firstIndex(of: 2), 2)
   97|      1|        XCTAssertEqual(list.last, 9)
   98|      1|    }
   99|       |    
  100|      1|    func test_equatable() {
  101|     10|        let list1 = LazyList<Int>(count: 10, useCache: true) { $0 }
  102|      0|        let list2 = LazyList<Int>(count: 11, useCache: true) { $0 }
  103|      1|        let list3 = Array(stride(from: 0, to: 10, by: 1)).lazyList
  104|      1|        XCTAssertNotEqual(list1, list2)
  105|      1|        XCTAssertEqual(list1, list1)
  106|      1|        XCTAssertEqual(list1, list3)
  107|      1|    }
  108|       |    
  109|      1|    func test_description() {
  110|      1|        let emptyList = LazyList<Int>.empty
  111|      1|        let oneElementList = LazyList<Int>(count: 1, useCache: false) { $0 + 1 }
  112|      3|        let nonEmptyList = LazyList<Int>(count: 3, useCache: false) { $0 * 2 }
  113|      1|        XCTAssertEqual(emptyList.description, "LazyList<[]>")
  114|      1|        XCTAssertEqual(oneElementList.description, "LazyList<[1]>")
  115|      1|        XCTAssertEqual(nonEmptyList.description, "LazyList<[0, 2, 4]>")
  116|      1|    }
  117|       |}

/Users/aikesiero/Desktop/clean-architecture-swiftui-master/UnitTests/Utilities/LoadableTests.swift:
    1|       |//
    2|       |//  LoadableTests.swift
    3|       |//  UnitTests
    4|       |//
    5|       |//  Created by Alexey Naumov on 31.10.2019.
    6|       |//  Copyright Â© 2019 Alexey Naumov. All rights reserved.
    7|       |//
    8|       |
    9|       |import XCTest
   10|       |import Combine
   11|       |@testable import CountriesSwiftUI
   12|       |
   13|       |final class LoadableTests: XCTestCase {
   14|       |
   15|      1|    func test_equality() {
   16|      1|        let possibleValues: [Loadable<Int>] = [
   17|      1|            .notRequested,
   18|      1|            .isLoading(last: nil, cancelBag: CancelBag()),
   19|      1|            .isLoading(last: 9, cancelBag: CancelBag()),
   20|      1|            .loaded(5),
   21|      1|            .loaded(6),
   22|      1|            .failed(NSError.test)
   23|      1|        ]
   24|      6|        possibleValues.enumerated().forEach { (index1, value1) in
   25|     36|            possibleValues.enumerated().forEach { (index2, value2) in
   26|     36|                if index1 == index2 {
   27|      6|                    XCTAssertEqual(value1, value2)
   28|     36|                } else {
   29|     30|                    XCTAssertNotEqual(value1, value2)
   30|     36|                }
   31|     36|            }
   32|      6|        }
   33|      1|    }
   34|       |    
   35|      1|    func test_cancelLoading() {
   36|      1|        let cancenBag1 = CancelBag(), cancenBag2 = CancelBag()
   37|      1|        let subject = PassthroughSubject<Int, Never>()
   38|      0|        subject.sink { _ in }
   39|      1|            .store(in: cancenBag1)
   40|      0|        subject.sink { _ in }
   41|      1|            .store(in: cancenBag2)
   42|      1|        var sut1 = Loadable<Int>.isLoading(last: nil, cancelBag: cancenBag1)
   43|      1|        XCTAssertEqual(cancenBag1.subscriptions.count, 1)
   44|      1|        sut1.cancelLoading()
   45|      1|        XCTAssertEqual(cancenBag1.subscriptions.count, 0)
   46|      1|        XCTAssertNotNil(sut1.error)
   47|      1|        var sut2 = Loadable<Int>.isLoading(last: 7, cancelBag: cancenBag2)
   48|      1|        XCTAssertEqual(cancenBag2.subscriptions.count, 1)
   49|      1|        sut2.cancelLoading()
   50|      1|        XCTAssertEqual(cancenBag2.subscriptions.count, 0)
   51|      1|        XCTAssertEqual(sut2.value, 7)
   52|      1|    }
   53|       |    
   54|      1|    func test_map() {
   55|      1|        let values: [Loadable<Int>] = [
   56|      1|            .notRequested,
   57|      1|            .isLoading(last: nil, cancelBag: CancelBag()),
   58|      1|            .isLoading(last: 5, cancelBag: CancelBag()),
   59|      1|            .loaded(7),
   60|      1|            .failed(NSError.test)
   61|      1|        ]
   62|      1|        let expect: [Loadable<String>] = [
   63|      1|            .notRequested,
   64|      1|            .isLoading(last: nil, cancelBag: CancelBag()),
   65|      1|            .isLoading(last: "5", cancelBag: CancelBag()),
   66|      1|            .loaded("7"),
   67|      1|            .failed(NSError.test)
   68|      1|        ]
   69|      5|        let sut = values.map { value in
   70|      2|            value.map { "\($0)" }
   71|      5|        }
   72|      1|        XCTAssertEqual(sut, expect)
   73|      1|    }
   74|       |
   75|      1|    func test_helperFunctions() {
   76|      1|        let notRequested = Loadable<Int>.notRequested
   77|      1|        let loadingNil = Loadable<Int>.isLoading(last: nil, cancelBag: CancelBag())
   78|      1|        let loadingValue = Loadable<Int>.isLoading(last: 9, cancelBag: CancelBag())
   79|      1|        let loaded = Loadable<Int>.loaded(5)
   80|      1|        let failedErrValue = Loadable<Int>.failed(NSError.test)
   81|      2|        [notRequested, loadingNil].forEach {
   82|      2|            XCTAssertNil($0.value)
   83|      2|        }
   84|      2|        [loadingValue, loaded].forEach {
   85|      2|            XCTAssertNotNil($0.value)
   86|      2|        }
   87|      4|        [notRequested, loadingNil, loadingValue, loaded].forEach {
   88|      4|            XCTAssertNil($0.error)
   89|      4|        }
   90|      1|        XCTAssertNotNil(failedErrValue.error)
   91|      1|    }
   92|       |    
   93|      1|    func test_throwingMap() {
   94|      1|        let value = Loadable<Int>.loaded(5)
   95|      1|        let sut = value.map { _ in throw NSError.test }
   96|      1|        XCTAssertNotNil(sut.error)
   97|      1|    }
   98|       |    
   99|      1|    func test_valueIsMissing() {
  100|      1|        XCTAssertEqual(ValueIsMissingError().localizedDescription, "Data is missing")
  101|      1|    }
  102|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/BaseTypes.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Protocols
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public protocol Inspectable {
    7|       |    var entity: Content.InspectableEntity { get }
    8|       |    func extractContent(environmentObjects: [AnyObject]) throws -> Any
    9|       |}
   10|       |
   11|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   12|       |public extension Content {
   13|       |    enum InspectableEntity {
   14|       |        case view
   15|       |        case viewModifier
   16|       |        case gesture
   17|       |    }
   18|       |}
   19|       |
   20|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   21|       |public extension Inspectable where Self: View {
   22|     31|    var entity: Content.InspectableEntity { .view }
   23|       |    
   24|     67|    func extractContent(environmentObjects: [AnyObject]) throws -> Any {
   25|     67|        var copy = self
   26|      0|        environmentObjects.forEach { copy.inject(environmentObject: $0) }
   27|     67|        let missingObjects = copy.missingEnvironmentObjects
   28|     67|        if missingObjects.count > 0 {
   29|      0|            let view = Inspector.typeName(value: self)
   30|      0|            throw InspectionError
   31|      0|                .missingEnvironmentObjects(view: view, objects: missingObjects)
   32|     67|        }
   33|     67|        return copy.body
   34|     67|    }
   35|       |}
   36|       |
   37|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   38|       |public extension Inspectable where Self: ViewModifier {
   39|       |    
   40|     19|    var entity: ViewInspector.Content.InspectableEntity { .viewModifier }
   41|       |    
   42|     66|    func extractContent(environmentObjects: [AnyObject]) throws -> Any {
   43|     66|        var copy = self
   44|      0|        environmentObjects.forEach { copy.inject(environmentObject: $0) }
   45|     66|        let missingObjects = copy.missingEnvironmentObjects
   46|     66|        if missingObjects.count > 0 {
   47|      0|            let view = Inspector.typeName(value: self)
   48|      0|            throw InspectionError
   49|      0|                .missingEnvironmentObjects(view: view, objects: missingObjects)
   50|     66|        }
   51|     66|        return copy.body()
   52|     66|    }
   53|       |}
   54|       |
   55|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   56|       |public protocol SingleViewContent {
   57|       |    static func child(_ content: Content) throws -> Content
   58|       |}
   59|       |
   60|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   61|       |public protocol MultipleViewContent {
   62|       |    static func children(_ content: Content) throws -> LazyGroup<Content>
   63|       |}
   64|       |
   65|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   66|       |internal typealias SupplementaryView = UnwrappedView
   67|       |
   68|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   69|       |internal protocol SupplementaryChildren {
   70|       |    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView>
   71|       |}
   72|       |
   73|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   74|       |internal protocol SupplementaryChildrenLabelView: SupplementaryChildren {
   75|       |    static var labelViewPath: String { get }
   76|       |}
   77|       |
   78|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   79|       |extension SupplementaryChildrenLabelView {
   80|      0|    static var labelViewPath: String { "label" }
   81|      5|    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView> {
   82|      4|        return .init(count: 1) { _ in
   83|      4|            let child = try Inspector.attribute(path: labelViewPath, value: parent.content.view)
   84|      4|            let medium = parent.content.medium.resettingViewModifiers()
   85|      4|            let content = try Inspector.unwrap(content: Content(child, medium: medium))
   86|      4|            return try InspectableView<ViewType.ClassifiedView>(content, parent: parent, call: "labelView()")
   87|      4|        }
   88|      5|    }
   89|       |}
   90|       |
   91|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   92|       |public protocol KnownViewType {
   93|       |    static var typePrefix: String { get }
   94|       |    static var namespacedPrefixes: [String] { get }
   95|       |    static var isTransitive: Bool { get }
   96|       |    static func inspectionCall(typeName: String) -> String
   97|       |}
   98|       |
   99|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  100|       |public extension KnownViewType {
  101|  1.09k|    static var namespacedPrefixes: [String] {
  102|    752|        guard !typePrefix.isEmpty else { return [] }
  103|    752|        return ["SwiftUI." + typePrefix]
  104|  1.09k|    }
  105|      0|    static var isTransitive: Bool { false }
  106|     76|    static func inspectionCall(typeName: String) -> String {
  107|     76|        let baseName = typePrefix.prefix(1).lowercased() + typePrefix.dropFirst()
  108|     76|        return "\(baseName)(\(ViewType.indexPlaceholder))"
  109|     76|    }
  110|       |}
  111|       |
  112|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  113|       |public struct ViewType { }
  114|       |
  115|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  116|       |internal extension ViewType {
  117|       |    static let indexPlaceholder = "###"
  118|       |    static let commaPlaceholder = "~~~"
  119|       |    
  120|    182|    static func inspectionCall(base: String, index: Int?) -> String {
  121|     45|        if let index = index {
  122|     45|            return base
  123|     45|                .replacingOccurrences(of: commaPlaceholder, with: ", ")
  124|     45|                .replacingOccurrences(of: indexPlaceholder, with: "\(index)")
  125|    137|        } else {
  126|    137|            return base
  127|    137|                .replacingOccurrences(of: commaPlaceholder, with: "")
  128|    137|                .replacingOccurrences(of: indexPlaceholder, with: "")
  129|      0|        }
  130|      0|    }
  131|       |}
  132|       |
  133|       |// MARK: - Content
  134|       |
  135|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  136|       |public struct Content {
  137|       |    let view: Any
  138|       |    let medium: Medium
  139|       |    
  140|    879|    internal init(_ view: Any, medium: Medium = .empty) {
  141|    879|        self.view = view
  142|    879|        self.medium = medium
  143|    879|    }
  144|       |}
  145|       |
  146|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  147|       |internal extension Content {
  148|       |    struct Medium {
  149|       |        let viewModifiers: [Any]
  150|       |        let transitiveViewModifiers: [Any]
  151|       |        let environmentModifiers: [EnvironmentModifier]
  152|       |        let environmentObjects: [AnyObject]
  153|       |        
  154|     31|        static var empty: Medium {
  155|     31|            return .init(viewModifiers: [],
  156|     31|                         transitiveViewModifiers: [],
  157|     31|                         environmentModifiers: [],
  158|     31|                         environmentObjects: [])
  159|     31|        }
  160|       |        
  161|    278|        func appending(viewModifier: Any) -> Medium {
  162|    278|            return .init(viewModifiers: viewModifiers + [viewModifier],
  163|    278|                         transitiveViewModifiers: transitiveViewModifiers,
  164|    278|                         environmentModifiers: environmentModifiers,
  165|    278|                         environmentObjects: environmentObjects)
  166|    278|        }
  167|       |        
  168|      0|        func appending(transitiveViewModifier: Any) -> Medium {
  169|      0|            return .init(viewModifiers: viewModifiers,
  170|      0|                         transitiveViewModifiers: transitiveViewModifiers + [transitiveViewModifier],
  171|      0|                         environmentModifiers: environmentModifiers,
  172|      0|                         environmentObjects: environmentObjects)
  173|      0|        }
  174|       |        
  175|     53|        func appending(environmentModifier: EnvironmentModifier) -> Medium {
  176|     53|            return .init(viewModifiers: viewModifiers,
  177|     53|                         transitiveViewModifiers: transitiveViewModifiers,
  178|     53|                         environmentModifiers: environmentModifiers + [environmentModifier],
  179|     53|                         environmentObjects: environmentObjects)
  180|     53|        }
  181|       |        
  182|      0|        func appending(environmentObject: AnyObject) -> Medium {
  183|      0|            return .init(viewModifiers: viewModifiers,
  184|      0|                         transitiveViewModifiers: transitiveViewModifiers,
  185|      0|                         environmentModifiers: environmentModifiers,
  186|      0|                         environmentObjects: environmentObjects + [environmentObject])
  187|      0|        }
  188|       |        
  189|    266|        func resettingViewModifiers() -> Medium {
  190|    266|            return .init(viewModifiers: [],
  191|    266|                         transitiveViewModifiers: transitiveViewModifiers,
  192|    266|                         environmentModifiers: environmentModifiers,
  193|    266|                         environmentObjects: environmentObjects)
  194|    266|        }
  195|       |        
  196|      2|        func removingCustomViewModifiers() -> Medium {
  197|      2|            let modifiers = viewModifiers
  198|      4|                .filter {
  199|      4|                    guard let modifier = $0 as? ModifierNameProvider else { return true }
  200|      4|                    return modifier.customModifier == nil
  201|      4|                }
  202|      2|            return .init(viewModifiers: modifiers,
  203|      2|                         transitiveViewModifiers: transitiveViewModifiers,
  204|      2|                         environmentModifiers: environmentModifiers,
  205|      2|                         environmentObjects: environmentObjects)
  206|      2|        }
  207|       |    }
  208|       |}
  209|       |
  210|       |// MARK: - Binding helper
  211|       |
  212|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  213|       |public extension Binding {
  214|      7|    init(wrappedValue: Value) {
  215|      7|        var value = wrappedValue
  216|     15|        self.init(get: { value }, set: { value = $0 })
  217|      7|    }
  218|       |}
  219|       |
  220|       |// MARK: - Error
  221|       |
  222|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  223|       |public enum InspectionError: Swift.Error {
  224|       |    case inspection(path: String, factual: String, expected: String)
  225|       |    case typeMismatch(factual: String, expected: String)
  226|       |    case attributeNotFound(label: String, type: String)
  227|       |    case viewIndexOutOfBounds(index: Int, count: Int)
  228|       |    case viewNotFound(parent: String)
  229|       |    case parentViewNotFound(view: String)
  230|       |    case modifierNotFound(parent: String, modifier: String, index: Int)
  231|       |    case missingEnvironmentObjects(view: String, objects: [String])
  232|       |    case notSupported(String)
  233|       |    case textAttribute(String)
  234|       |    case searchFailure(skipped: Int, blockers: [String])
  235|       |    case callbackNotFound(parent: String, callback: String)
  236|       |    case unresponsiveControl(name: String, reason: String)
  237|       |}
  238|       |
  239|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  240|       |extension InspectionError: CustomStringConvertible, LocalizedError {
  241|       |    
  242|     42|    public var description: String {
  243|     42|        switch self {
  244|      4|        case let .inspection(path, factual, expected):
  245|      4|            return "\(path) found \(factual) instead of \(expected)"
  246|      5|        case let .typeMismatch(factual, expected):
  247|      5|            return "Type mismatch: \(factual) is not \(expected)"
  248|      1|        case let .attributeNotFound(label, type):
  249|      1|            return "\(type) does not have '\(label)' attribute"
  250|      0|        case let .viewIndexOutOfBounds(index, count):
  251|      0|            return "Enclosed view index '\(index)' is out of bounds: '0 ..< \(count)'"
  252|      0|        case let .viewNotFound(parent):
  253|      0|            return "View for \(parent) is absent"
  254|      0|        case let .parentViewNotFound(view):
  255|      0|            return "\(view) does not have parent"
  256|     21|        case let .modifierNotFound(parent, modifier, index):
  257|     21|            return "\(parent) does not have '\(modifier)' modifier"
  258|     21|                + (index == 0 ? "" : " at index \(index)")
  259|      0|        case let .missingEnvironmentObjects(view, objects):
  260|      0|            return "\(view) is missing EnvironmentObjects: \(objects)"
  261|      4|        case let .notSupported(message), let .textAttribute(message):
  262|      4|            return message
  263|      7|        case let .searchFailure(skipped, blockers):
  264|      5|             let blockersDescription = blockers.count == 0 ? "" :
  265|      2|                 ". Possible blockers: \(blockers.joined(separator: ", "))"
  266|      7|             let conclusion = skipped == 0 ?
  267|      7|                 "Search did not find a match" : "Search did only find \(skipped) matches"
  268|      7|             return conclusion + blockersDescription
  269|      0|        case let .callbackNotFound(parent, callback):
  270|      0|            return "\(parent) does not have '\(callback)' callback"
  271|      0|        case let .unresponsiveControl(name, reason):
  272|      0|            return "\(name) is unresponsive: \(reason)"
  273|     42|        }
  274|     42|    }
  275|       |    
  276|      8|    public var errorDescription: String? {
  277|      8|        return description
  278|      8|    }
  279|       |}
  280|       |
  281|       |// MARK: - BinaryEquatable
  282|       |
  283|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  284|       |internal protocol BinaryEquatable: Equatable { }
  285|       |
  286|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  287|       |extension BinaryEquatable {
  288|      0|    static func == (lhs: Self, rhs: Self) -> Bool {
  289|      0|        withUnsafeBytes(of: lhs) { lhsBytes -> Bool in
  290|      0|            withUnsafeBytes(of: rhs) { rhsBytes -> Bool in
  291|      0|                lhsBytes.elementsEqual(rhsBytes)
  292|      0|            }
  293|      0|        }
  294|      0|    }
  295|       |}
  296|       |
  297|       |// MARK: - EnvironmentObject injection
  298|       |
  299|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  300|       |internal extension Inspectable {
  301|    134|    var missingEnvironmentObjects: [String] {
  302|    134|        let prefix = "SwiftUI.EnvironmentObject<"
  303|    134|        let mirror = Mirror(reflecting: self)
  304|    518|        return mirror.children.compactMap {
  305|    518|            let fullName = Inspector.typeName(value: $0.value, namespaced: true)
  306|    518|            guard fullName.hasPrefix(prefix),
  307|    518|                  (try? Inspector.attribute(path: "_store|some", value: $0.value)) == nil,
  308|    518|                  let ivarName = $0.label
  309|    518|            else { return nil }
  310|      0|            var objName = Inspector.typeName(value: $0.value)
  311|      0|            objName = objName[18..<objName.count - 1]
  312|      0|            return "\(ivarName[1..<ivarName.count]): \(objName)"
  313|    518|        }
  314|    134|    }
  315|      0|    mutating func inject(environmentObject: AnyObject) {
  316|      0|        let type = "SwiftUI.EnvironmentObject<\(Inspector.typeName(value: environmentObject, namespaced: true))>"
  317|      0|        let mirror = Mirror(reflecting: self)
  318|      0|        guard let label = mirror.children
  319|      0|                .first(where: {
  320|      0|                    Inspector.typeName(value: $0.value, namespaced: true) == type
  321|      0|                })?.label
  322|      0|        else { return }
  323|      0|        let envObjSize = EnvObject.structSize
  324|      0|        let viewSize = MemoryLayout<Self>.size
  325|      0|        var offset = MemoryLayout<Self>.stride - envObjSize
  326|      0|        let step = MemoryLayout<Self>.alignment
  327|      0|        while offset + envObjSize > viewSize {
  328|      0|            offset -= step
  329|      0|        }
  330|      0|        withUnsafeBytes(of: EnvObject.Forgery(object: nil)) { reference in
  331|      0|            while offset >= 0 {
  332|      0|                var copy = self
  333|      0|                withUnsafeMutableBytes(of: &copy) { bytes in
  334|      0|                    guard bytes[offset..<offset + envObjSize].elementsEqual(reference)
  335|      0|                    else { return }
  336|      0|                    let rawPointer = bytes.baseAddress! + offset + EnvObject.seedOffset
  337|      0|                    let pointerToValue = rawPointer.assumingMemoryBound(to: Int.self)
  338|      0|                    pointerToValue.pointee = -1
  339|      0|                }
  340|      0|                if let seed = try? Inspector.attribute(path: label + "|_seed", value: copy, type: Int.self),
  341|      0|                   seed == -1 {
  342|      0|                    withUnsafeMutableBytes(of: &copy) { bytes in
  343|      0|                        let rawPointer = bytes.baseAddress! + offset
  344|      0|                        let pointerToValue = rawPointer.assumingMemoryBound(to: EnvObject.Forgery.self)
  345|      0|                        pointerToValue.pointee = .init(object: environmentObject)
  346|      0|                    }
  347|      0|                    self = copy
  348|      0|                    return
  349|      0|                }
  350|      0|                offset -= step
  351|      0|            }
  352|      0|        }
  353|      0|    }
  354|       |}
  355|       |
  356|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  357|       |internal struct EnvObject {
  358|      0|    static var seedOffset: Int { 8 }
  359|      0|    static var structSize: Int { 16 }
  360|       |    
  361|       |    struct Forgery {
  362|       |        let object: AnyObject?
  363|       |        let seed: Int = 0
  364|       |    }
  365|       |}
  366|       |
  367|       |internal extension String {
  368|      0|    subscript(intRange: Range<Int>) -> String {
  369|      0|        let range = Range(uncheckedBounds: (lower: max(0, min(count, intRange.lowerBound)),
  370|      0|                                            upper: min(count, max(0, intRange.upperBound))))
  371|      0|        let start = index(startIndex, offsetBy: range.lowerBound)
  372|      0|        let end = index(start, offsetBy: range.upperBound - range.lowerBound)
  373|      0|        return String(self[start ..< end])
  374|      0|    }
  375|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/InspectableView+RandomAccessCollection.swift:
    1|       |import Foundation
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |extension InspectableView: Sequence where View: MultipleViewContent {
    5|       |    
    6|       |    public typealias Element = InspectableView<ViewType.ClassifiedView>
    7|       |    
    8|       |    public struct Iterator: IteratorProtocol {
    9|       |        
   10|       |        private var groupIterator: LazyGroup<Content>.Iterator
   11|       |        private let view: UnwrappedView
   12|       |        
   13|      0|        init(_ group: LazyGroup<Content>, view: UnwrappedView) {
   14|      0|            groupIterator = group.makeIterator()
   15|      0|            self.view = view
   16|      0|        }
   17|       |        
   18|      0|        mutating public func next() -> Element? {
   19|      0|            guard let content = groupIterator.next()
   20|      0|                else { return nil }
   21|      0|            return try? .init(content, parent: view)
   22|      0|        }
   23|       |    }
   24|       |
   25|      0|    public func makeIterator() -> Iterator {
   26|      0|        // swiftlint:disable force_try
   27|      0|        return .init(try! View.children(content), view: self)
   28|      0|        // swiftlint:enable force_try
   29|      0|    }
   30|       |
   31|      0|    public var underestimatedCount: Int {
   32|      0|        // swiftlint:disable force_try
   33|      0|        return try! View.children(content).count
   34|      0|        // swiftlint:enable force_try
   35|      0|    }
   36|       |}
   37|       |
   38|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   39|       |extension InspectableView: Collection, BidirectionalCollection, RandomAccessCollection
   40|       |    where View: MultipleViewContent {
   41|       |    
   42|       |    public typealias Index = Int
   43|      0|    public var startIndex: Index { 0 }
   44|      0|    public var endIndex: Index { count }
   45|      0|    public var count: Int { underestimatedCount }
   46|       |    
   47|      0|    public subscript(index: Index) -> Iterator.Element {
   48|      0|        // swiftlint:disable force_try
   49|      0|        let viewes = try! View.children(content)
   50|      0|        return try! .init(try! viewes.element(at: index), parent: self, call: "[\(index)]")
   51|      0|        // swiftlint:enable force_try
   52|      0|    }
   53|       |
   54|      0|    public func index(after index: Index) -> Index { index + 1 }
   55|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/InspectableView.swift:
    1|       |import SwiftUI
    2|       |import XCTest
    3|       |
    4|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    5|       |public struct InspectableView<View> where View: KnownViewType {
    6|       |    
    7|       |    internal let content: Content
    8|       |    internal let parentView: UnwrappedView?
    9|       |    internal let inspectionCall: String
   10|       |    internal let inspectionIndex: Int?
   11|       |    internal var isUnwrappedSupplementaryChild: Bool = false
   12|       |    
   13|       |    internal init(_ content: Content, parent: UnwrappedView?,
   14|    785|                  call: String = #function, index: Int? = nil) throws {
   15|    785|        let parentView: UnwrappedView? = (parent is InspectableView<ViewType.ParentView>)
   16|    785|            ? parent?.parentView : parent
   17|    785|        let inspectionCall = index
   18|    542|            .flatMap({ call.replacingOccurrences(of: "_:", with: "\($0)") }) ?? call
   19|    785|        try self.init(content: content, parent: parentView, call: inspectionCall, index: index)
   20|    785|    }
   21|       |    
   22|    785|    private init(content: Content, parent: UnwrappedView?, call: String, index: Int?) throws {
   23|    785|        if !View.typePrefix.isEmpty,
   24|    785|           Inspector.isTupleView(content.view),
   25|      0|           View.self != ViewType.TupleView.self {
   26|      0|            throw InspectionError.notSupported(
   27|      0|                "Unable to extract \(View.typePrefix): please specify its index inside parent view")
   28|    785|        }
   29|    785|        self.content = content
   30|    785|        self.parentView = parent
   31|    785|        self.inspectionCall = call
   32|    785|        self.inspectionIndex = index
   33|    785|        do {
   34|    785|            try Inspector.guardType(value: content.view,
   35|    785|                                    namespacedPrefixes: View.namespacedPrefixes,
   36|    785|                                    inspectionCall: inspectionCall)
   37|    124|        } catch {
   38|    124|            if let err = error as? InspectionError, case .typeMismatch = err {
   39|    124|                let factual = Inspector.typeName(value: content.view, namespaced: true, prefixOnly: true)
   40|    124|                    .sanitizeNamespace()
   41|    124|                let expected = View.namespacedPrefixes
   42|    124|                    .map { $0.sanitizeNamespace() }
   43|    124|                    .joined(separator: " or ")
   44|    124|                throw InspectionError.inspection(path: pathToRoot, factual: factual, expected: expected)
   45|      0|            }
   46|      0|            throw error
   47|    785|        }
   48|    785|    }
   49|       |}
   50|       |
   51|       |private extension String {
   52|    248|    func sanitizeNamespace() -> String {
   53|    248|        var str = self
   54|      0|        if let range = str.range(of: ".(unknown context at ") {
   55|      0|            let end = str.index(range.upperBound, offsetBy: .init(11))
   56|      0|            str.replaceSubrange(range.lowerBound..<end, with: "")
   57|    248|        }
   58|    248|        return str.replacingOccurrences(of: "SwiftUI.", with: "")
   59|    248|    }
   60|       |}
   61|       |
   62|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   63|       |internal protocol UnwrappedView {
   64|       |    var content: Content { get }
   65|       |    var parentView: UnwrappedView? { get }
   66|       |    var inspectionCall: String { get }
   67|       |    var inspectionIndex: Int? { get }
   68|       |    var pathToRoot: String { get }
   69|       |    var isTransitive: Bool { get }
   70|       |    var isUnwrappedSupplementaryChild: Bool { get set }
   71|       |}
   72|       |
   73|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   74|       |extension InspectableView: UnwrappedView {
   75|      0|    var isTransitive: Bool { View.isTransitive }
   76|       |}
   77|       |
   78|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   79|       |internal extension UnwrappedView {
   80|    211|    func asInspectableView() throws -> InspectableView<ViewType.ClassifiedView> {
   81|    211|        return try .init(content, parent: parentView, call: inspectionCall, index: inspectionIndex)
   82|    211|    }
   83|       |    
   84|      0|    func asInspectableView<T>(ofType type: T.Type) throws -> InspectableView<T> where T: KnownViewType {
   85|      0|        return try .init(content, parent: parentView, call: inspectionCall, index: inspectionIndex)
   86|      0|    }
   87|       |}
   88|       |
   89|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   90|       |internal extension InspectableView {
   91|    211|    func asInspectableView<T>(ofType type: T.Type) throws -> InspectableView<T> where T: KnownViewType {
   92|    211|        return try .init(content, parent: parentView, call: inspectionCall, index: inspectionIndex)
   93|    211|    }
   94|       |}
   95|       |
   96|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   97|       |public extension InspectableView {
   98|      0|    func parent() throws -> InspectableView<ViewType.ParentView> {
   99|      0|        guard let parent = self.parentView else {
  100|      0|            throw InspectionError.parentViewNotFound(view: Inspector.typeName(value: content.view))
  101|      0|        }
  102|      0|        if parent.parentView == nil,
  103|      0|           parent is InspectableView<ViewType.ClassifiedView>,
  104|      0|           Inspector.typeName(value: parent.content.view, namespaced: true)
  105|      0|            == Inspector.typeName(value: content.view, namespaced: true) {
  106|      0|            throw InspectionError.parentViewNotFound(view: Inspector.typeName(value: content.view))
  107|      0|        }
  108|      0|        return try .init(parent.content, parent: parent.parentView, call: parent.inspectionCall)
  109|      0|    }
  110|       |    
  111|    357|    var pathToRoot: String {
  112|    233|        let prefix = parentView.flatMap { $0.pathToRoot } ?? ""
  113|    233|        return prefix.isEmpty ? inspectionCall : prefix + "." + inspectionCall
  114|    357|    }
  115|       |}
  116|       |
  117|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  118|       |internal extension InspectableView where View: SingleViewContent {
  119|     21|    func child() throws -> Content {
  120|     21|        return try View.child(content)
  121|     21|    }
  122|       |}
  123|       |
  124|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  125|       |internal extension InspectableView where View: MultipleViewContent {
  126|       |    
  127|      9|    func child(at index: Int, isTupleExtraction: Bool = false) throws -> Content {
  128|      9|        let viewes = try View.children(content)
  129|      9|        guard index >= 0 && index < viewes.count else {
  130|      0|            throw InspectionError.viewIndexOutOfBounds(index: index, count: viewes.count)
  131|      9|        }
  132|      9|        let child = try viewes.element(at: index)
  133|      9|        if !isTupleExtraction && Inspector.isTupleView(child.view) {
  134|      0|            // swiftlint:disable line_length
  135|      0|            throw InspectionError.notSupported(
  136|      0|                "Please insert .tupleView(\(index)) after \(Inspector.typeName(type: View.self)) for inspecting its children at index \(index)")
  137|      0|            // swiftlint:enable line_length
  138|      9|        }
  139|      9|        return child
  140|      9|    }
  141|       |}
  142|       |
  143|       |// MARK: - Inspection of a Custom View
  144|       |
  145|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  146|       |public extension View {
  147|      1|    func inspect(function: String = #function) throws -> InspectableView<ViewType.ClassifiedView> {
  148|      1|        let medium = ViewHosting.medium(function: function)
  149|      1|        let content = try Inspector.unwrap(view: self, medium: medium)
  150|      1|        return try .init(content, parent: nil, call: "")
  151|      1|    }
  152|       |    
  153|       |    func inspect(function: String = #function, file: StaticString = #file, line: UInt = #line,
  154|      0|                 inspection: (InspectableView<ViewType.ClassifiedView>) throws -> Void) {
  155|      0|        do {
  156|      0|            try inspection(try inspect(function: function))
  157|      0|        } catch {
  158|      0|            XCTFail("\(error.localizedDescription)", file: file, line: line)
  159|      0|        }
  160|      0|    }
  161|       |}
  162|       |
  163|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  164|       |public extension View where Self: Inspectable {
  165|       |    
  166|     28|    func inspect(function: String = #function) throws -> InspectableView<ViewType.View<Self>> {
  167|     28|        let call = "view(\(ViewType.View<Self>.typePrefix).self)"
  168|     28|        let medium = ViewHosting.medium(function: function)
  169|     28|        let content = Content(self, medium: medium)
  170|     28|        return try .init(content, parent: nil, call: call)
  171|     28|    }
  172|       |    
  173|       |    func inspect(function: String = #function, file: StaticString = #file, line: UInt = #line,
  174|      0|                 inspection: (InspectableView<ViewType.View<Self>>) throws -> Void) {
  175|      0|        do {
  176|      0|            try inspection(try inspect(function: function))
  177|      0|        } catch {
  178|      0|            XCTFail("\(error.localizedDescription)", file: file, line: line)
  179|      0|        }
  180|      0|    }
  181|       |}
  182|       |
  183|       |// MARK: - Modifiers
  184|       |
  185|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  186|       |public extension ViewModifier where Self: Inspectable {
  187|      2|    func inspect(function: String = #function) throws -> InspectableView<ViewType.ViewModifier<Self>> {
  188|      2|        let medium = ViewHosting.medium(function: function)
  189|      2|        let content = try Inspector.unwrap(view: self, medium: medium)
  190|      2|        return try .init(content, parent: nil, call: "")
  191|      2|    }
  192|       |    
  193|       |    func inspect(function: String = #function, file: StaticString = #file, line: UInt = #line,
  194|      0|                 inspection: (InspectableView<ViewType.ViewModifier<Self>>) throws -> Void) {
  195|      0|        do {
  196|      0|            try inspection(try inspect(function: function))
  197|      0|        } catch {
  198|      0|            XCTFail("\(error.localizedDescription)", file: file, line: line)
  199|      0|        }
  200|      0|    }
  201|       |}
  202|       |
  203|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  204|       |internal extension InspectableView {
  205|       |
  206|       |    func modifierAttribute<Type>(
  207|       |        modifierName: String, transitive: Bool = false,
  208|       |        path: String, type: Type.Type, call: String, index: Int = 0
  209|      6|    ) throws -> Type {
  210|      6|        return try contentForModifierLookup.modifierAttribute(
  211|      6|            modifierName: modifierName, transitive: transitive,
  212|      6|            path: path, type: type, call: call, index: index)
  213|      6|    }
  214|       |    
  215|       |    func modifierAttribute<Type>(
  216|       |        modifierLookup: (ModifierNameProvider) -> Bool, transitive: Bool = false,
  217|       |        path: String, type: Type.Type, call: String
  218|      1|    ) throws -> Type {
  219|      1|        return try contentForModifierLookup.modifierAttribute(
  220|      1|            modifierLookup: modifierLookup, transitive: transitive, path: path, type: type, call: call)
  221|      1|    }
  222|       |    
  223|       |    func modifier(
  224|       |        _ modifierLookup: (ModifierNameProvider) -> Bool,
  225|       |        transitive: Bool = false, call: String
  226|      0|    ) throws -> Any {
  227|      0|        return try contentForModifierLookup.modifier(
  228|      0|            modifierLookup, transitive: transitive, call: call)
  229|      0|    }
  230|       |    
  231|       |    func modifiersMatching(_ modifierLookup: (ModifierNameProvider) -> Bool,
  232|       |                           transitive: Bool = false
  233|      2|    ) -> [ModifierNameProvider] {
  234|      2|        return contentForModifierLookup
  235|      2|            .modifiersMatching(modifierLookup, transitive: transitive)
  236|      2|    }
  237|       |    
  238|      9|    var contentForModifierLookup: Content {
  239|      9|        if self is InspectableView<ViewType.ParentView>, let parent = parentView {
  240|      0|            return parent.content
  241|      9|        }
  242|      9|        return content
  243|      9|    }
  244|       |}
  245|       |
  246|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  247|       |internal extension Content {
  248|       |    typealias ModifierLookupClosure = (ModifierNameProvider) -> Bool
  249|       |
  250|       |    func modifierAttribute<Type>(
  251|       |        modifierName: String, transitive: Bool = false,
  252|       |        path: String, type: Type.Type, call: String, index: Int = 0
  253|      6|    ) throws -> Type {
  254|      6|        let modifyNameProvider: ModifierLookupClosure = { modifier -> Bool in
  255|      5|            guard modifier.modifierType.contains(modifierName) else { return false }
  256|      5|            return (try? Inspector.attribute(path: path, value: modifier) as? Type) != nil
  257|      6|        }
  258|      6|        return try modifierAttribute(
  259|      6|            modifierLookup: modifyNameProvider, transitive: transitive,
  260|      6|            path: path, type: type, call: call, index: index)
  261|      6|    }
  262|       |    
  263|       |    func modifierAttribute<Type>(
  264|       |        modifierLookup: ModifierLookupClosure, transitive: Bool = false,
  265|       |        path: String, type: Type.Type, call: String, index: Int = 0
  266|    301|    ) throws -> Type {
  267|    301|        let modifier = try self.modifier(modifierLookup, transitive: transitive, call: call, index: index)
  268|    301|        guard let attribute = try? Inspector.attribute(path: path, value: modifier) as? Type
  269|      0|        else {
  270|      0|            throw InspectionError.modifierNotFound(
  271|      0|                parent: Inspector.typeName(value: self.view), modifier: call, index: index)
  272|    301|        }
  273|    301|        return attribute
  274|    301|    }
  275|       |
  276|       |    func modifier(_ modifierLookup: ModifierLookupClosure, transitive: Bool = false,
  277|    595|                  call: String, index: Int = 0) throws -> Any {
  278|    595|        let modifiers = modifiersMatching(modifierLookup, transitive: transitive)
  279|    595|        if index < modifiers.count {
  280|     11|            return modifiers[index]
  281|    584|        }
  282|    584|        throw InspectionError.modifierNotFound(
  283|    584|            parent: Inspector.typeName(value: self.view), modifier: call, index: index)
  284|    595|    }
  285|       |    
  286|       |    func modifiersMatching(_ modifierLookup: ModifierLookupClosure,
  287|    721|                           transitive: Bool = false) -> [ModifierNameProvider] {
  288|      4|        let modifiers = transitive ? medium.transitiveViewModifiers
  289|    717|            : medium.viewModifiers.reversed()
  290|    721|        return modifiers.lazy
  291|  1.39k|            .compactMap { $0 as? ModifierNameProvider }
  292|    721|            .filter(modifierLookup)
  293|    721|    }
  294|       |}
  295|       |
  296|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  297|       |internal protocol ModifierNameProvider {
  298|       |    var modifierType: String { get }
  299|       |    func modifierType(prefixOnly: Bool) -> String
  300|       |    var customModifier: Inspectable? { get }
  301|       |}
  302|       |
  303|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  304|       |extension ModifierNameProvider {
  305|  1.64k|    var modifierType: String { modifierType(prefixOnly: false) }
  306|       |}
  307|       |
  308|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  309|       |extension ModifiedContent: ModifierNameProvider {
  310|       |    
  311|  1.66k|    func modifierType(prefixOnly: Bool) -> String {
  312|  1.66k|        return Inspector.typeName(type: Modifier.self, prefixOnly: prefixOnly)
  313|  1.66k|    }
  314|       |    
  315|    255|    var customModifier: Inspectable? {
  316|    255|        return try? Inspector.attribute(label: "modifier", value: self, type: Inspectable.self)
  317|    255|    }
  318|       |}
  319|       |
  320|       |// MARK: - isResponsive check for controls
  321|       |
  322|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  323|       |public extension InspectableView {
  324|       |    
  325|       |    /**
  326|       |     A function to check if the view is responsive to the user's touch input.
  327|       |     Returns `false` if the view or any of its parent views are `disabled`,
  328|       |     `hidden`, or if `allowsHitTesting` is set to `false`.
  329|       |
  330|       |      - Returns: `true` if the view is responsive to the user's interaction
  331|       |     */
  332|      0|    func isResponsive() -> Bool {
  333|      0|        do {
  334|      0|            try guardIsResponsive()
  335|      0|            return true
  336|      0|        } catch {
  337|      0|            return false
  338|      0|        }
  339|      0|    }
  340|       |    
  341|      1|    internal func guardIsResponsive() throws {
  342|      1|        let name = Inspector.typeName(value: content.view, prefixOnly: true)
  343|      1|        if isDisabled() {
  344|      0|            let blocker = farthestParent(where: { $0.isDisabled() }) ?? self
  345|      0|            throw InspectionError.unresponsiveControl(
  346|      0|                name: name, reason: blocker.pathToRoot.ifEmpty(use: "it") + " is disabled")
  347|      1|        }
  348|      1|        if isHidden() {
  349|      0|            let blocker = farthestParent(where: { $0.isHidden() }) ?? self
  350|      0|            throw InspectionError.unresponsiveControl(
  351|      0|                name: name, reason: blocker.pathToRoot.ifEmpty(use: "it") + " is hidden")
  352|      1|        }
  353|      1|        if !allowsHitTesting() {
  354|      0|            let blocker = farthestParent(where: { !$0.allowsHitTesting() }) ?? self
  355|      0|            throw InspectionError.unresponsiveControl(
  356|      0|                name: name, reason: blocker.pathToRoot.ifEmpty(use: "it") + " has allowsHitTesting set to false")
  357|      1|        }
  358|      1|    }
  359|       |    
  360|      0|    private func farthestParent(where condition: (InspectableView<ViewType.ClassifiedView>) -> Bool) -> UnwrappedView? {
  361|      0|        if let parent = try? self.parentView?.asInspectableView(),
  362|      0|           condition(parent) {
  363|      0|            return parent.farthestParent(where: condition) ?? parent
  364|      0|        }
  365|      0|        return nil
  366|      0|    }
  367|       |}
  368|       |
  369|       |private extension String {
  370|      0|    func ifEmpty(use replacement: String) -> String {
  371|      0|        return isEmpty ? replacement : self
  372|      0|    }
  373|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/InspectionEmissary.swift:
    1|       |import SwiftUI
    2|       |import Combine
    3|       |import XCTest
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public protocol InspectionEmissary: AnyObject {
    7|       |    
    8|       |    associatedtype V
    9|       |    var notice: PassthroughSubject<UInt, Never> { get }
   10|       |    var callbacks: [UInt: (V) -> Void] { get set }
   11|       |}
   12|       |
   13|       |// MARK: - InspectionEmissary for View
   14|       |
   15|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   16|       |public extension InspectionEmissary where V: View & Inspectable {
   17|       |    
   18|       |    typealias ViewInspection = (InspectableView<ViewType.View<V>>) throws -> Void
   19|       |    
   20|       |    @discardableResult
   21|       |    func inspect(after delay: TimeInterval = 0,
   22|       |                 function: String = #function, file: StaticString = #file, line: UInt = #line,
   23|       |                 _ inspection: @escaping ViewInspection
   24|     25|    ) -> XCTestExpectation {
   25|     25|        return inspect(after: delay, function: function, file: file, line: line) { view in
   26|     25|            return try inspection(try view.inspect(function: function))
   27|     25|        }
   28|     25|    }
   29|       |    
   30|       |    @discardableResult
   31|       |    func inspect<P>(onReceive publisher: P,
   32|       |                    function: String = #function, file: StaticString = #file, line: UInt = #line,
   33|       |                    _ inspection: @escaping ViewInspection
   34|      0|    ) -> XCTestExpectation where P: Publisher, P.Failure == Never {
   35|      0|        return inspect(onReceive: publisher, function: function, file: file, line: line) { view in
   36|      0|            return try inspection(try view.inspect(function: function))
   37|      0|        }
   38|      0|    }
   39|       |}
   40|       |
   41|       |// MARK: - InspectionEmissary for ViewModifier
   42|       |
   43|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   44|       |public extension InspectionEmissary where V: ViewModifier & Inspectable {
   45|       |    
   46|       |    typealias ViewModifierInspection = (InspectableView<ViewType.ViewModifier<V>>) throws -> Void
   47|       |    
   48|       |    @discardableResult
   49|       |    func inspect(after delay: TimeInterval = 0,
   50|       |                 function: String = #function, file: StaticString = #file, line: UInt = #line,
   51|       |                 _ inspection: @escaping ViewModifierInspection
   52|      2|    ) -> XCTestExpectation {
   53|      2|        return inspect(after: delay, function: function, file: file, line: line) { view in
   54|      2|            return try inspection(try view.inspect(function: function))
   55|      2|        }
   56|      2|    }
   57|       |    
   58|       |    @discardableResult
   59|       |    func inspect<P>(onReceive publisher: P,
   60|       |                    function: String = #function, file: StaticString = #file, line: UInt = #line,
   61|       |                    _ inspection: @escaping ViewModifierInspection
   62|      0|    ) -> XCTestExpectation where P: Publisher, P.Failure == Never {
   63|      0|        return inspect(onReceive: publisher, function: function, file: file, line: line) { view in
   64|      0|            return try inspection(try view.inspect(function: function))
   65|      0|        }
   66|      0|    }
   67|       |}
   68|       |
   69|       |// MARK: - Private
   70|       |
   71|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   72|       |private extension InspectionEmissary {
   73|       |    
   74|       |    typealias SubjectInspection = (_ subject: V) throws -> Void
   75|       |    
   76|       |    func inspect(after delay: TimeInterval,
   77|       |                 function: String, file: StaticString, line: UInt,
   78|       |                 inspection: @escaping SubjectInspection
   79|     27|    ) -> XCTestExpectation {
   80|     27|        let exp = XCTestExpectation(description: "Inspection at line \(line)")
   81|     27|        setup(inspection: inspection, expectation: exp, function: function, file: file, line: line)
   82|     27|        DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak notice] in
   83|     27|            notice?.send(line)
   84|     27|        }
   85|     27|        return exp
   86|     27|    }
   87|       |    
   88|       |    func inspect<P>(onReceive publisher: P,
   89|       |                    function: String, file: StaticString, line: UInt,
   90|       |                    inspection: @escaping SubjectInspection
   91|      0|    ) -> XCTestExpectation where P: Publisher, P.Failure == Never {
   92|      0|        let exp = XCTestExpectation(description: "Inspection at line \(line)")
   93|      0|        setup(inspection: inspection, expectation: exp, function: function, file: file, line: line)
   94|      0|        var subscription: AnyCancellable?
   95|      0|        _ = subscription
   96|      0|        subscription = publisher.sink { [weak notice] _ in
   97|      0|            subscription = nil
   98|      0|            DispatchQueue.main.async {
   99|      0|                notice?.send(line)
  100|      0|            }
  101|      0|        }
  102|      0|        return exp
  103|      0|    }
  104|       |    
  105|       |    func setup(inspection: @escaping SubjectInspection,
  106|       |               expectation: XCTestExpectation,
  107|     27|               function: String, file: StaticString, line: UInt) {
  108|     27|        callbacks[line] = { [weak self] view in
  109|     27|            do {
  110|     27|                try inspection(view)
  111|      8|            } catch let error {
  112|      8|                XCTFail("\(error.localizedDescription)", file: file, line: line)
  113|     27|            }
  114|     27|            if self?.callbacks.count == 0 {
  115|     26|                ViewHosting.expel(function: function)
  116|     27|            }
  117|     27|            expectation.fulfill()
  118|     27|        }
  119|     27|    }
  120|       |}
  121|       |
  122|       |// MARK: - on keyPath inspection
  123|       |
  124|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  125|       |public extension View where Self: Inspectable {
  126|       |    @discardableResult
  127|       |    mutating func on(_ keyPath: WritableKeyPath<Self, ((Self) -> Void)?>,
  128|       |                     function: String = #function, file: StaticString = #file, line: UInt = #line,
  129|       |                     perform: @escaping ((InspectableView<ViewType.View<Self>>) throws -> Void)
  130|      0|    ) -> XCTestExpectation {
  131|      0|        return on(keyPath, function: function, file: file, line: line) { body in
  132|      0|            body.inspect(function: function, file: file, line: line, inspection: perform)
  133|      0|        }
  134|      0|    }
  135|       |}
  136|       |
  137|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  138|       |public extension ViewModifier where Self: Inspectable {
  139|       |    @discardableResult
  140|       |    mutating func on(_ keyPath: WritableKeyPath<Self, ((Self) -> Void)?>,
  141|       |                     function: String = #function, file: StaticString = #file, line: UInt = #line,
  142|       |                     perform: @escaping ((InspectableView<ViewType.ViewModifier<Self>>) throws -> Void)
  143|      0|    ) -> XCTestExpectation {
  144|      0|        return on(keyPath, function: function, file: file, line: line) { body in
  145|      0|            body.inspect(function: function, file: file, line: line, inspection: perform)
  146|      0|        }
  147|      0|    }
  148|       |}
  149|       |
  150|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  151|       |private extension Inspectable {
  152|       |    mutating func on(_ keyPath: WritableKeyPath<Self, ((Self) -> Void)?>,
  153|       |                     function: String, file: StaticString, line: UInt,
  154|       |                     inspect: @escaping ((Self) -> Void)
  155|      0|    ) -> XCTestExpectation {
  156|      0|        let description = Inspector.typeName(value: self) + " callback at line #\(line)"
  157|      0|        let expectation = XCTestExpectation(description: description)
  158|      0|        self[keyPath: keyPath] = { body in
  159|      0|            inspect(body)
  160|      0|            ViewHosting.expel(function: function)
  161|      0|            expectation.fulfill()
  162|      0|        }
  163|      0|        return expectation
  164|      0|    }
  165|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Inspector.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal struct Inspector { }
    5|       |
    6|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    7|       |extension Inspector {
    8|       |    
    9|  1.35k|    static func attribute(label: String, value: Any) throws -> Any {
   10|  1.35k|        if label == "super", let superclass = Mirror(reflecting: value).superclassMirror {
   11|      0|            return superclass
   12|  1.35k|        }
   13|  1.35k|        return try attribute(label: label, value: value, type: Any.self)
   14|  1.35k|    }
   15|       |    
   16|  2.83k|    static func attribute<T>(label: String, value: Any, type: T.Type) throws -> T {
   17|  2.83k|        let mirror = (value as? Mirror) ?? Mirror(reflecting: value)
   18|     47|        guard let child = mirror.descendant(label) else {
   19|     47|            throw InspectionError.attributeNotFound(
   20|     47|                label: label, type: typeName(value: value))
   21|  2.79k|        }
   22|  2.79k|        return try cast(value: child, type: T.self)
   23|  2.83k|    }
   24|       |    
   25|     75|    static func attribute(path: String, value: Any) throws -> Any {
   26|     75|        return try attribute(path: path, value: value, type: Any.self)
   27|     75|    }
   28|       |    
   29|    341|    static func attribute<T>(path: String, value: Any, type: T.Type) throws -> T {
   30|    341|        let labels = path.components(separatedBy: "|")
   31|    668|        let child = try labels.reduce(value, { (value, label) -> Any in
   32|    668|            try attribute(label: label, value: value)
   33|    668|        })
   34|    341|        return try cast(value: child, type: T.self)
   35|    341|    }
   36|       |    
   37|  3.27k|    static func cast<T>(value: Any, type: T.Type) throws -> T {
   38|  1.31k|        guard let casted = value as? T else {
   39|  1.31k|            throw InspectionError.typeMismatch(value, T.self)
   40|  1.96k|        }
   41|  1.96k|        return casted
   42|  3.27k|    }
   43|       |    
   44|       |    static func typeName(value: Any,
   45|       |                         namespaced: Bool = false,
   46|  4.33k|                         prefixOnly: Bool = false) -> String {
   47|  4.33k|        return typeName(type: type(of: value), namespaced: namespaced, prefixOnly: prefixOnly)
   48|  4.33k|    }
   49|       |    
   50|       |    static func typeName(type: Any.Type,
   51|       |                         namespaced: Bool = false,
   52|  8.68k|                         prefixOnly: Bool = false) -> String {
   53|  7.27k|        let typeName = namespaced ? String(reflecting: type) : String(describing: type)
   54|  6.11k|        guard prefixOnly else { return typeName }
   55|  2.57k|        return typeName.components(separatedBy: "<").first!
   56|  8.68k|    }
   57|       |}
   58|       |
   59|       |// MARK: - Attributes lookup
   60|       |
   61|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   62|       |extension Inspector {
   63|       |    
   64|       |    /**
   65|       |        Use this function to lookup the struct content:
   66|       |        ```
   67|       |        (lldb) po Inspector.print(view) as AnyObject
   68|       |        ```
   69|       |     */
   70|      0|    public static func print(_ value: Any) -> String {
   71|      0|        let tree = attributesTree(value: value, medium: .empty)
   72|      0|        return typeName(value: value) + print(tree, level: 1)
   73|      0|    }
   74|       |    
   75|      0|    fileprivate static func print(_ value: Any, level: Int) -> String {
   76|      0|        let prefix = Inspector.newline(value: value)
   77|      0|        if let array = value as? [Any] {
   78|      0|            return prefix + array.description(level: level)
   79|      0|        } else if let dict = value as? [String: Any] {
   80|      0|            return prefix + dict.description(level: level)
   81|      0|        }
   82|      0|        return prefix + String(describing: value) + "\n"
   83|      0|    }
   84|       |    
   85|      0|    fileprivate static func indent(level: Int) -> String {
   86|      0|        return Array(repeating: "  ", count: level).joined()
   87|      0|    }
   88|       |    
   89|      0|    private static func newline(value: Any) -> String {
   90|      0|        let needsNewLine: Bool = {
   91|      0|            if let array = value as? [Any] {
   92|      0|                return array.count > 0
   93|      0|            }
   94|      0|            return value is [String: Any]
   95|      0|        }()
   96|      0|        return needsNewLine ? "\n" : ""
   97|      0|    }
   98|       |    
   99|      0|    private static func attributesTree(value: Any, medium: Content.Medium) -> Any {
  100|      0|        if let array = value as? [Any] {
  101|      0|            return array.map { attributesTree(value: $0, medium: medium) }
  102|      0|        }
  103|      0|        let medium = (try? unwrap(content: Content(value, medium: medium)).medium) ?? medium
  104|      0|        let mirror = Mirror(reflecting: value)
  105|      0|        var dict: [String: Any] = [:]
  106|      0|        mirror.children.enumerated().forEach { child in
  107|      0|            let childName = child.element.label ?? "[\(child.offset)]"
  108|      0|            let childType = typeName(value: child.element.value)
  109|      0|            dict[childName + ": " + childType] = attributesTree(value: child.element.value, medium: medium)
  110|      0|        }
  111|      0|        if let inspectable = value as? Inspectable,
  112|      0|           let content = try? inspectable.extractContent(environmentObjects: medium.environmentObjects) {
  113|      0|            let childType = typeName(value: content)
  114|      0|            dict["body: " + childType] = attributesTree(value: content, medium: medium)
  115|      0|        }
  116|      0|        if dict.count == 0 {
  117|      0|            return " = " + String(describing: value)
  118|      0|        }
  119|      0|        return dict
  120|      0|    }
  121|       |}
  122|       |
  123|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  124|       |fileprivate extension Dictionary where Key == String {
  125|      0|    func description(level: Int) -> String {
  126|      0|        let indent = Inspector.indent(level: level)
  127|      0|        return sorted(by: { $0.key < $1.key }).reduce("") { (str, pair) -> String in
  128|      0|            return str + indent + pair.key + Inspector.print(pair.value, level: level + 1)
  129|      0|        }
  130|      0|    }
  131|       |}
  132|       |
  133|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  134|       |fileprivate extension Array {
  135|      0|    func description(level: Int) -> String {
  136|      0|        guard count > 0 else {
  137|      0|            return " = []\n"
  138|      0|        }
  139|      0|        let indent = Inspector.indent(level: level)
  140|      0|        return enumerated().reduce("") { (str, pair) -> String in
  141|      0|            return str + indent + "[\(pair.offset)]" + Inspector.print(pair.element, level: level + 1)
  142|      0|        }
  143|      0|    }
  144|       |}
  145|       |// MARK: - View Inspection
  146|       |
  147|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  148|       |extension Inspector {
  149|       |    
  150|     85|    static func viewsInContainer(view: Any, medium: Content.Medium) throws -> LazyGroup<Content> {
  151|     85|        let unwrappedContainer = try Inspector.unwrap(content: Content(view, medium: medium.resettingViewModifiers()))
  152|     62|        guard Inspector.isTupleView(unwrappedContainer.view) else {
  153|     46|            return LazyGroup(count: 1) { _ in unwrappedContainer }
  154|     23|        }
  155|     23|        return try ViewType.TupleView.children(unwrappedContainer)
  156|     85|    }
  157|       |    
  158|    468|    static func isTupleView(_ view: Any) -> Bool {
  159|    468|        return Inspector.typeName(value: view, prefixOnly: true) == ViewType.TupleView.typePrefix
  160|    468|    }
  161|       |    
  162|    692|    static func unwrap(view: Any, medium: Content.Medium) throws -> Content {
  163|    692|        return try unwrap(content: Content(view, medium: medium))
  164|    692|    }
  165|       |    
  166|    823|    static func unwrap(content: Content) throws -> Content {
  167|    823|        switch Inspector.typeName(value: content.view, prefixOnly: true) {
  168|      0|        case "Tree":
  169|      0|            return try ViewType.TreeView.child(content)
  170|      0|        case "IDView":
  171|      0|            return try ViewType.IDView.child(content)
  172|     13|        case "Optional":
  173|     13|            return try ViewType.OptionalContent.child(content)
  174|      0|        case "EquatableView":
  175|      0|            return try ViewType.EquatableView.child(content)
  176|    278|        case "ModifiedContent":
  177|    278|            return try ViewType.ViewModifier<ViewType.Stub>.child(content)
  178|    237|        case "SubscriptionView":
  179|    237|            return try ViewType.SubscriptionView.child(content)
  180|      0|        case "_ConditionalContent":
  181|      0|            return try ViewType.ConditionalContent.child(content)
  182|      0|        case "EnvironmentReaderView":
  183|      0|            return try ViewType.EnvironmentReaderView.child(content)
  184|      0|        case "_DelayedPreferenceView":
  185|      0|            return try ViewType.DelayedPreferenceView.child(content)
  186|    295|        default:
  187|    295|            return content
  188|    823|        }
  189|    823|    }
  190|       |    
  191|    786|    static func guardType(value: Any, namespacedPrefixes: [String], inspectionCall: String) throws {
  192|    786|        guard let firstPrefix = namespacedPrefixes.first
  193|    411|        else { return }
  194|    375|        let typeWithParams = typeName(type: type(of: value))
  195|    375|        let typePrefix = typeName(type: type(of: value), namespaced: true, prefixOnly: true)
  196|    375|        if typePrefix == "SwiftUI.EnvironmentReaderView" {
  197|      0|            if typeWithParams.contains("NavigationBarItemsKey") {
  198|      0|                throw InspectionError.notSupported(
  199|      0|                    """
  200|      0|                    Please insert '.navigationBarItems()' before \(inspectionCall) \
  201|      0|                    for unwrapping the underlying view hierarchy.
  202|      0|                    """)
  203|      0|            } else if typeWithParams.contains("_AnchorWritingModifier") {
  204|      0|                throw InspectionError.notSupported(
  205|      0|                    "Unwrapping the view under popover is not supported on iOS 14.0 and 14.1")
  206|      0|            }
  207|    375|        }
  208|    124|        guard namespacedPrefixes.contains(typePrefix) else {
  209|    124|            throw InspectionError.typeMismatch(factual: typePrefix, expected: firstPrefix)
  210|    251|        }
  211|    251|    }
  212|       |}
  213|       |
  214|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  215|       |extension InspectionError {
  216|  1.31k|    static func typeMismatch<V, T>(_ value: V, _ expectedType: T.Type) -> InspectionError {
  217|  1.31k|        return .typeMismatch(
  218|  1.31k|            factual: Inspector.typeName(value: value),
  219|  1.31k|            expected: Inspector.typeName(type: expectedType))
  220|  1.31k|    }
  221|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/LazyGroup.swift:
    1|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    2|       |public struct LazyGroup<T> {
    3|       |    
    4|       |    private let access: (Int) throws -> T
    5|       |    public let count: Int
    6|       |    
    7|  1.62k|    init(count: Int, _ access: @escaping (Int) throws -> T) {
    8|  1.62k|        self.count = count
    9|  1.62k|        self.access = access
   10|  1.62k|    }
   11|       |    
   12|  1.65k|    func element(at index: Int) throws -> T {
   13|      0|        guard 0 ..< count ~= index else {
   14|      0|            throw InspectionError.viewIndexOutOfBounds(index: index, count: count)
   15|  1.65k|        }
   16|  1.65k|        return try access(index)
   17|  1.65k|    }
   18|       |    
   19|    139|    static var empty: Self {
   20|      0|        return .init(count: 0) { _ in fatalError() }
   21|    139|    }
   22|       |    
   23|    496|    static func + (lhs: LazyGroup, rhs: LazyGroup) -> LazyGroup {
   24|  1.09k|        return .init(count: lhs.count + rhs.count) { index -> T in
   25|  1.09k|            if index < lhs.count {
   26|    588|                return try lhs.element(at: index)
   27|    509|            }
   28|    509|            return try rhs.element(at: index - lhs.count)
   29|  1.09k|        }
   30|    496|    }
   31|       |}
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension LazyGroup: Sequence {
   35|       |    
   36|       |    public struct Iterator: IteratorProtocol {
   37|       |        public typealias Element = T
   38|       |        internal var index = -1
   39|       |        private var group: LazyGroup<Element>
   40|       |        
   41|      0|        init(group: LazyGroup<Element>) {
   42|      0|            self.group = group
   43|      0|        }
   44|       |        
   45|      0|        mutating public func next() -> Element? {
   46|      0|            index += 1
   47|      0|            do {
   48|      0|                return try group.element(at: index)
   49|      0|            } catch _ {
   50|      0|                return nil
   51|      0|            }
   52|      0|        }
   53|       |    }
   54|       |
   55|      0|    public func makeIterator() -> Iterator {
   56|      0|        .init(group: self)
   57|      0|    }
   58|       |
   59|      0|    public var underestimatedCount: Int { count }
   60|       |}
   61|       |
   62|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   63|       |extension LazyGroup: RandomAccessCollection {
   64|       |    
   65|      0|    public var startIndex: Int { 0 }
   66|      0|    public var endIndex: Int { count }
   67|       |    
   68|      0|    public subscript(position: Int) -> T {
   69|      0|        // swiftlint:disable force_try
   70|      0|        return try! element(at: position)
   71|      0|        // swiftlint:enable force_try
   72|      0|    }
   73|       |    
   74|      0|    public func index(after index: Int) -> Int { index + 1 }
   75|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/AccessibilityModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Accessibility
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |    
    8|      0|    func accessibilityLabel() throws -> InspectableView<ViewType.Text> {
    9|      0|        let text = try accessibilityElement(
   10|      0|            "LabelKey", type: Text.self, call: "accessibilityLabel")
   11|      0|        let medium = content.medium.resettingViewModifiers()
   12|      0|        return try .init(try Inspector.unwrap(content: Content(text, medium: medium)), parent: self)
   13|      0|    }
   14|       |    
   15|      0|    func accessibilityValue() throws -> InspectableView<ViewType.Text> {
   16|      0|        let text = try accessibilityElement(
   17|      0|            "TypedValueKey", path: "value|some|description|some",
   18|      0|            type: Text.self, call: "accessibilityValue")
   19|      0|        let medium = content.medium.resettingViewModifiers()
   20|      0|        return try .init(try Inspector.unwrap(content: Content(text, medium: medium)), parent: self)
   21|      0|    }
   22|       |    
   23|      0|    func accessibilityHint() throws -> InspectableView<ViewType.Text> {
   24|      0|        let text = try accessibilityElement(
   25|      0|            "HintKey", type: Text.self, call: "accessibilityHint")
   26|      0|        let medium = content.medium.resettingViewModifiers()
   27|      0|        return try .init(try Inspector.unwrap(content: Content(text, medium: medium)), parent: self)
   28|      0|    }
   29|       |    
   30|      0|    func accessibilityHidden() throws -> Bool {
   31|      0|        let visibility = try accessibilityElement(
   32|      0|            "VisibilityKey", path: "value", type: (Any?).self, call: "accessibility(hidden:)")
   33|      0|        switch visibility {
   34|      0|        case let .some(value):
   35|      0|            return String(describing: value) == "hidden"
   36|      0|        case .none:
   37|      0|            return false
   38|      0|        }
   39|      0|    }
   40|       |    
   41|      0|    func accessibilityIdentifier() throws -> String {
   42|      0|        return try accessibilityElement(
   43|      0|            "IdentifierKey", type: String.self, call: "accessibility(identifier:)")
   44|      0|    }
   45|       |    
   46|      0|    func accessibilitySelectionIdentifier() throws -> AnyHashable {
   47|      0|        return try accessibilityElement(
   48|      0|            "SelectionIdentifierKey", type: AnyHashable.self,
   49|      0|            call: "accessibility(selectionIdentifier:)")
   50|      0|    }
   51|       |    
   52|      0|    func accessibilityActivationPoint() throws -> UnitPoint {
   53|      0|        return try accessibilityElement(
   54|      0|            "ActivationPointKey", path: "value|some|unitPoint",
   55|      0|            type: UnitPoint.self, call: "accessibility(activationPoint:)")
   56|      0|    }
   57|       |    
   58|      0|    func callAccessibilityAction(_ kind: AccessibilityActionKind) throws {
   59|      0|        let kindString = String(describing: kind)
   60|      0|        let shortName = kindString
   61|      0|            .components(separatedBy: CharacterSet(charactersIn: ".)"))
   62|      0|            .filter { $0.count > 0 }.last!
   63|      0|        let call = "accessibilityAction(.\(shortName))"
   64|      0|        typealias Callback = (()) -> Void
   65|      0|        let callback = try accessibilityAction(name: kindString, path: "box|action|kind",
   66|      0|                                               type: Callback.self, call: call)
   67|      0|        callback(())
   68|      0|    }
   69|       |    
   70|      0|    func callAccessibilityAdjustableAction(_ direction: AccessibilityAdjustmentDirection = .increment) throws {
   71|      0|        typealias Callback = (AccessibilityAdjustmentDirection) -> Void
   72|      0|        let callback = try accessibilityAction(
   73|      0|            name: "AccessibilityAdjustableAction()", path: "box|action",
   74|      0|            type: Callback.self, call: "accessibilityAdjustableAction")
   75|      0|        callback(direction)
   76|      0|    }
   77|       |    
   78|      0|    func callAccessibilityScrollAction(_ edge: Edge) throws {
   79|      0|        typealias Callback = (Edge) -> Void
   80|      0|        let callback = try accessibilityAction(
   81|      0|            name: "AccessibilityScrollAction()", path: "box|action",
   82|      0|            type: Callback.self, call: "accessibilityScrollAction")
   83|      0|        callback(edge)
   84|      0|    }
   85|       |    
   86|      0|    func accessibilitySortPriority() throws -> Double {
   87|      0|        return try accessibilityElement(
   88|      0|            "SortPriorityKey", type: Double.self, call: "accessibility(sortPriority:)")
   89|      0|    }
   90|       |}
   91|       |
   92|       |// MARK: - Private
   93|       |
   94|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   95|       |private extension InspectableView {
   96|       |    
   97|       |    func accessibilityElement<T>(_ name: String, path: String = "value|some",
   98|      0|                                 type: T.Type, call: String) throws -> T {
   99|      0|        let item = try modifierAttribute(
  100|      0|            modifierName: "AccessibilityAttachmentModifier",
  101|      0|            path: "modifier|attachment|some|properties|plist|elements|some",
  102|      0|            type: Any.self, call: call)
  103|      0|        guard let attribute = lookupAttributeWithName(name, item: item),
  104|      0|            let value = try? Inspector.attribute(path: path, value: attribute) as? T else {
  105|      0|            throw InspectionError.modifierNotFound(parent:
  106|      0|                Inspector.typeName(value: content.view), modifier: call, index: 0)
  107|      0|        }
  108|      0|        return value
  109|      0|    }
  110|       |    
  111|      0|    func lookupAttributeWithName(_ name: String, item: Any) -> Any? {
  112|      0|        if Inspector.typeName(value: item).contains(name) {
  113|      0|            return item
  114|      0|        }
  115|      0|        if let nextItem = try? Inspector.attribute(path: "super|after|some", value: item) {
  116|      0|            return lookupAttributeWithName(name, item: nextItem)
  117|      0|        }
  118|      0|        return nil
  119|      0|    }
  120|       |    
  121|      0|    func accessibilityAction<T>(name: String, path: String, type: T.Type, call: String) throws -> T {
  122|      0|        let actionHandlers = try accessibilityElement(
  123|      0|            "ActionsKey", path: "value",
  124|      0|            type: [Any].self, call: call)
  125|      0|        guard let handler = actionHandlers.first(where: { handler -> Bool in
  126|      0|            guard let actionName = try? Inspector.attribute(path: path, value: handler)
  127|      0|                else { return false }
  128|      0|            return name == String(describing: actionName)
  129|      0|        }), let callback = try? Inspector.attribute(path: "box|handler", value: handler) as? T
  130|      0|        else {
  131|      0|            throw InspectionError.modifierNotFound(parent:
  132|      0|                Inspector.typeName(value: content.view), modifier: call, index: 0)
  133|      0|        }
  134|      0|        return callback
  135|      0|    }
  136|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/AnimationModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Animation
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |    
    8|      0|    func callTransaction() throws {
    9|      0|        let callback = try modifierAttribute(
   10|      0|            modifierName: "_TransactionModifier",
   11|      0|            path: "modifier|transform",
   12|      0|            type: ((inout Transaction) -> Void).self, call: "transaction")
   13|      0|        var transaction = Transaction()
   14|      0|        callback(&transaction)
   15|      0|    }
   16|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/ConfigurationModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - ViewControlAttributesTests
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |    
    8|      1|    func labelsHidden() -> Bool {
    9|      0|        return (try? modifierAttribute(modifierLookup: { modifier -> Bool in
   10|      0|            modifier.modifierType.hasPrefix("_LabeledViewStyleModifier<HiddenLabel")
   11|      0|        }, transitive: true, path: "modifier|style",
   12|      1|        type: Any.self, call: "labelsHidden")) != nil
   13|      1|    }
   14|       |    
   15|       |    #if os(macOS)
   16|       |    func horizontalRadioGroupLayout() throws -> Bool {
   17|       |        _ = try modifierAttribute(
   18|       |            modifierName: "RadioGroupLayoutModifier<_HStackLayout>",
   19|       |            path: "modifier|style",
   20|       |            type: Any.self, call: "horizontalRadioGroupLayout")
   21|       |        return true
   22|       |    }
   23|       |    
   24|       |    func controlSize() throws -> ControlSize {
   25|       |        let reference = EmptyView().controlSize(.regular)
   26|       |        let keyPath = try Inspector.environmentKeyPath(ControlSize.self, reference)
   27|       |        return try environment(keyPath, call: "controlSize")
   28|       |    }
   29|       |    #endif
   30|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/CustomStyleModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Custom Style Modifiers
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |
    8|      0|    func customStyle(_ modifierName: String) throws -> Any {
    9|      0|        
   10|      0|        let name = modifierName.firstUppercased + "Modifier"
   11|      0|
   12|      0|        let modifier = try self.modifier({ modifier -> Bool in
   13|      0|            return modifier.modifierType.hasPrefix(name)
   14|      0|        }, call: modifierName)
   15|      0|        if let style = try? Inspector.attribute(path: "modifier|style|style", value: modifier) {
   16|      0|            return style
   17|      0|        }
   18|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   19|      0|    }
   20|       |}
   21|       |
   22|       |private extension StringProtocol {
   23|      0|    var firstUppercased: String { prefix(1).uppercased() + dropFirst() }
   24|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/EnvironmentModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Environment Modifiers
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |
    8|      0|    func environment<T>(_ keyPath: WritableKeyPath<EnvironmentValues, T>) throws -> T {
    9|      0|        return try environment(keyPath, call: "environment(\(Inspector.typeName(type: T.self)))")
   10|      0|    }
   11|       |}
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |internal extension InspectableView {
   15|     10|    func environment<T>(_ reference: WritableKeyPath<EnvironmentValues, T>, call: String) throws -> T {
   16|     18|        guard let modifier = content.medium.environmentModifiers.last(where: { modifier in
   17|     18|            guard let keyPath = try? modifier.keyPath() as? WritableKeyPath<EnvironmentValues, T>
   18|     18|            else { return false }
   19|      0|            return keyPath == reference
   20|     10|        }) else {
   21|     10|            throw InspectionError.modifierNotFound(
   22|     10|                parent: Inspector.typeName(value: content.view), modifier: call, index: 0)
   23|      0|        }
   24|      0|        return try Inspector.cast(value: try modifier.value(), type: T.self)
   25|     10|    }
   26|       |}
   27|       |
   28|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   29|       |internal extension Inspector {
   30|    261|    static func environmentKeyPath<T>(_ type: T.Type, _ value: Any) throws -> WritableKeyPath<EnvironmentValues, T> {
   31|    261|        return try Inspector.attribute(path: "modifier|keyPath", value: value,
   32|    261|                                       type: WritableKeyPath<EnvironmentValues, T>.self)
   33|    261|    }
   34|       |}
   35|       |
   36|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   37|       |extension ModifiedContent: EnvironmentModifier where Modifier: EnvironmentModifier {
   38|     18|    func keyPath() throws -> Any {
   39|     18|        return try Inspector.attribute(label: "modifier", value: self,
   40|     18|                                       type: Modifier.self).keyPath()
   41|     18|    }
   42|       |    
   43|     27|    func value() throws -> Any {
   44|     27|        return try Inspector.attribute(label: "modifier", value: self,
   45|     27|                                       type: Modifier.self).value()
   46|     27|    }
   47|       |}
   48|       |
   49|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   50|       |internal protocol EnvironmentModifier {
   51|       |    func keyPath() throws -> Any
   52|       |    func value() throws -> Any
   53|       |}
   54|       |
   55|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   56|       |extension _EnvironmentKeyWritingModifier: EnvironmentModifier {
   57|       |    
   58|     18|    func keyPath() throws -> Any {
   59|     18|        return try Inspector.attribute(label: "keyPath", value: self)
   60|     18|    }
   61|       |    
   62|     27|    func value() throws -> Any {
   63|     27|        return try Inspector.attribute(label: "value", value: self)
   64|     27|    }
   65|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/EventsModifiers.swift:
    1|       |// MARK: - ViewEvents
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension InspectableView {
    5|       |    
    6|      0|    func callOnAppear() throws {
    7|      0|        let callback = try modifierAttribute(
    8|      0|            modifierName: "_AppearanceActionModifier", path: "modifier|appear",
    9|      0|            type: (() -> Void).self, call: "onAppear")
   10|      0|        callback()
   11|      0|    }
   12|       |    
   13|      0|    func callOnDisappear() throws {
   14|      0|        let callback = try modifierAttribute(
   15|      0|            modifierName: "_AppearanceActionModifier", path: "modifier|disappear",
   16|      0|            type: (() -> Void).self, call: "onDisappear")
   17|      0|        callback()
   18|      0|    }
   19|       |
   20|      0|    func callOnChange<E: Equatable>(newValue value: E, index: Int = 0) throws {
   21|      0|        let callback = try modifierAttribute(
   22|      0|            modifierName: "_ValueActionModifier<\(type(of: value))>",
   23|      0|            path: "modifier|action",
   24|      0|            type: ((E) -> Void).self,
   25|      0|            call: "onChange", index: index)
   26|      0|        callback(value)
   27|      0|    }
   28|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/GestureModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - ViewGestures
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|      1|    func callOnTapGesture() throws {
    8|      1|        typealias Callback = ((()) -> Void)
    9|      1|        let callback = try modifierAttribute(
   10|      1|            modifierName: "TapGesture",
   11|      1|            path: "modifier|gesture|_body|modifier|callbacks|ended",
   12|      1|            type: Callback.self, call: "onTapGesture")
   13|      1|        callback(())
   14|      1|    }
   15|       |    
   16|      0|    func callOnLongPressGesture() throws {
   17|      0|        let callback = try modifierAttribute(
   18|      0|            modifierName: "LongPressGesture",
   19|      0|            path: "modifier|gesture|modifier|callbacks|pressed",
   20|      0|            type: (() -> Void).self, call: "onLongPressGesture")
   21|      0|        callback()
   22|      0|    }
   23|       |}
   24|       |
   25|       |// MARK: - ViewHitTesting
   26|       |
   27|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   28|       |public struct ContentShape<S>: Equatable where S: Shape {
   29|       |    public let shape: S
   30|       |    public let eoFill: Bool
   31|       |    
   32|      0|    public static func == (lhs: Self, rhs: Self) -> Bool {
   33|      0|        let testRect = CGRect(x: 0, y: 0, width: 100, height: 100)
   34|      0|        return lhs.shape.path(in: testRect) == rhs.shape.path(in: testRect) &&
   35|      0|            lhs.eoFill == rhs.eoFill
   36|      0|    }
   37|       |}
   38|       |
   39|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   40|       |public extension InspectableView {
   41|       |    
   42|      1|    func allowsHitTesting() -> Bool {
   43|      0|        return !modifiersMatching({ $0.modifierType == "_AllowsHitTestingModifier" }, transitive: true)
   44|      1|            .lazy
   45|      0|            .compactMap {
   46|      0|                try? Inspector.attribute(path: "modifier|allowsHitTesting", value: $0, type: Bool.self)
   47|      0|            }
   48|      1|            .contains(false)
   49|      1|    }
   50|       |    
   51|      0|    func contentShape<S>(_ shape: S.Type) throws -> ContentShape<S> where S: Shape {
   52|      0|        let shapeValue = try modifierAttribute(
   53|      0|            modifierName: "_ContentShapeModifier", path: "modifier|shape",
   54|      0|            type: Any.self, call: "contentShape")
   55|      0|        let casted = try Inspector.cast(value: shapeValue, type: S.self)
   56|      0|        let eoFill = try modifierAttribute(
   57|      0|            modifierName: "_ContentShapeModifier", path: "modifier|eoFill",
   58|      0|            type: Bool.self, call: "contentShape")
   59|      0|        return .init(shape: casted, eoFill: eoFill)
   60|      0|    }
   61|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/PositioningModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - ViewPositioning
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |    
    8|      0|    func position() throws -> CGPoint {
    9|      0|        return try modifierAttribute(
   10|      0|            modifierName: "_PositionLayout", path: "modifier|position",
   11|      0|            type: CGPoint.self, call: "position")
   12|      0|    }
   13|       |    
   14|      0|    func offset() throws -> CGSize {
   15|      0|        return try modifierAttribute(
   16|      0|            modifierName: "_OffsetEffect", path: "modifier|offset",
   17|      0|            type: CGSize.self, call: "offset")
   18|      0|    }
   19|       |    
   20|      0|    func edgesIgnoringSafeArea() throws -> Edge.Set {
   21|      0|        return try modifierAttribute(
   22|      0|            modifierName: "_SafeAreaIgnoringLayout", path: "modifier|edges",
   23|      0|            type: Edge.Set.self, call: "edgesIgnoringSafeArea")
   24|      0|    }
   25|       |    
   26|      0|    func coordinateSpaceName() throws -> String {
   27|      0|        return try modifierAttribute(
   28|      0|            modifierName: "_CoordinateSpaceModifier", path: "modifier|name",
   29|      0|            type: String.self, call: "coordinateSpace(name:)")
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - ViewLayering
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |public extension InspectableView {
   37|       |    
   38|      0|    func zIndex() throws -> Double {
   39|      0|        return try modifierAttribute(
   40|      0|            modifierName: "ZIndexTraitKey", path: "modifier|value",
   41|      0|            type: Double.self, call: "zIndex")
   42|      0|    }
   43|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/PreviewModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - ViewColorTests
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |    
    8|      0|    func foregroundColor() throws -> Color? {
    9|      0|        return try foregroundColor(checkIfText: true)
   10|      0|    }
   11|       |    
   12|      5|    internal func foregroundColor(checkIfText: Bool) throws -> Color? {
   13|      5|        let reference = EmptyView().foregroundColor(nil)
   14|      5|        let keyPath = try Inspector.environmentKeyPath(Optional<Color>.self, reference)
   15|      5|        let throwIfText: () throws -> Void = {
   16|      5|            guard checkIfText, content.view is Text else { return }
   17|      0|            throw InspectionError.notSupported(
   18|      0|                "Please use .attributes().foregroundColor() for inspecting foregroundColor on a Text")
   19|      5|        }
   20|      5|        do {
   21|      5|            let color = try environment(keyPath, call: "foregroundColor")
   22|      5|            try throwIfText()
   23|      5|            return color
   24|      5|        } catch {
   25|      5|            try throwIfText()
   26|      5|            throw error
   27|      0|        }
   28|      0|    }
   29|       |    
   30|       |    @available(macOS 11.0, *)
   31|      0|    func accentColor() throws -> Color? {
   32|      0|        let reference = EmptyView().accentColor(nil)
   33|      0|        let keyPath = try Inspector.environmentKeyPath(Optional<Color>.self, reference)
   34|      0|        return try environment(keyPath, call: "accentColor")
   35|      0|    }
   36|       |    
   37|      0|    func colorScheme() throws -> ColorScheme {
   38|      0|        let reference = EmptyView().colorScheme(.light)
   39|      0|        do {
   40|      0|            let keyPath = try Inspector.environmentKeyPath(ColorScheme.self, reference)
   41|      0|            return try environment(keyPath, call: "colorScheme")
   42|      0|        } catch {
   43|      0|            if #available(macOS 11.0, *) {
   44|      0|                if let preferred = try? preferredColorScheme() {
   45|      0|                    return preferred
   46|      0|                }
   47|      0|            }
   48|      0|            throw error
   49|      0|        }
   50|      0|    }
   51|       |    
   52|       |    @available(macOS 11.0, *)
   53|      0|    func preferredColorScheme() throws -> ColorScheme? {
   54|      0|        return try modifierAttribute(
   55|      0|            modifierName: "_PreferenceWritingModifier<PreferredColorSchemeKey>",
   56|      0|            transitive: true,
   57|      0|            path: "modifier|value", type: Optional<ColorScheme>.self, call: "preferredColorScheme")
   58|      0|    }
   59|       |}
   60|       |
   61|       |// MARK: - ViewPreview
   62|       |
   63|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   64|       |public extension InspectableView {
   65|       |    
   66|      0|    func previewDevice() throws -> PreviewDevice {
   67|      0|        return try modifierAttribute(
   68|      0|            modifierName: "PreviewDeviceTraitKey", path: "modifier|value",
   69|      0|            type: PreviewDevice.self, call: "previewDevice")
   70|      0|    }
   71|       |    
   72|      0|    func previewDisplayName() throws -> String {
   73|      0|        return try modifierAttribute(
   74|      0|            modifierName: "PreviewDisplayNameTraitKey", path: "modifier|value",
   75|      0|            type: String.self, call: "previewDisplayName")
   76|      0|    }
   77|       |    
   78|      0|    func previewLayout() throws -> PreviewLayout {
   79|      0|        return try modifierAttribute(
   80|      0|            modifierName: "PreviewLayoutTraitKey", path: "modifier|value",
   81|      0|            type: PreviewLayout.self, call: "previewLayout")
   82|      0|    }
   83|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/SizingModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - ViewSizing
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |
    8|      0|    func fixedFrame() throws -> (width: CGFloat, height: CGFloat, alignment: Alignment) {
    9|      0|        let width = try fixedWidth()
   10|      0|        let height = try fixedHeight()
   11|      0|        let alignment = try fixedAlignment()
   12|      0|        return (width, height, alignment)
   13|      0|    }
   14|       |
   15|      0|    func fixedHeight() throws -> CGFloat {
   16|      0|        return try modifierAttribute(
   17|      0|            modifierName: "_FrameLayout", path: "modifier|height",
   18|      0|            type: CGFloat.self, call: "frame(height:)")
   19|      0|    }
   20|       |
   21|      0|    func fixedWidth() throws -> CGFloat {
   22|      0|        return try modifierAttribute(
   23|      0|            modifierName: "_FrameLayout", path: "modifier|width",
   24|      0|            type: CGFloat.self, call: "frame(width:)")
   25|      0|    }
   26|       |
   27|      0|    func fixedAlignment() throws -> Alignment {
   28|      0|        return try modifierAttribute(
   29|      0|            modifierName: "_FrameLayout", path: "modifier|alignment",
   30|      0|            type: Alignment.self, call: "frame(alignment:)")
   31|      0|    }
   32|       |    
   33|       |    func flexFrame() throws -> (minWidth: CGFloat, idealWidth: CGFloat, maxWidth: CGFloat,
   34|       |                                minHeight: CGFloat, idealHeight: CGFloat, maxHeight: CGFloat,
   35|      0|                                alignment: Alignment) {
   36|      0|        let floatAttrNames = ["minWidth", "idealWidth", "maxWidth",
   37|      0|                              "minHeight", "idealHeight", "maxHeight"]
   38|      0|        let call = "frame(minWidth: idealWidth: maxWidth: minHeight: idealHeight: maxHeight: alignment:)"
   39|      0|        var floats = [CGFloat]()
   40|      0|        for name in floatAttrNames {
   41|      0|            do {
   42|      0|                let value = try modifierAttribute(
   43|      0|                    modifierName: "_FlexFrameLayout", path: "modifier|\(name)",
   44|      0|                    type: CGFloat.self, call: call)
   45|      0|                floats.append(value)
   46|      0|            } catch {
   47|      0|                floats.append(CGFloat.nan)
   48|      0|            }
   49|      0|        }
   50|      0|        let alignment = try modifierAttribute(
   51|      0|            modifierName: "_FlexFrameLayout", path: "modifier|alignment",
   52|      0|            type: Alignment.self, call: call)
   53|      0|        return (floats[0], floats[1], floats[2], floats[3], floats[4], floats[5], alignment)
   54|      0|    }
   55|       |
   56|      0|    func fixedSize() throws -> (horizontal: Bool, vertical: Bool) {
   57|      0|        let horizontal = try modifierAttribute(
   58|      0|            modifierName: "_FixedSizeLayout", path: "modifier|horizontal",
   59|      0|            type: Bool.self, call: "fixedSize")
   60|      0|        let vertical = try modifierAttribute(
   61|      0|            modifierName: "_FixedSizeLayout", path: "modifier|vertical",
   62|      0|            type: Bool.self, call: "fixedSize")
   63|      0|        return (horizontal, vertical)
   64|      0|    }
   65|       |
   66|      0|    func layoutPriority() throws -> Double {
   67|      0|        return try modifierAttribute(
   68|      0|            modifierName: "LayoutPriorityTraitKey", path: "modifier|value",
   69|      0|            type: Double.self, call: "layoutPriority")
   70|      0|    }
   71|       |}
   72|       |
   73|       |// MARK: - ViewPadding
   74|       |
   75|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   76|       |public extension InspectableView {
   77|       |
   78|       |    private struct PaddingAttributes {
   79|       |        let edgeInsets: EdgeInsets?
   80|       |        let edges: Edge.Set
   81|       |    }
   82|       |
   83|      0|    func padding() throws -> EdgeInsets {
   84|      0|        return try modifierAttribute(
   85|      0|            modifierName: "_PaddingLayout", path: "modifier|insets",
   86|      0|            type: EdgeInsets.self, call: "padding")
   87|      0|    }
   88|       |
   89|      0|    func padding(_ edge: Edge.Set) throws -> CGFloat {
   90|      0|        let attributes = try self.paddingAttributes()
   91|      0|        for attribute in attributes {
   92|      0|            if attribute.edges.contains(edge) {
   93|      0|                if let value = edgeValue(attribute: attribute, edge: edge) {
   94|      0|                    return value
   95|      0|                }
   96|      0|            }
   97|      0|        }
   98|      0|        throw InspectionError.modifierNotFound(
   99|      0|            parent: Inspector.typeName(value: self), modifier: "padding", index: 0)
  100|      0|    }
  101|       |
  102|      0|    func hasPadding(_ edge: Edge.Set = .all)  throws -> Bool {
  103|      0|        let attributes = try self.paddingAttributes()
  104|      0|        for attribute in attributes {
  105|      0|            if attribute.edges.contains(edge) {
  106|      0|                return true
  107|      0|            }
  108|      0|        }
  109|      0|        return false
  110|      0|    }
  111|       |
  112|      0|    private func edgeValue(attribute: PaddingAttributes, edge: Edge.Set) -> CGFloat? {
  113|      0|        guard let edgeInsets = attribute.edgeInsets else {
  114|      0|            return nil
  115|      0|        }
  116|      0|        var result = [CGFloat]()
  117|      0|        if edge.contains(.top) {
  118|      0|            result.append(edgeInsets.top)
  119|      0|        }
  120|      0|        if edge.contains(.bottom) {
  121|      0|            result.append(edgeInsets.bottom)
  122|      0|        }
  123|      0|        if edge.contains(.trailing) {
  124|      0|            result.append(edgeInsets.trailing)
  125|      0|        }
  126|      0|        if edge.contains(.leading) {
  127|      0|            result.append(edgeInsets.leading)
  128|      0|        }
  129|      0|        if hasSingleValue(result) {
  130|      0|            return result[0]
  131|      0|        }
  132|      0|        return nil
  133|      0|    }
  134|       |
  135|      0|    private func hasSingleValue(_ array: [CGFloat]) -> Bool {
  136|      0|        if array.count == 0 {
  137|      0|            return false
  138|      0|        }
  139|      0|        return array.dropLast().allSatisfy { $0 == array.last }
  140|      0|    }
  141|       |
  142|      0|    private func paddingAttributes() throws -> [PaddingAttributes] {
  143|      0|        
  144|      0|        return try modifiersMatching({ $0.modifierType.contains("_PaddingLayout") })
  145|      0|            .enumerated()
  146|      0|            .map { index, modifier -> PaddingAttributes in
  147|      0|                let edges = try modifierAttribute(
  148|      0|                    modifierName: "_PaddingLayout", path: "modifier|edges",
  149|      0|                    type: SwiftUI.Edge.Set.self, call: "padding", index: index)
  150|      0|                let insets: EdgeInsets?
  151|      0|                do {
  152|      0|                    insets = try modifierAttribute(
  153|      0|                        modifierName: "_PaddingLayout", path: "modifier|insets",
  154|      0|                        type: EdgeInsets.self, call: "padding", index: index)
  155|      0|                } catch {
  156|      0|                    insets = nil
  157|      0|                }
  158|      0|                return .init(edgeInsets: insets, edges: edges)
  159|      0|            }
  160|      0|    }
  161|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/TextInputModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Adjusting Text in a View
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |    
    8|       |    #if !os(macOS)
    9|      0|    func textContentType() throws -> UITextContentType? {
   10|      0|        let reference = EmptyView().textContentType(.emailAddress)
   11|      0|        let keyPath = try Inspector.environmentKeyPath(Optional<String>.self, reference)
   12|      0|        let value = try environment(keyPath, call: "textContentType")
   13|      0|        return value.flatMap { UITextContentType(rawValue: $0) }
   14|      0|    }
   15|       |    #endif
   16|       |
   17|       |    #if os(iOS) || os(tvOS)
   18|      0|    func keyboardType() throws -> UIKeyboardType {
   19|      0|        let reference = EmptyView().keyboardType(.default)
   20|      0|        let keyPath = try Inspector.environmentKeyPath(Int.self, reference)
   21|      0|        let value = try environment(keyPath, call: "keyboardType")
   22|      0|        return UIKeyboardType(rawValue: value)!
   23|      0|    }
   24|       |    
   25|      0|    func autocapitalization() throws -> UITextAutocapitalizationType {
   26|      0|        let reference = EmptyView().autocapitalization(.none)
   27|      0|        let keyPath = try Inspector.environmentKeyPath(Int.self, reference)
   28|      0|        let value = try environment(keyPath, call: "autocapitalization")
   29|      0|        return UITextAutocapitalizationType(rawValue: value)!
   30|      0|    }
   31|       |    #endif
   32|       |    
   33|      0|    func font() throws -> Font? {
   34|      0|        return try font(checkIfText: true)
   35|      0|    }
   36|       |    
   37|      5|    internal func font(checkIfText: Bool) throws -> Font? {
   38|      5|        let reference = EmptyView().font(.callout)
   39|      5|        let keyPath = try Inspector.environmentKeyPath(Optional<Font>.self, reference)
   40|      5|        let throwIfText: () throws -> Void = {
   41|      5|            guard checkIfText, content.view is Text else { return }
   42|      0|            throw InspectionError.notSupported(
   43|      0|                "Please use .attributes().font() for inspecting Font on a Text")
   44|      5|        }
   45|      5|        do {
   46|      5|            let font = try environment(keyPath, call: "font")
   47|      5|            try throwIfText()
   48|      5|            return font
   49|      5|        } catch {
   50|      5|            try throwIfText()
   51|      5|            throw error
   52|      0|        }
   53|      0|    }
   54|       |    
   55|      0|    func lineLimit() throws -> Int? {
   56|      0|        let reference = EmptyView().lineLimit(nil)
   57|      0|        let keyPath = try Inspector.environmentKeyPath(Optional<Int>.self, reference)
   58|      0|        return try environment(keyPath, call: "lineLimit")
   59|      0|    }
   60|       |    
   61|      0|    func lineSpacing() throws -> CGFloat {
   62|      0|        let reference = EmptyView().lineSpacing(0)
   63|      0|        let keyPath = try Inspector.environmentKeyPath(CGFloat.self, reference)
   64|      0|        return try environment(keyPath, call: "lineSpacing")
   65|      0|    }
   66|       |    
   67|      0|    func multilineTextAlignment() throws -> TextAlignment {
   68|      0|        let reference = EmptyView().multilineTextAlignment(.leading)
   69|      0|        let keyPath = try Inspector.environmentKeyPath(TextAlignment.self, reference)
   70|      0|        return try environment(keyPath, call: "multilineTextAlignment")
   71|      0|    }
   72|       |    
   73|      0|    func minimumScaleFactor() throws -> CGFloat {
   74|      0|        let reference = EmptyView().minimumScaleFactor(3)
   75|      0|        let keyPath = try Inspector.environmentKeyPath(CGFloat.self, reference)
   76|      0|        return try environment(keyPath, call: "minimumScaleFactor")
   77|      0|    }
   78|       |    
   79|      0|    func truncationMode() throws -> Text.TruncationMode {
   80|      0|        let reference = EmptyView().truncationMode(.head)
   81|      0|        let keyPath = try Inspector.environmentKeyPath(Text.TruncationMode.self, reference)
   82|      0|        return try environment(keyPath, call: "truncationMode")
   83|      0|    }
   84|       |    
   85|      0|    func allowsTightening() -> Bool {
   86|      0|        let reference = EmptyView().allowsTightening(true)
   87|      0|        if let keyPath = try? Inspector.environmentKeyPath(Bool.self, reference),
   88|      0|           let value = try? environment(keyPath, call: "allowsTightening") {
   89|      0|            return value
   90|      0|        }
   91|      0|        return false
   92|      0|    }
   93|       |    
   94|      0|    func disableAutocorrection() -> Bool {
   95|      0|        let reference = EmptyView().disableAutocorrection(false)
   96|      0|        if let keyPath = try? Inspector.environmentKeyPath(Optional<Bool>.self, reference),
   97|      0|           let value = try? environment(keyPath, call: "disableAutocorrection") {
   98|      0|            return value
   99|      0|        }
  100|      0|        return false
  101|      0|    }
  102|       |    
  103|      0|    func flipsForRightToLeftLayoutDirection() -> Bool {
  104|      0|        return modifiersMatching({ $0.modifierType == "_FlipForRTLEffect" },
  105|      0|                                 transitive: true)
  106|      0|            .compactMap {
  107|      0|                try? Inspector.attribute(path: "modifier|isEnabled", value: $0, type: Bool.self)
  108|      0|            }
  109|      0|            .contains(true)
  110|      0|    }
  111|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/TransformingModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - ViewTransforming
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |    
    8|      0|    func rotation() throws -> (angle: Angle, anchor: UnitPoint) {
    9|      0|        let angle = try modifierAttribute(
   10|      0|            modifierName: "_RotationEffect", path: "modifier|angle",
   11|      0|            type: Angle.self, call: "rotationEffect")
   12|      0|        let anchor = try modifierAttribute(
   13|      0|            modifierName: "_RotationEffect", path: "modifier|anchor",
   14|      0|            type: UnitPoint.self, call: "rotationEffect")
   15|      0|        return (angle, anchor)
   16|      0|    }
   17|       |    
   18|       |    struct Rotation3D {
   19|       |        let angle: Angle
   20|       |        let axis: Axis
   21|       |        let anchor: UnitPoint
   22|       |        let anchorZ: CGFloat
   23|       |        let perspective: CGFloat
   24|       |        typealias Axis = (x: CGFloat, y: CGFloat, z: CGFloat)
   25|       |    }
   26|       |    
   27|      0|    func rotation3D() throws -> Rotation3D {
   28|      0|        let angle = try modifierAttribute(
   29|      0|            modifierName: "_Rotation3DEffect", path: "modifier|angle",
   30|      0|            type: Angle.self, call: "rotation3DEffect")
   31|      0|        let axis = try modifierAttribute(
   32|      0|            modifierName: "_Rotation3DEffect", path: "modifier|axis",
   33|      0|            type: Rotation3D.Axis.self, call: "rotation3DEffect")
   34|      0|        let anchor = try modifierAttribute(
   35|      0|            modifierName: "_Rotation3DEffect", path: "modifier|anchor",
   36|      0|            type: UnitPoint.self, call: "rotation3DEffect")
   37|      0|        let anchorZ = try modifierAttribute(
   38|      0|            modifierName: "_Rotation3DEffect", path: "modifier|anchorZ",
   39|      0|            type: CGFloat.self, call: "rotation3DEffect")
   40|      0|        let perspective = try modifierAttribute(
   41|      0|            modifierName: "_Rotation3DEffect", path: "modifier|perspective",
   42|      0|            type: CGFloat.self, call: "rotation3DEffect")
   43|      0|        return .init(angle: angle, axis: axis, anchor: anchor,
   44|      0|                     anchorZ: anchorZ, perspective: perspective)
   45|      0|    }
   46|       |    
   47|      0|    func projectionTransform() throws -> ProjectionTransform {
   48|      0|        return try modifierAttribute(
   49|      0|            modifierName: "_ProjectionEffect", path: "modifier|transform",
   50|      0|            type: ProjectionTransform.self, call: "projectionTransform")
   51|      0|    }
   52|       |    
   53|      0|    func transformEffect() throws -> CGAffineTransform {
   54|      0|        return try modifierAttribute(
   55|      0|            modifierName: "_TransformEffect", path: "modifier|transform",
   56|      0|            type: CGAffineTransform.self, call: "transformEffect")
   57|      0|    }
   58|       |}
   59|       |
   60|       |// MARK: - ViewScaling
   61|       |
   62|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   63|       |public extension InspectableView {
   64|       |    
   65|      0|    func isScaledToFill() throws -> Bool {
   66|      0|        let values = try aspectRatio(call: "scaledToFill")
   67|      0|        return values.contentMode == .fill && values.aspectRatio == nil
   68|      0|    }
   69|       |    
   70|      0|    func isScaledToFit() throws -> Bool {
   71|      0|        let values = try aspectRatio(call: "scaledToFit")
   72|      0|        return values.contentMode == .fit && values.aspectRatio == nil
   73|      0|    }
   74|       |    
   75|      0|    func scaleEffect() throws -> CGSize {
   76|      0|        return try modifierAttribute(
   77|      0|            modifierName: "_ScaleEffect", path: "modifier|scale",
   78|      0|            type: CGSize.self, call: "scaleEffect")
   79|      0|    }
   80|       |    
   81|      0|    func scaleEffectAnchor() throws -> UnitPoint {
   82|      0|        return try modifierAttribute(
   83|      0|            modifierName: "_ScaleEffect", path: "modifier|anchor",
   84|      0|            type: UnitPoint.self, call: "scaleEffect")
   85|      0|    }
   86|       |    
   87|      0|    func aspectRatio() throws -> (aspectRatio: CGFloat?, contentMode: ContentMode) {
   88|      0|        return try aspectRatio(call: "aspectRatio")
   89|      0|    }
   90|       |    
   91|       |    #if !os(macOS)
   92|      0|    func imageScale() throws -> Image.Scale {
   93|      0|        let reference = EmptyView().imageScale(.large)
   94|      0|        let keyPath = try Inspector.environmentKeyPath(Image.Scale.self, reference)
   95|      0|        return try environment(keyPath, call: "imageScale")
   96|      0|    }
   97|       |    #endif
   98|       |    
   99|      0|    private func aspectRatio(call: String) throws -> (aspectRatio: CGFloat?, contentMode: ContentMode) {
  100|      0|        let ratio = try modifierAttribute(
  101|      0|            modifierName: "_AspectRatioLayout", path: "modifier|aspectRatio",
  102|      0|            type: Optional<CGFloat>.self, call: call)
  103|      0|        let mode = try modifierAttribute(
  104|      0|            modifierName: "_AspectRatioLayout", path: "modifier|contentMode",
  105|      0|            type: ContentMode.self, call: call)
  106|      0|        return (ratio, mode)
  107|      0|    }
  108|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/TransitiveModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal protocol PossiblyTransitiveModifier {
    5|       |    func isTransitive() -> Bool
    6|       |}
    7|       |
    8|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    9|       |extension ModifiedContent: PossiblyTransitiveModifier {
   10|    251|    func isTransitive() -> Bool {
   11|    251|        let name = Inspector.typeName(type: Modifier.self)
   12|    251|        if [
   13|    251|            "_HiddenModifier",
   14|    251|            "_FlipForRTLEffect",
   15|    251|            "_AllowsHitTestingModifier",
   16|    251|            "_PreferenceWritingModifier<PreferredColorSchemeKey>",
   17|    251|        ].contains(name) || [
   18|    251|            "_LabeledViewStyleModifier<HiddenLabel",
   19|    251|        ].contains(where: { name.hasPrefix($0) }) {
   20|      0|            return true
   21|    251|        }
   22|    251|        if self.isDisabledEnvironmentKeyTransformModifier() {
   23|      0|            return true
   24|    251|        }
   25|    251|        return false
   26|    251|    }
   27|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/Modifiers/VisualEffectModifiers.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - ViewGraphicalEffects
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension InspectableView {
    7|       |    
    8|      2|    func blur() throws -> (radius: CGFloat, isOpaque: Bool) {
    9|      2|        let radius = try modifierAttribute(
   10|      2|            modifierName: "_BlurEffect", path: "modifier|radius",
   11|      2|            type: CGFloat.self, call: "blur")
   12|      2|        let isOpaque = try modifierAttribute(
   13|      2|            modifierName: "_BlurEffect", path: "modifier|isOpaque",
   14|      2|            type: Bool.self, call: "blur")
   15|      2|        return (radius, isOpaque)
   16|      2|    }
   17|       |    
   18|      0|    func opacity() throws -> Double {
   19|      0|        return try modifierAttribute(
   20|      0|            modifierName: "_OpacityEffect", path: "modifier|opacity",
   21|      0|            type: Double.self, call: "opacity")
   22|      0|    }
   23|       |    
   24|      0|    func brightness() throws -> Double {
   25|      0|        return try modifierAttribute(
   26|      0|            modifierName: "_BrightnessEffect", path: "modifier|amount",
   27|      0|            type: Double.self, call: "brightness")
   28|      0|    }
   29|       |    
   30|      0|    func contrast() throws -> Double {
   31|      0|        return try modifierAttribute(
   32|      0|            modifierName: "_ContrastEffect", path: "modifier|amount",
   33|      0|            type: Double.self, call: "contrast")
   34|      0|    }
   35|       |    
   36|      0|    func colorInvert() throws {
   37|      0|        _ = try modifierAttribute(
   38|      0|            modifierName: "_ColorInvertEffect", path: "modifier",
   39|      0|            type: Any.self, call: "colorInvert")
   40|      0|    }
   41|       |    
   42|      0|    func colorMultiply() throws -> Color {
   43|      0|        return try modifierAttribute(
   44|      0|            modifierName: "_ColorMultiplyEffect", path: "modifier|color",
   45|      0|            type: Color.self, call: "colorMultiply")
   46|      0|    }
   47|       |    
   48|      0|    func saturation() throws -> Double {
   49|      0|        return try modifierAttribute(
   50|      0|            modifierName: "_SaturationEffect", path: "modifier|amount",
   51|      0|            type: Double.self, call: "saturation")
   52|      0|    }
   53|       |    
   54|      0|    func grayscale() throws -> Double {
   55|      0|        return try modifierAttribute(
   56|      0|            modifierName: "_GrayscaleEffect", path: "modifier|amount",
   57|      0|            type: Double.self, call: "grayscale")
   58|      0|    }
   59|       |    
   60|      0|    func hueRotation() throws -> Angle {
   61|      0|        return try modifierAttribute(
   62|      0|            modifierName: "_HueRotationEffect", path: "modifier|angle",
   63|      0|            type: Angle.self, call: "hueRotation")
   64|      0|    }
   65|       |    
   66|      0|    func luminanceToAlpha() throws {
   67|      0|        _ = try modifierAttribute(
   68|      0|            modifierName: "_LuminanceToAlphaEffect", path: "modifier",
   69|      0|            type: Any.self, call: "luminanceToAlpha")
   70|      0|    }
   71|       |    
   72|      0|    func shadow() throws -> (color: Color, radius: CGFloat, offset: CGSize) {
   73|      0|        let color = try modifierAttribute(
   74|      0|            modifierName: "_ShadowEffect", path: "modifier|color",
   75|      0|            type: Color.self, call: "shadow")
   76|      0|        let radius = try modifierAttribute(
   77|      0|            modifierName: "_ShadowEffect", path: "modifier|radius",
   78|      0|            type: CGFloat.self, call: "shadow")
   79|      0|        let offset = try modifierAttribute(
   80|      0|            modifierName: "_ShadowEffect", path: "modifier|offset",
   81|      0|            type: CGSize.self, call: "shadow")
   82|      0|        return (color, radius, offset)
   83|      0|    }
   84|       |    
   85|      0|    func border<S>(_ type: S.Type) throws -> (content: S, width: CGFloat) {
   86|      0|        let content = try modifierAttribute(modifierName:
   87|      0|            "_OverlayModifier<_ShapeView<_StrokedShape", path: "modifier|overlay|style",
   88|      0|            type: Any.self, call: "border")
   89|      0|        let castedContent = try Inspector.cast(value: content, type: S.self)
   90|      0|        let width = try modifierAttribute(modifierName:
   91|      0|            "_OverlayModifier<_ShapeView<_StrokedShape", path: "modifier|overlay|shape|style|lineWidth",
   92|      0|            type: CGFloat.self, call: "border")
   93|      0|        return (castedContent, width)
   94|      0|    }
   95|       |    
   96|      0|    func blendMode() throws -> BlendMode {
   97|      0|        return try modifierAttribute(
   98|      0|            modifierName: "_BlendModeEffect", path: "modifier|blendMode",
   99|      0|            type: BlendMode.self, call: "blendMode")
  100|      0|    }
  101|       |}
  102|       |
  103|       |// MARK: - ViewMasking
  104|       |
  105|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  106|       |public extension InspectableView {
  107|       |    
  108|      0|    func clipShape<S>(_ shape: S.Type) throws -> S where S: Shape {
  109|      0|        return try clipShape(shape, call: "clipShape")
  110|      0|    }
  111|       |    
  112|      0|    private func clipShape<S>(_ shape: S.Type, call: String) throws -> S where S: Shape {
  113|      0|        let shapeValue = try modifierAttribute(
  114|      0|            modifierName: "_ClipEffect", path: "modifier|shape",
  115|      0|            type: Any.self, call: call)
  116|      0|        return try Inspector.cast(value: shapeValue, type: S.self)
  117|      0|    }
  118|       |    
  119|      0|    func clipStyle() throws -> FillStyle {
  120|      0|        return try modifierAttribute(
  121|      0|            modifierName: "_ClipEffect", path: "modifier|style",
  122|      0|            type: FillStyle.self, call: "clipStyle")
  123|      0|    }
  124|       |    
  125|      0|    func cornerRadius() throws -> CGFloat {
  126|      0|        let shape = try clipShape(RoundedRectangle.self, call: "cornerRadius")
  127|      0|        return shape.cornerSize.width
  128|      0|    }
  129|       |    
  130|      0|    func mask() throws -> InspectableView<ViewType.ClassifiedView> {
  131|      0|        return try contentForModifierLookup.mask(parent: self)
  132|      0|    }
  133|       |}
  134|       |
  135|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  136|       |internal extension Content {
  137|      0|    func mask(parent: UnwrappedView) throws -> InspectableView<ViewType.ClassifiedView> {
  138|      0|        let rootView = try modifierAttribute(
  139|      0|            modifierName: "_MaskEffect", path: "modifier|mask",
  140|      0|            type: Any.self, call: "mask")
  141|      0|        let medium = self.medium.resettingViewModifiers()
  142|      0|        return try .init(try Inspector.unwrap(content: Content(rootView, medium: medium)),
  143|      0|                         parent: parent, call: "mask()")
  144|      0|    }
  145|       |}
  146|       |
  147|       |// MARK: - ViewHiding
  148|       |
  149|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  150|       |public extension InspectableView {
  151|       |    
  152|      1|    func isHidden() -> Bool {
  153|      1|        if labelsHidden() && isControlLabelDescendant() {
  154|      0|            return true
  155|      1|        }
  156|      1|        return (try? modifierAttribute(
  157|      1|                    modifierName: "_HiddenModifier", transitive: true,
  158|      1|                    path: "modifier", type: Any.self, call: "hidden")) != nil
  159|      1|    }
  160|       |    
  161|      1|    func isDisabled() -> Bool {
  162|      1|        typealias Closure = (inout Bool) -> Void
  163|      0|        return modifiersMatching({ modifier -> Bool in
  164|      0|            guard modifier.isDisabledEnvironmentKeyTransformModifier(),
  165|      0|                  let closure = try? Inspector.attribute(
  166|      0|                    path: "modifier|transform", value: modifier, type: Closure.self)
  167|      0|            else { return false }
  168|      0|            var value = true
  169|      0|            closure(&value)
  170|      0|            return !value
  171|      0|        }, transitive: true).count > 0
  172|      1|    }
  173|       |}
  174|       |
  175|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  176|       |private extension UnwrappedView {
  177|      0|    func isControlLabelDescendant() -> Bool {
  178|      0|        guard let parent = parentView, let grandParent = parent.parentView
  179|      0|        else { return false }
  180|      0|        if parent.inspectionCall == "labelView()",
  181|      0|           grandParent is InspectableView<ViewType.ColorPicker>
  182|      0|        || grandParent is InspectableView<ViewType.DatePicker>
  183|      0|        || grandParent is InspectableView<ViewType.Picker>
  184|      0|        || grandParent is InspectableView<ViewType.ProgressView>
  185|      0|        || grandParent is InspectableView<ViewType.Slider>
  186|      0|        || grandParent is InspectableView<ViewType.Stepper>
  187|      0|        || grandParent is InspectableView<ViewType.TextField>
  188|      0|        || grandParent is InspectableView<ViewType.Toggle> {
  189|      0|            return true
  190|      0|        }
  191|      0|        return parent.isControlLabelDescendant()
  192|      0|    }
  193|       |}
  194|       |
  195|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  196|       |internal extension ModifierNameProvider {
  197|    251|    func isDisabledEnvironmentKeyTransformModifier() -> Bool {
  198|    251|        let reference = EmptyView().disabled(true)
  199|    251|        guard let referenceKeyPath = try? Inspector.environmentKeyPath(Bool.self, reference),
  200|    251|              self.modifierType == "_EnvironmentKeyTransformModifier<Bool>",
  201|    251|              let keyPath = try? Inspector.environmentKeyPath(Bool.self, self),
  202|    251|              keyPath == referenceKeyPath
  203|    251|        else { return false }
  204|      0|        return true
  205|    251|    }
  206|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ActionSheet.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - ActionSheet
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension ViewType {
    7|       |    
    8|       |    struct ActionSheet: KnownViewType {
    9|       |        public static var typePrefix: String = "ViewType.ActionSheet.Container"
   10|      8|        public static var namespacedPrefixes: [String] {
   11|      8|            return ["ViewInspector." + typePrefix]
   12|      8|        }
   13|      0|        public static func inspectionCall(typeName: String) -> String {
   14|      0|            return "actionSheet(\(ViewType.indexPlaceholder))"
   15|      0|        }
   16|       |    }
   17|       |}
   18|       |
   19|       |// MARK: - Extraction
   20|       |
   21|       |@available(iOS 13.0, tvOS 13.0, *)
   22|       |@available(macOS, unavailable)
   23|       |public extension InspectableView {
   24|       |
   25|      0|    func actionSheet(_ index: Int? = nil) throws -> InspectableView<ViewType.ActionSheet> {
   26|      0|        return try contentForModifierLookup.actionSheet(parent: self, index: index)
   27|      0|    }
   28|       |}
   29|       |
   30|       |@available(iOS 13.0, tvOS 13.0, *)
   31|       |@available(macOS, unavailable)
   32|       |internal extension Content {
   33|       |    
   34|     98|    func actionSheet(parent: UnwrappedView, index: Int?) throws -> InspectableView<ViewType.ActionSheet> {
   35|     98|        guard let sheetBuilder = try? self.modifierAttribute(
   36|    212|                modifierLookup: { isActionSheetBuilder(modifier: $0) }, path: "modifier",
   37|      0|                type: ActionSheetBuilder.self, call: "", index: index ?? 0)
   38|     98|        else {
   39|    212|            _ = try self.modifier({
   40|    212|                $0.modifierType == "IdentifiedPreferenceTransformModifier<Key>"
   41|    212|                || $0.modifierType.contains("AlertTransformModifier")
   42|    212|            }, call: "actionSheet")
   43|     98|            throw InspectionError.notSupported(
   44|     98|                """
   45|     98|                Please refer to the Guide for inspecting the ActionSheet: \
   46|     98|                https://github.com/nalexn/ViewInspector/blob/master/guide.md#actionsheet
   47|     98|                """)
   48|      0|        }
   49|      0|        let sheet = try sheetBuilder.buildSheet()
   50|      0|        let container = ViewType.ActionSheet.Container(sheet: sheet, builder: sheetBuilder)
   51|      0|        let medium = self.medium.resettingViewModifiers()
   52|      0|        let content = Content(container, medium: medium)
   53|      0|        let call = ViewType.inspectionCall(
   54|      0|            base: ViewType.ActionSheet.inspectionCall(typeName: ""), index: index)
   55|      0|        return try .init(content, parent: parent, call: call, index: index)
   56|     98|    }
   57|       |    
   58|    124|    func actionSheetsForSearch() -> [ViewSearch.ModifierIdentity] {
   59|    124|        let count = medium.viewModifiers
   60|    114|            .compactMap { isActionSheetBuilder(modifier: $0) }
   61|    124|            .count
   62|    114|        return Array(0..<count).map { _ in
   63|     98|            .init(name: "", builder: { parent, index in
   64|     98|                try parent.content.actionSheet(parent: parent, index: index)
   65|     98|            })
   66|    114|        }
   67|    124|    }
   68|       |    
   69|    326|    private func isActionSheetBuilder(modifier: Any) -> Bool {
   70|    326|        return (try? Inspector.attribute(
   71|    326|            label: "modifier", value: modifier, type: ActionSheetBuilder.self)) != nil
   72|    326|    }
   73|       |}
   74|       |
   75|       |@available(iOS 13.0, tvOS 13.0, *)
   76|       |@available(macOS, unavailable)
   77|       |internal extension ViewType.ActionSheet {
   78|       |    struct Container: CustomViewIdentityMapping {
   79|       |        let sheet: SwiftUI.ActionSheet
   80|       |        let builder: ActionSheetBuilder
   81|       |        
   82|      0|        var viewTypeForSearch: KnownViewType.Type { ViewType.ActionSheet.self }
   83|       |    }
   84|       |}
   85|       |
   86|       |// MARK: - Custom Attributes
   87|       |
   88|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   89|       |public extension InspectableView where View == ViewType.ActionSheet {
   90|       |
   91|      0|    func title() throws -> InspectableView<ViewType.Text> {
   92|      0|        return try View.supplementaryChildren(self).element(at: 0)
   93|      0|            .asInspectableView(ofType: ViewType.Text.self)
   94|      0|    }
   95|       |    
   96|      0|    func message() throws -> InspectableView<ViewType.Text> {
   97|      0|        return try View.supplementaryChildren(self).element(at: 1)
   98|      0|            .asInspectableView(ofType: ViewType.Text.self)
   99|      0|    }
  100|       |    
  101|      0|    func button(_ index: Int) throws -> InspectableView<ViewType.AlertButton> {
  102|      0|        let allViews = try View.supplementaryChildren(self)
  103|      0|        guard index >= 0 && index < allViews.count - 2 else {
  104|      0|            throw InspectionError.viewNotFound(parent: "button at index \(index)")
  105|      0|        }
  106|      0|        return try allViews.element(at: index + 2)
  107|      0|            .asInspectableView(ofType: ViewType.AlertButton.self)
  108|      0|    }
  109|       |}
  110|       |
  111|       |// MARK: - Non Standard Children
  112|       |
  113|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  114|       |extension ViewType.ActionSheet: SupplementaryChildren {
  115|      0|    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView> {
  116|      0|        let buttons = try Inspector.attribute(
  117|      0|            path: "sheet|buttons", value: parent.content.view, type: [Any].self)
  118|      0|        return .init(count: 2 + buttons.count) { index in
  119|      0|            let medium = parent.content.medium.resettingViewModifiers()
  120|      0|            switch index {
  121|      0|            case 0:
  122|      0|                let view = try Inspector.attribute(path: "sheet|title", value: parent.content.view)
  123|      0|                let content = try Inspector.unwrap(content: Content(view, medium: medium))
  124|      0|                return try InspectableView<ViewType.Text>(
  125|      0|                    content, parent: parent, call: "title()")
  126|      0|            case 1:
  127|      0|                let maybeView = try Inspector.attribute(
  128|      0|                    path: "sheet|message", value: parent.content.view, type: Text?.self)
  129|      0|                guard let view = maybeView else {
  130|      0|                    throw InspectionError.viewNotFound(parent: "message")
  131|      0|                }
  132|      0|                let content = try Inspector.unwrap(content: Content(view, medium: medium))
  133|      0|                return try InspectableView<ViewType.Text>(
  134|      0|                    content, parent: parent, call: "message()")
  135|      0|            default:
  136|      0|                let index = index - 2
  137|      0|                guard index >= 0 && index < buttons.count,
  138|      0|                      let view = buttons[index] as? Alert.Button else {
  139|      0|                    throw InspectionError.viewNotFound(parent: "button at index \(index)")
  140|      0|                }
  141|      0|                let content = try Inspector.unwrap(content: Content(view, medium: medium))
  142|      0|                return try InspectableView<ViewType.AlertButton>(
  143|      0|                    content, parent: parent, call: "button(\(index))")
  144|      0|            }
  145|      0|        }
  146|      0|    }
  147|       |}
  148|       |
  149|       |// MARK: - ActionSheet inspection protocols
  150|       |
  151|       |@available(iOS 13.0, tvOS 13.0, *)
  152|       |@available(macOS, unavailable)
  153|       |public protocol ActionSheetBuilder: SystemPopupPresenter {
  154|       |    func buildSheet() throws -> ActionSheet
  155|       |}
  156|       |
  157|       |@available(iOS 13.0, tvOS 13.0, *)
  158|       |@available(macOS, unavailable)
  159|       |public protocol ActionSheetProvider: ActionSheetBuilder {
  160|       |    var isPresented: Binding<Bool> { get }
  161|       |    var sheetBuilder: () -> ActionSheet { get }
  162|       |}
  163|       |
  164|       |@available(iOS 13.0, tvOS 13.0, *)
  165|       |@available(macOS, unavailable)
  166|       |public protocol ActionSheetItemProvider: ActionSheetBuilder {
  167|       |    associatedtype Item: Identifiable
  168|       |    var item: Binding<Item?> { get }
  169|       |    var sheetBuilder: (Item) -> ActionSheet { get }
  170|       |}
  171|       |
  172|       |@available(iOS 13.0, tvOS 13.0, *)
  173|       |@available(macOS, unavailable)
  174|       |public extension ActionSheetProvider {
  175|      0|    func buildSheet() throws -> ActionSheet {
  176|      0|        guard isPresented.wrappedValue else {
  177|      0|            throw InspectionError.viewNotFound(parent: "ActionSheet")
  178|      0|        }
  179|      0|        return sheetBuilder()
  180|      0|    }
  181|       |    
  182|      0|    func dismissPopup() {
  183|      0|        isPresented.wrappedValue = false
  184|      0|    }
  185|       |}
  186|       |
  187|       |@available(iOS 13.0, tvOS 13.0, *)
  188|       |@available(macOS, unavailable)
  189|       |public extension ActionSheetItemProvider {
  190|      0|    func buildSheet() throws -> ActionSheet {
  191|      0|        guard let value = item.wrappedValue else {
  192|      0|            throw InspectionError.viewNotFound(parent: "ActionSheet")
  193|      0|        }
  194|      0|        return sheetBuilder(value)
  195|      0|    }
  196|       |    
  197|      0|    func dismissPopup() {
  198|      0|        item.wrappedValue = nil
  199|      0|    }
  200|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Alert.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Alert
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension ViewType {
    7|       |    
    8|       |    struct Alert: KnownViewType {
    9|       |        public static var typePrefix: String = "ViewType.Alert.Container"
   10|      8|        public static var namespacedPrefixes: [String] {
   11|      8|            return ["ViewInspector." + typePrefix]
   12|      8|        }
   13|      0|        public static func inspectionCall(typeName: String) -> String {
   14|      0|            return "alert(\(ViewType.indexPlaceholder))"
   15|      0|        }
   16|       |    }
   17|       |}
   18|       |
   19|       |// MARK: - Extraction
   20|       |
   21|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   22|       |public extension InspectableView {
   23|       |
   24|      0|    func alert(_ index: Int? = nil) throws -> InspectableView<ViewType.Alert> {
   25|      0|        return try contentForModifierLookup.alert(parent: self, index: index)
   26|      0|    }
   27|       |}
   28|       |
   29|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   30|       |internal extension Content {
   31|       |    
   32|     98|    func alert(parent: UnwrappedView, index: Int?) throws -> InspectableView<ViewType.Alert> {
   33|     98|        guard let alertBuilder = try? self.modifierAttribute(
   34|    212|                modifierLookup: { isAlertBuilder(modifier: $0) }, path: "modifier",
   35|      0|                type: AlertBuilder.self, call: "", index: index ?? 0)
   36|     98|        else {
   37|    212|            _ = try self.modifier({
   38|    212|                $0.modifierType == "IdentifiedPreferenceTransformModifier<Key>"
   39|    212|                || $0.modifierType.contains("AlertTransformModifier")
   40|    212|            }, call: "alert")
   41|     98|            throw InspectionError.notSupported(
   42|     98|                """
   43|     98|                Please refer to the Guide for inspecting the Alert: \
   44|     98|                https://github.com/nalexn/ViewInspector/blob/master/guide.md#alert-sheet-and-actionsheet
   45|     98|                """)
   46|      0|        }
   47|      0|        let alert = try alertBuilder.buildAlert()
   48|      0|        let container = ViewType.Alert.Container(alert: alert, builder: alertBuilder)
   49|      0|        let medium = self.medium.resettingViewModifiers()
   50|      0|        let content = Content(container, medium: medium)
   51|      0|        let call = ViewType.inspectionCall(
   52|      0|            base: ViewType.Alert.inspectionCall(typeName: ""), index: index)
   53|      0|        return try .init(content, parent: parent, call: call, index: index)
   54|     98|    }
   55|       |    
   56|    124|    func alertsForSearch() -> [ViewSearch.ModifierIdentity] {
   57|    124|        let count = medium.viewModifiers
   58|    114|            .compactMap { isAlertBuilder(modifier: $0) }
   59|    124|            .count
   60|    114|        return Array(0..<count).map { _ in
   61|     98|            .init(name: "", builder: { parent, index in
   62|     98|                try parent.content.alert(parent: parent, index: index)
   63|     98|            })
   64|    114|        }
   65|    124|    }
   66|       |    
   67|    326|    private func isAlertBuilder(modifier: Any) -> Bool {
   68|    326|        return (try? Inspector.attribute(
   69|    326|            label: "modifier", value: modifier, type: AlertBuilder.self)) != nil
   70|    326|    }
   71|       |}
   72|       |
   73|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   74|       |internal extension ViewType.Alert {
   75|       |    struct Container: CustomViewIdentityMapping {
   76|       |        let alert: SwiftUI.Alert
   77|       |        let builder: AlertBuilder
   78|       |        
   79|      0|        var viewTypeForSearch: KnownViewType.Type { ViewType.Alert.self }
   80|       |    }
   81|       |}
   82|       |
   83|       |// MARK: - Custom Attributes
   84|       |
   85|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   86|       |public extension InspectableView where View == ViewType.Alert {
   87|       |
   88|      0|    func title() throws -> InspectableView<ViewType.Text> {
   89|      0|        return try View.supplementaryChildren(self).element(at: 0)
   90|      0|            .asInspectableView(ofType: ViewType.Text.self)
   91|      0|    }
   92|       |    
   93|      0|    func message() throws -> InspectableView<ViewType.Text> {
   94|      0|        return try View.supplementaryChildren(self).element(at: 1)
   95|      0|            .asInspectableView(ofType: ViewType.Text.self)
   96|      0|    }
   97|       |    
   98|      0|    func primaryButton() throws -> InspectableView<ViewType.AlertButton> {
   99|      0|        return try View.supplementaryChildren(self).element(at: 2)
  100|      0|            .asInspectableView(ofType: ViewType.AlertButton.self)
  101|      0|    }
  102|       |    
  103|      0|    func secondaryButton() throws -> InspectableView<ViewType.AlertButton> {
  104|      0|        return try View.supplementaryChildren(self).element(at: 3)
  105|      0|            .asInspectableView(ofType: ViewType.AlertButton.self)
  106|      0|    }
  107|       |}
  108|       |
  109|       |// MARK: - Non Standard Children
  110|       |
  111|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  112|       |extension ViewType.Alert: SupplementaryChildren {
  113|      0|    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView> {
  114|      0|        return .init(count: 4) { index in
  115|      0|            let medium = parent.content.medium.resettingViewModifiers()
  116|      0|            switch index {
  117|      0|            case 0:
  118|      0|                let view = try Inspector.attribute(path: "alert|title", value: parent.content.view)
  119|      0|                let content = try Inspector.unwrap(content: Content(view, medium: medium))
  120|      0|                return try InspectableView<ViewType.Text>(
  121|      0|                    content, parent: parent, call: "title()")
  122|      0|            case 1:
  123|      0|                let maybeView = try Inspector.attribute(
  124|      0|                    path: "alert|message", value: parent.content.view, type: Text?.self)
  125|      0|                guard let view = maybeView else {
  126|      0|                    throw InspectionError.viewNotFound(parent: "message")
  127|      0|                }
  128|      0|                let content = try Inspector.unwrap(content: Content(view, medium: medium))
  129|      0|                return try InspectableView<ViewType.Text>(
  130|      0|                    content, parent: parent, call: "message()")
  131|      0|            case 2:
  132|      0|                let view = try Inspector.attribute(path: "alert|primaryButton", value: parent.content.view)
  133|      0|                let content = try Inspector.unwrap(content: Content(view, medium: medium))
  134|      0|                return try InspectableView<ViewType.AlertButton>(
  135|      0|                    content, parent: parent, call: "primaryButton()")
  136|      0|            default:
  137|      0|                let maybeView = try Inspector.attribute(
  138|      0|                    path: "alert|secondaryButton", value: parent.content.view, type: Alert.Button?.self)
  139|      0|                guard let view = maybeView else {
  140|      0|                    throw InspectionError.viewNotFound(parent: "secondaryButton")
  141|      0|                }
  142|      0|                let content = try Inspector.unwrap(content: Content(view, medium: medium))
  143|      0|                return try InspectableView<ViewType.AlertButton>(
  144|      0|                    content, parent: parent, call: "secondaryButton()")
  145|      0|            }
  146|      0|        }
  147|      0|    }
  148|       |}
  149|       |
  150|       |// MARK: - AlertButton
  151|       |
  152|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  153|       |public extension ViewType {
  154|       |    
  155|       |    struct AlertButton: KnownViewType {
  156|       |        public static var typePrefix: String = "Alert.Button"
  157|       |    }
  158|       |}
  159|       |
  160|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  161|       |extension SwiftUI.Alert.Button: CustomViewIdentityMapping {
  162|      0|    var viewTypeForSearch: KnownViewType.Type { ViewType.AlertButton.self }
  163|       |}
  164|       |
  165|       |// MARK: - Non Standard Children
  166|       |
  167|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  168|       |extension ViewType.AlertButton: SupplementaryChildren {
  169|      0|    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView> {
  170|      0|        return .init(count: 1) { _ in
  171|      0|            let child = try Inspector.attribute(path: "label", value: parent.content.view)
  172|      0|            let medium = parent.content.medium.resettingViewModifiers()
  173|      0|            let content = try Inspector.unwrap(content: Content(child, medium: medium))
  174|      0|            return try InspectableView<ViewType.Text>(content, parent: parent, call: "labelView()")
  175|      0|        }
  176|      0|    }
  177|       |}
  178|       |
  179|       |// MARK: - Custom Attributes
  180|       |
  181|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  182|       |public extension Alert.Button {
  183|       |    enum Style: String {
  184|       |        case `default`, cancel, destructive
  185|       |    }
  186|       |}
  187|       |
  188|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  189|       |public extension InspectableView where View == ViewType.AlertButton {
  190|       |    
  191|      0|    func labelView() throws -> InspectableView<ViewType.Text> {
  192|      0|        return try View.supplementaryChildren(self).element(at: 0)
  193|      0|            .asInspectableView(ofType: ViewType.Text.self)
  194|      0|    }
  195|       |    
  196|      0|    func style() throws -> Alert.Button.Style {
  197|      0|        let value = try Inspector.attribute(label: "style", value: content.view)
  198|      0|        let stringValue = String(describing: value)
  199|      0|        guard let style = Alert.Button.Style(rawValue: stringValue) else {
  200|      0|            throw InspectionError.notSupported("Unknown Alert.Button.Style: \(stringValue)")
  201|      0|        }
  202|      0|        return style
  203|      0|    }
  204|       |    
  205|      0|    func tap() throws {
  206|      0|        guard let container = self.parentView?.content.view,
  207|      0|            let presenter = try? Inspector.attribute(
  208|      0|                label: "builder", value: container,
  209|      0|                type: SystemPopupPresenter.self)
  210|      0|        else { throw InspectionError.parentViewNotFound(view: "Alert.Button") }
  211|      0|        presenter.dismissPopup()
  212|      0|        typealias Callback = () -> Void
  213|      0|        let callback = try Inspector
  214|      0|            .attribute(label: "action", value: content.view, type: Callback.self)
  215|      0|        callback()
  216|      0|    }
  217|       |}
  218|       |
  219|       |// MARK: - Alert inspection protocols
  220|       |
  221|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  222|       |public protocol SystemPopupPresenter {
  223|       |    func dismissPopup()
  224|       |}
  225|       |
  226|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  227|       |public protocol AlertBuilder: SystemPopupPresenter {
  228|       |    func buildAlert() throws -> Alert
  229|       |}
  230|       |
  231|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  232|       |public protocol AlertProvider: AlertBuilder {
  233|       |    var isPresented: Binding<Bool> { get }
  234|       |    var alertBuilder: () -> Alert { get }
  235|       |}
  236|       |
  237|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  238|       |public protocol AlertItemProvider: AlertBuilder {
  239|       |    associatedtype Item: Identifiable
  240|       |    var item: Binding<Item?> { get }
  241|       |    var alertBuilder: (Item) -> Alert { get }
  242|       |}
  243|       |
  244|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  245|       |public extension AlertProvider {
  246|      0|    func buildAlert() throws -> Alert {
  247|      0|        guard isPresented.wrappedValue else {
  248|      0|            throw InspectionError.viewNotFound(parent: "Alert")
  249|      0|        }
  250|      0|        return alertBuilder()
  251|      0|    }
  252|       |    
  253|      0|    func dismissPopup() {
  254|      0|        isPresented.wrappedValue = false
  255|      0|    }
  256|       |}
  257|       |
  258|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  259|       |public extension AlertItemProvider {
  260|      0|    func buildAlert() throws -> Alert {
  261|      0|        guard let value = item.wrappedValue else {
  262|      0|            throw InspectionError.viewNotFound(parent: "Alert")
  263|      0|        }
  264|      0|        return alertBuilder(value)
  265|      0|    }
  266|       |    
  267|      0|    func dismissPopup() {
  268|      0|        item.wrappedValue = nil
  269|      0|    }
  270|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/AngularGradient.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct AngularGradient: KnownViewType {
    7|       |        public static var typePrefix: String = "AngularGradient"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func angularGradient() throws -> InspectableView<ViewType.AngularGradient> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func angularGradient(_ index: Int) throws -> InspectableView<ViewType.AngularGradient> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Custom Attributes
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |public extension InspectableView where View == ViewType.AngularGradient {
   35|       |    
   36|      0|    func gradient() throws -> Gradient {
   37|      0|        return try Inspector
   38|      0|            .attribute(label: "gradient", value: content.view, type: Gradient.self)
   39|      0|    }
   40|       |    
   41|      0|    func center() throws -> UnitPoint {
   42|      0|        return try Inspector
   43|      0|            .attribute(label: "center", value: content.view, type: UnitPoint.self)
   44|      0|    }
   45|       |    
   46|      0|    func startAngle() throws -> Angle {
   47|      0|        return try Inspector
   48|      0|            .attribute(label: "startAngle", value: content.view, type: Angle.self)
   49|      0|    }
   50|       |    
   51|      0|    func endAngle() throws -> Angle {
   52|      0|        return try Inspector
   53|      0|            .attribute(label: "endAngle", value: content.view, type: Angle.self)
   54|      0|    }
   55|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/AnyView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct AnyView: KnownViewType {
    7|       |        public static var typePrefix: String = "AnyView"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.AnyView: SingleViewContent {
   15|       |    
   16|     19|    public static func child(_ content: Content) throws -> Content {
   17|     19|        let view = try Inspector.attribute(path: "storage|view", value: content.view)
   18|     19|        let medium = content.medium.resettingViewModifiers()
   19|     19|        return try Inspector.unwrap(view: view, medium: medium)
   20|     19|    }
   21|       |}
   22|       |
   23|       |// MARK: - Extraction from SingleViewContent parent
   24|       |
   25|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   26|       |public extension InspectableView where View: SingleViewContent {
   27|       |    
   28|      0|    func anyView() throws -> InspectableView<ViewType.AnyView> {
   29|      0|        return try .init(try child(), parent: self)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Extraction from MultipleViewContent parent
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |public extension InspectableView where View: MultipleViewContent {
   37|       |    
   38|      0|    func anyView(_ index: Int) throws -> InspectableView<ViewType.AnyView> {
   39|      0|        return try .init(try child(at: index), parent: self, index: index)
   40|      0|    }
   41|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Button.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Button: KnownViewType {
    7|       |        public static var typePrefix: String = "Button"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func button() throws -> InspectableView<ViewType.Button> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      1|    func button(_ index: Int) throws -> InspectableView<ViewType.Button> {
   27|      1|        return try .init(try child(at: index), parent: self, index: index)
   28|      1|    }
   29|       |}
   30|       |
   31|       |// MARK: - Non Standard Children
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.Button: SupplementaryChildrenLabelView {
   35|      4|    static var labelViewPath: String { "_label" }
   36|       |}
   37|       |
   38|       |// MARK: - Custom Attributes
   39|       |
   40|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   41|       |public extension InspectableView where View == ViewType.Button {
   42|       |    
   43|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   44|      0|        return try View.supplementaryChildren(self).element(at: 0)
   45|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   46|      0|    }
   47|       |    
   48|      1|    func tap() throws {
   49|      1|        try guardIsResponsive()
   50|      1|        typealias Callback = () -> Void
   51|      1|        let callback = try Inspector
   52|      1|            .attribute(label: "action", value: content.view, type: Callback.self)
   53|      1|        callback()
   54|      1|    }
   55|       |}
   56|       |
   57|       |// MARK: - Global View Modifiers
   58|       |
   59|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   60|       |public extension InspectableView {
   61|       |
   62|      0|    func buttonStyle() throws -> Any {
   63|      0|        let modifier = try self.modifier({ modifier -> Bool in
   64|      0|            return modifier.modifierType.hasPrefix("ButtonStyleModifier")
   65|      0|        }, call: "buttonStyle")
   66|      0|        if let style = try? Inspector.attribute(path: "modifier|style|style", value: modifier) {
   67|      0|            return style
   68|      0|        }
   69|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   70|      0|    }
   71|       |}
   72|       |
   73|       |// MARK: - ButtonStyle and PrimitiveButtonStyle inspection
   74|       |
   75|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   76|       |public extension ButtonStyle {
   77|      0|    func inspect(isPressed: Bool) throws -> InspectableView<ViewType.ClassifiedView> {
   78|      0|        let config = ButtonStyleConfiguration(isPressed: isPressed)
   79|      0|        let view = try makeBody(configuration: config).inspect()
   80|      0|        return try .init(view.content, parent: nil, index: nil)
   81|      0|    }
   82|       |}
   83|       |
   84|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   85|       |public extension PrimitiveButtonStyle {
   86|      0|    func inspect(onTrigger: @escaping () -> Void = { }) throws -> InspectableView<ViewType.ClassifiedView> {
   87|      0|        let config = PrimitiveButtonStyleConfiguration(onTrigger: onTrigger)
   88|      0|        return try makeBody(configuration: config).inspect()
   89|      0|    }
   90|       |}
   91|       |
   92|       |// MARK: - Style Configuration initializers
   93|       |
   94|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   95|       |internal extension ButtonStyleConfiguration {
   96|       |    private struct Allocator {
   97|       |        let data: (Int64, Int64, Int64)
   98|      0|        init(flag: Bool) {
   99|      0|            data = (flag ? -1 : 0, 0, 0)
  100|      0|        }
  101|       |    }
  102|      0|    init(isPressed: Bool) {
  103|      0|        self = unsafeBitCast(Allocator(flag: isPressed), to: Self.self)
  104|      0|    }
  105|       |}
  106|       |
  107|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  108|       |public extension PrimitiveButtonStyleConfiguration {
  109|       |    private struct Allocator {
  110|       |        let onTrigger: () -> Void
  111|       |    }
  112|      0|    init(onTrigger: @escaping () -> Void) {
  113|      0|        self = unsafeBitCast(Allocator(onTrigger: onTrigger), to: Self.self)
  114|      0|    }
  115|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ClassifiedView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct ClassifiedView: KnownViewType {
    7|       |        public static var typePrefix: String = ""
    8|      0|        public static var isTransitive: Bool { true }
    9|       |    }
   10|       |    
   11|       |    struct ParentView: KnownViewType {
   12|       |        public static var typePrefix: String = ""
   13|       |    }
   14|       |}
   15|       |
   16|       |// MARK: - Content Extraction
   17|       |
   18|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   19|       |extension ViewType.ClassifiedView: SingleViewContent {
   20|       |    
   21|      1|    public static func child(_ content: Content) throws -> Content {
   22|      1|        return content
   23|      1|    }
   24|       |}
   25|       |
   26|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   27|       |extension ViewType.ParentView: SingleViewContent {
   28|       |    
   29|      0|    public static func child(_ content: Content) throws -> Content {
   30|      0|        return content
   31|      0|    }
   32|       |}
   33|       |
   34|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   35|       |extension ViewType.ClassifiedView: MultipleViewContent {
   36|       |    
   37|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   38|      0|        return try Inspector.viewsInContainer(view: content.view, medium: content.medium)
   39|      0|    }
   40|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Color.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Color: KnownViewType {
    7|       |        public static var typePrefix: String = "Color"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func color() throws -> InspectableView<ViewType.Color> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func color(_ index: Int) throws -> InspectableView<ViewType.Color> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Custom Attributes
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |public extension InspectableView where View == ViewType.Color {
   35|       |    
   36|      0|    func value() throws -> Color {
   37|      0|        return try Inspector.cast(value: content.view, type: Color.self)
   38|      0|    }
   39|       |    
   40|      0|    func rgba() throws -> (red: Float, green: Float, blue: Float, alpha: Float) {
   41|      0|        let colorProvider = try Inspector.attribute(path: "provider|base", value: content.view)
   42|      0|        let providerName = Inspector.typeName(value: colorProvider)
   43|      0|        if providerName == "_Resolved" {
   44|      0|            let red = try Inspector.attribute(label: "linearRed", value: colorProvider, type: Float.self)
   45|      0|            let green = try Inspector.attribute(label: "linearGreen", value: colorProvider, type: Float.self)
   46|      0|            let blue = try Inspector.attribute(label: "linearBlue", value: colorProvider, type: Float.self)
   47|      0|            let alpha = try Inspector.attribute(label: "opacity", value: colorProvider, type: Float.self)
   48|      0|            return (red, green, blue, alpha)
   49|      0|        }
   50|      0|        if providerName == "DisplayP3" {
   51|      0|            let red = try Inspector.attribute(label: "red", value: colorProvider, type: CGFloat.self)
   52|      0|            let green = try Inspector.attribute(label: "green", value: colorProvider, type: CGFloat.self)
   53|      0|            let blue = try Inspector.attribute(label: "blue", value: colorProvider, type: CGFloat.self)
   54|      0|            let alpha = try Inspector.attribute(label: "opacity", value: colorProvider, type: Float.self)
   55|      0|            return (Float(red), Float(green), Float(blue), alpha)
   56|      0|        }
   57|      0|        throw InspectionError.notSupported("RGBA values are not available")
   58|      0|    }
   59|       |    
   60|      0|    func name() throws -> String {
   61|      0|        let colorProvider = try Inspector.attribute(path: "provider|base", value: content.view)
   62|      0|        let providerName = Inspector.typeName(value: colorProvider)
   63|      0|        if providerName == "NamedColor" {
   64|      0|            return try Inspector.attribute(label: "name", value: colorProvider, type: String.self)
   65|      0|        }
   66|      0|        throw InspectionError.notSupported("Color name is not available")
   67|      0|    }
   68|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ColorPicker.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct ColorPicker: KnownViewType {
    7|       |        public static var typePrefix: String = "ColorPicker"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, *)
   14|       |@available(tvOS, unavailable)
   15|       |public extension InspectableView where View: SingleViewContent {
   16|       |    
   17|      0|    func colorPicker() throws -> InspectableView<ViewType.ColorPicker> {
   18|      0|        return try .init(try child(), parent: self)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from MultipleViewContent parent
   23|       |
   24|       |@available(iOS 14.0, macOS 11.0, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func colorPicker(_ index: Int) throws -> InspectableView<ViewType.ColorPicker> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Non Standard Children
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |extension ViewType.ColorPicker: SupplementaryChildrenLabelView { }
   37|       |
   38|       |// MARK: - Custom Attributes
   39|       |
   40|       |@available(iOS 14.0, macOS 11.0, *)
   41|       |@available(tvOS, unavailable)
   42|       |public extension InspectableView where View == ViewType.ColorPicker {
   43|       |    
   44|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   45|      0|        return try View.supplementaryChildren(self).element(at: 0)
   46|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   47|      0|    }
   48|       |    
   49|       |    @available(tvOS 14.0, *)
   50|      0|    func select(color: Color) throws {
   51|      0|        try guardIsResponsive()
   52|      0|        #if os(macOS)
   53|      0|        try select(color: NSColor(color))
   54|      0|        #else
   55|      0|        try select(color: UIColor(color))
   56|      0|        #endif
   57|      0|    }
   58|       |    
   59|      0|    func select(color: CGColor) throws {
   60|      0|        try guardIsResponsive()
   61|      0|        #if os(macOS)
   62|      0|        try select(color: NSColor(cgColor: color)!)
   63|      0|        #else
   64|      0|        try select(color: UIColor(cgColor: color))
   65|      0|        #endif
   66|      0|    }
   67|       |    
   68|       |    #if os(macOS)
   69|       |    func select(color: NSColor) throws {
   70|       |        try guardIsResponsive()
   71|       |        let binding = try Inspector.attribute(label: "_color", value: content.view, type: Binding<NSColor>.self)
   72|       |        binding.wrappedValue = color
   73|       |    }
   74|       |    #else
   75|      0|    func select(color: UIColor) throws {
   76|      0|        try guardIsResponsive()
   77|      0|        let binding = try Inspector.attribute(label: "_color", value: content.view, type: Binding<UIColor>.self)
   78|      0|        binding.wrappedValue = color
   79|      0|    }
   80|       |    #endif
   81|       |}
   82|       |
   83|       |@available(iOS 14.0, macOS 11.0, *)
   84|       |@available(tvOS, unavailable)
   85|       |public extension ViewType.ColorPicker {
   86|       |    /**
   87|       |     A container for comparing colors in tests. FYI: Color.red != UIColor.red
   88|       |     */
   89|       |    struct RGBA: Equatable {
   90|       |        
   91|       |        var red: CGFloat = 0
   92|       |        var green: CGFloat = 0
   93|       |        var blue: CGFloat = 0
   94|       |        var alpha: CGFloat = 0
   95|       |        
   96|      0|        init(color: CGColor) {
   97|      0|            #if os(macOS)
   98|      0|            self.init(color: NSColor(cgColor: color)!)
   99|      0|            #else
  100|      0|            self.init(color: UIColor(cgColor: color))
  101|      0|            #endif
  102|      0|        }
  103|       |        
  104|       |        @available(tvOS 14.0, *)
  105|      0|        init(color: Color) {
  106|      0|            #if os(macOS)
  107|      0|            self.init(color: NSColor(color))
  108|      0|            #else
  109|      0|            self.init(color: UIColor(color))
  110|      0|            #endif
  111|      0|        }
  112|       |        
  113|       |        #if os(macOS)
  114|       |        init(color: NSColor) {
  115|       |            let color = color.usingColorSpace(.deviceRGB) ?? color
  116|       |            red = color.redComponent
  117|       |            green = color.greenComponent
  118|       |            blue = color.blueComponent
  119|       |            alpha = color.alphaComponent
  120|       |        }
  121|       |        #else
  122|      0|        init(color: UIColor) {
  123|      0|            color.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
  124|      0|        }
  125|       |        #endif
  126|       |        
  127|      0|        public static func == (lhs: RGBA, rhs: RGBA) -> Bool {
  128|      0|            let compareComponent: (CGFloat, CGFloat) -> Bool = { value1, value2 in
  129|      0|                return abs(value1 - value2) < 1 / 256
  130|      0|            }
  131|      0|            return compareComponent(lhs.red, rhs.red)
  132|      0|                && compareComponent(lhs.green, rhs.green)
  133|      0|                && compareComponent(lhs.blue, rhs.blue)
  134|      0|                && compareComponent(lhs.alpha, rhs.alpha)
  135|      0|        }
  136|       |    }
  137|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ConditionalContent.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType {
    5|       |    struct ConditionalContent { }
    6|       |}
    7|       |
    8|       |// MARK: - Content Extraction
    9|       |
   10|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   11|       |extension ViewType.ConditionalContent: SingleViewContent {
   12|       |    
   13|      0|    static func child(_ content: Content) throws -> Content {
   14|      0|        let storage = try Inspector.attribute(label: "storage", value: content.view)
   15|      0|        let medium = content.medium.resettingViewModifiers()
   16|      0|        if let trueContent = try? Inspector.attribute(label: "trueContent", value: storage) {
   17|      0|            return try Inspector.unwrap(view: trueContent, medium: medium)
   18|      0|        }
   19|      0|        let falseContent = try Inspector.attribute(label: "falseContent", value: storage)
   20|      0|        return try Inspector.unwrap(view: falseContent, medium: medium)
   21|      0|    }
   22|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/CustomView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public protocol CustomViewType {
    5|       |    associatedtype T: Inspectable
    6|       |}
    7|       |
    8|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    9|       |public extension ViewType {
   10|       |    
   11|       |    struct View<T>: KnownViewType, CustomViewType where T: Inspectable {
   12|    177|        public static var typePrefix: String {
   13|    177|            guard T.self != ViewType.Stub.self
   14|    146|            else { return "" }
   15|    146|            return Inspector.typeName(type: T.self, prefixOnly: true)
   16|    177|        }
   17|       |        
   18|    216|        public static var namespacedPrefixes: [String] {
   19|    216|            guard T.self != ViewType.Stub.self
   20|    185|            else { return [] }
   21|    185|            return [Inspector.typeName(type: T.self, namespaced: true, prefixOnly: true)]
   22|    216|        }
   23|       |        
   24|     32|        public static func inspectionCall(typeName: String) -> String {
   25|     32|            return "view(\(typeName).self\(ViewType.commaPlaceholder)\(ViewType.indexPlaceholder))"
   26|     32|        }
   27|       |    }
   28|       |}
   29|       |
   30|       |// MARK: - Content Extraction
   31|       |
   32|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   33|       |extension ViewType.View: SingleViewContent {
   34|       |    
   35|     11|    public static func child(_ content: Content) throws -> Content {
   36|     11|        return try content.extractCustomView()
   37|     11|    }
   38|       |}
   39|       |
   40|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   41|       |extension ViewType.View: MultipleViewContent {
   42|       |    
   43|     25|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   44|     25|        return try content.extractCustomViewGroup()
   45|     25|    }
   46|       |}
   47|       |
   48|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   49|       |internal extension Content {
   50|    306|    var isCustomView: Bool {
   51|    306|        return view is Inspectable
   52|    306|    }
   53|       |    
   54|     95|    func extractCustomView() throws -> Content {
   55|     95|        let inspectable = try Inspector.cast(value: view, type: Inspectable.self)
   56|     95|        let view = try inspectable.extractContent(environmentObjects: medium.environmentObjects)
   57|     95|        let medium = self.medium.resettingViewModifiers()
   58|     95|        return try Inspector.unwrap(view: view, medium: medium)
   59|     95|    }
   60|       |    
   61|     44|    func extractCustomViewGroup() throws -> LazyGroup<Content> {
   62|     44|        let inspectable = try Inspector.cast(value: view, type: Inspectable.self)
   63|     44|        let view = try inspectable.extractContent(environmentObjects: medium.environmentObjects)
   64|     44|        return try Inspector.viewsInContainer(view: view, medium: medium)
   65|     44|    }
   66|       |}
   67|       |
   68|       |// MARK: - Extraction from SingleViewContent parent
   69|       |
   70|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   71|       |public extension InspectableView where View: SingleViewContent {
   72|       |    
   73|      1|    func view<T>(_ type: T.Type) throws -> InspectableView<ViewType.View<T>> where T: Inspectable {
   74|      1|        let child = try View.child(content)
   75|      1|        let prefix = Inspector.typeName(type: type, namespaced: true, prefixOnly: true)
   76|      1|        let base = ViewType.View<T>.inspectionCall(typeName: Inspector.typeName(type: type))
   77|      1|        let call = ViewType.inspectionCall(base: base, index: nil)
   78|      1|        try Inspector.guardType(value: child.view, namespacedPrefixes: [prefix], inspectionCall: call)
   79|      1|        return try .init(child, parent: self, call: call)
   80|      1|    }
   81|       |}
   82|       |
   83|       |// MARK: - Extraction from MultipleViewContent parent
   84|       |
   85|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   86|       |public extension InspectableView where View: MultipleViewContent {
   87|       |    
   88|      0|    func view<T>(_ type: T.Type, _ index: Int) throws -> InspectableView<ViewType.View<T>> where T: Inspectable {
   89|      0|        let content = try child(at: index)
   90|      0|        let prefix = Inspector.typeName(type: type, namespaced: true, prefixOnly: true)
   91|      0|        let base = ViewType.View<T>.inspectionCall(typeName: Inspector.typeName(type: type))
   92|      0|        let call = ViewType.inspectionCall(base: base, index: index)
   93|      0|        try Inspector.guardType(value: content.view, namespacedPrefixes: [prefix], inspectionCall: call)
   94|      0|        return try .init(content, parent: self, call: call)
   95|      0|    }
   96|       |}
   97|       |
   98|       |// MARK: - Custom Attributes
   99|       |
  100|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  101|       |public extension InspectableView where View: CustomViewType {
  102|       |    
  103|      1|    func actualView() throws -> View.T {
  104|      1|        return try Inspector.cast(value: content.view, type: View.T.self)
  105|      1|    }
  106|       |}
  107|       |
  108|       |#if os(macOS)
  109|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  110|       |public extension NSViewRepresentable where Self: Inspectable {
  111|       |    func nsView() throws -> NSViewType {
  112|       |        return try ViewHosting.lookup(Self.self)
  113|       |    }
  114|       |}
  115|       |
  116|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  117|       |public extension NSViewControllerRepresentable where Self: Inspectable {
  118|       |    func viewController() throws -> NSViewControllerType {
  119|       |        return try ViewHosting.lookup(Self.self)
  120|       |    }
  121|       |}
  122|       |
  123|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  124|       |public extension Inspectable where Self: NSViewRepresentable {
  125|       |    func extractContent(environmentObjects: [AnyObject]) throws -> Any {
  126|       |        throw InspectionError.notSupported(
  127|       |            "Please use `.actualView().nsView()` for inspecting the contents of NSViewRepresentable")
  128|       |    }
  129|       |}
  130|       |
  131|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  132|       |public extension Inspectable where Self: NSViewControllerRepresentable {
  133|       |    func extractContent(environmentObjects: [AnyObject]) throws -> Any {
  134|       |        throw InspectionError.notSupported(
  135|       |            "Please use `.actualView().viewController()` for inspecting the contents of NSViewControllerRepresentable")
  136|       |    }
  137|       |}
  138|       |#else
  139|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  140|       |public extension UIViewRepresentable where Self: Inspectable {
  141|      0|    func uiView() throws -> UIViewType {
  142|      0|        return try ViewHosting.lookup(Self.self)
  143|      0|    }
  144|       |}
  145|       |
  146|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  147|       |public extension UIViewControllerRepresentable where Self: Inspectable {
  148|      0|    func viewController() throws -> UIViewControllerType {
  149|      0|        return try ViewHosting.lookup(Self.self)
  150|      0|    }
  151|       |}
  152|       |
  153|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  154|       |public extension Inspectable where Self: UIViewRepresentable {
  155|      6|    func extractContent(environmentObjects: [AnyObject]) throws -> Any {
  156|      6|        throw InspectionError.notSupported(
  157|      6|            "Please use `.actualView().uiView()` for inspecting the contents of UIViewRepresentable")
  158|      6|    }
  159|       |}
  160|       |
  161|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  162|       |public extension Inspectable where Self: UIViewControllerRepresentable {
  163|      0|    func extractContent(environmentObjects: [AnyObject]) throws -> Any {
  164|      0|        throw InspectionError.notSupported(
  165|      0|            "Please use `.actualView().viewController()` for inspecting the contents of UIViewControllerRepresentable")
  166|      0|    }
  167|       |}
  168|       |#endif

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/CustomViewModifier.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct ViewModifier<T>: KnownViewType, CustomViewType where T: Inspectable {
    7|       |        
    8|     40|        public static var typePrefix: String { "" }
    9|       |        
   10|     40|        public static var namespacedPrefixes: [String] { [] }
   11|       |        
   12|     38|        public static func inspectionCall(typeName: String) -> String {
   13|     38|            return "modifier(\(typeName).self\(ViewType.commaPlaceholder)\(ViewType.indexPlaceholder))"
   14|     38|        }
   15|       |    }
   16|       |}
   17|       |
   18|       |// MARK: - Extraction from SingleViewContent parent
   19|       |
   20|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   21|       |public extension InspectableView {
   22|       |    
   23|       |    func modifier<T>(_ type: T.Type, _ index: Int? = nil) throws -> InspectableView<ViewType.ViewModifier<T>>
   24|      0|    where T: ViewModifier, T: Inspectable {
   25|      0|        let name = Inspector.typeName(type: type)
   26|      0|        guard let view = content.medium.viewModifiers.reversed().compactMap({ modifier in
   27|      0|            try? Inspector.attribute(label: "modifier", value: modifier, type: type)
   28|      0|        }).dropFirst(index ?? 0).first else {
   29|      0|            throw InspectionError.modifierNotFound(
   30|      0|                parent: Inspector.typeName(value: content.view),
   31|      0|                modifier: name, index: index ?? 0)
   32|      0|        }
   33|      0|        let medium = content.medium.resettingViewModifiers()
   34|      0|        let modifierContent = try Inspector.unwrap(view: view, medium: medium)
   35|      0|        let base = ViewType.ViewModifier<T>.inspectionCall(typeName: name)
   36|      0|        let call = ViewType.inspectionCall(base: base, index: index)
   37|      0|        return try .init(modifierContent, parent: self, call: call)
   38|      0|    }
   39|       |}
   40|       |
   41|       |// MARK: - Children
   42|       |
   43|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   44|       |extension ViewType.ViewModifier: SingleViewContent {
   45|       |    
   46|    280|    public static func child(_ content: Content) throws -> Content {
   47|    280|        if content.isCustomView {
   48|      2|            return try content.extractCustomView()
   49|    278|        }
   50|    278|        return try content.unwrappedModifiedContent()
   51|    280|    }
   52|       |}
   53|       |
   54|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   55|       |extension ViewType.ViewModifier: MultipleViewContent {
   56|       |    
   57|     19|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   58|     19|        return try content.extractCustomViewGroup()
   59|     19|    }
   60|       |}
   61|       |
   62|       |// MARK: - Internal
   63|       |
   64|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   65|       |internal extension Content {
   66|    278|    func unwrappedModifiedContent() throws -> Content {
   67|    278|        let view = try Inspector.attribute(label: "content", value: self.view)
   68|    278|        var medium: Content.Medium
   69|     27|        if let modifier = self.view as? EnvironmentModifier {
   70|     27|            if let value = try? modifier.value(),
   71|     27|               let object = try? Inspector.attribute(label: "some", value: value, type: AnyObject.self),
   72|      0|               !(object is NSObject) {
   73|      0|                medium = self.medium.appending(environmentObject: object)
   74|     27|            } else {
   75|     27|                medium = self.medium.appending(environmentModifier: modifier)
   76|     27|            }
   77|    278|        } else if let modifier = self.view as? PossiblyTransitiveModifier,
   78|      0|                  modifier.isTransitive() {
   79|      0|            medium = self.medium.appending(transitiveViewModifier: modifier)
   80|    278|        } else {
   81|    278|            medium = self.medium.appending(viewModifier: self.view)
   82|    278|            if let modifier = (self.view as? ModifierNameProvider)?.customModifier,
   83|    278|               let modifierBodyContent = try? Content(modifier, medium: self.medium).extractCustomView(),
   84|    278|               let modifierBodyView = try? InspectableView<ViewType.ClassifiedView>(modifierBodyContent, parent: nil),
   85|     26|               let viewModifierContent = try? modifierBodyView.find(ViewType.ViewModifierContent.self) {
   86|    182|                let overlayModifiers = Set(ViewSearch.modifierIdentities.map({ $0.name }))
   87|     26|                viewModifierContent.content.medium.viewModifiers
   88|     26|                    .filter { modifier in
   89|     26|                        return (modifier as? ModifierNameProvider)
   90|     26|                            .map { $0.modifierType(prefixOnly: true) }
   91|     26|                            .map { !overlayModifiers.contains($0) } ?? true
   92|     26|                    }
   93|     26|                    .forEach {
   94|     26|                        medium = medium.appending(viewModifier: $0)
   95|     26|                    }
   96|      0|                viewModifierContent.content.medium.transitiveViewModifiers.forEach {
   97|      0|                    medium = medium.appending(transitiveViewModifier: $0)
   98|      0|                }
   99|     26|                viewModifierContent.content.medium.environmentModifiers.forEach {
  100|     26|                    medium = medium.appending(environmentModifier: $0)
  101|     26|                }
  102|      0|                viewModifierContent.content.medium.environmentObjects.forEach {
  103|      0|                    medium = medium.appending(environmentObject: $0)
  104|      0|                }
  105|    278|            }
  106|    278|        }
  107|    278|        return try Inspector.unwrap(view: view, medium: medium)
  108|    278|    }
  109|       |
  110|    124|    func customViewModifiers() -> [Inspectable] {
  111|    114|        return medium.viewModifiers.reversed().compactMap({ modifier in
  112|    114|            try? Inspector.attribute(label: "modifier", value: modifier, type: Inspectable.self)
  113|    114|        })
  114|    124|    }
  115|       |}
  116|       |
  117|       |// MARK: - ViewModifier content
  118|       |
  119|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  120|       |public extension ViewType {
  121|       |    
  122|       |    struct ViewModifierContent: KnownViewType {
  123|       |        public static var typePrefix: String = "_ViewModifier_Content"
  124|       |        
  125|     36|        public static func inspectionCall(typeName: String) -> String {
  126|     36|            return "viewModifierContent(\(ViewType.indexPlaceholder))"
  127|     36|        }
  128|       |    }
  129|       |}
  130|       |
  131|       |// MARK: - Extraction from SingleViewContent parent
  132|       |
  133|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  134|       |public extension InspectableView where View: SingleViewContent {
  135|       |    
  136|      2|    func viewModifierContent() throws -> InspectableView<ViewType.ViewModifierContent> {
  137|      2|        return try .init(try child(), parent: self)
  138|      2|    }
  139|       |}
  140|       |
  141|       |// MARK: - Extraction from MultipleViewContent parent
  142|       |
  143|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  144|       |public extension InspectableView where View: MultipleViewContent {
  145|       |    
  146|      0|    func viewModifierContent(_ index: Int) throws -> InspectableView<ViewType.ViewModifierContent> {
  147|      0|        return try .init(try child(at: index), parent: self, index: index)
  148|      0|    }
  149|       |}
  150|       |
  151|       |// MARK: - ViewModifier content allocation
  152|       |
  153|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  154|       |internal extension _ViewModifier_Content {
  155|       |    private struct Allocator { }
  156|     66|    init() {
  157|     66|        self = unsafeBitCast(Allocator(), to: Self.self)
  158|     66|    }
  159|       |}
  160|       |
  161|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  162|       |internal extension ViewModifier {
  163|     66|    func body() -> Any {
  164|     66|        body(content: .init())
  165|     66|    }
  166|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/DatePicker.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct DatePicker: KnownViewType {
    7|       |        public static let typePrefix: String = "DatePicker"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, *)
   14|       |@available(tvOS, unavailable)
   15|       |public extension InspectableView where View: SingleViewContent {
   16|       |    
   17|      0|    func datePicker() throws -> InspectableView<ViewType.DatePicker> {
   18|      0|        return try .init(try child(), parent: self)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from MultipleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func datePicker(_ index: Int) throws -> InspectableView<ViewType.DatePicker> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Non Standard Children
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |extension ViewType.DatePicker: SupplementaryChildrenLabelView { }
   37|       |
   38|       |// MARK: - Custom Attributes
   39|       |
   40|       |@available(iOS 13.0, macOS 10.15, *)
   41|       |@available(tvOS, unavailable)
   42|       |public extension InspectableView where View == ViewType.DatePicker {
   43|       |    
   44|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   45|      0|        return try View.supplementaryChildren(self).element(at: 0)
   46|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   47|      0|    }
   48|       |    
   49|      0|    func select(date: Date) throws {
   50|      0|        try guardIsResponsive()
   51|      0|        let binding = try Inspector.attribute(path: "selection", value: content.view, type: Binding<Date>.self)
   52|      0|        binding.wrappedValue = date
   53|      0|    }
   54|       |}
   55|       |
   56|       |// MARK: - Global View Modifiers
   57|       |
   58|       |@available(iOS 13.0, macOS 10.15, *)
   59|       |@available(tvOS, unavailable)
   60|       |public extension InspectableView {
   61|       |
   62|      0|    func datePickerStyle() throws -> Any {
   63|      0|        let modifier = try self.modifier({ modifier -> Bool in
   64|      0|            return modifier.modifierType.hasPrefix("DatePickerStyleModifier")
   65|      0|        }, call: "datePickerStyle")
   66|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   67|      0|    }
   68|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/DelayedPreferenceView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType {
    5|       |    struct DelayedPreferenceView { }
    6|       |}
    7|       |
    8|       |// MARK: - Content Extraction
    9|       |
   10|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   11|       |extension ViewType.DelayedPreferenceView: SingleViewContent {
   12|       |    
   13|      0|    static func child(_ content: Content) throws -> Content {
   14|      0|        /* Need to find a way to get through DelayedPreferenceView */
   15|      0|        // swiftlint:disable line_length
   16|      0|        throw InspectionError.notSupported(
   17|      0|            "'PreferenceValue' modifiers are currently not supported. Consider extracting the enclosed view for direct inspection.")
   18|      0|        // swiftlint:enable line_length
   19|      0|    }
   20|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/DisclosureGroup.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct DisclosureGroup: KnownViewType {
    7|       |        public static var typePrefix: String = "DisclosureGroup"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, *)
   14|       |@available(tvOS, unavailable)
   15|       |public extension InspectableView where View: SingleViewContent {
   16|       |    
   17|      0|    func disclosureGroup() throws -> InspectableView<ViewType.DisclosureGroup> {
   18|      0|        return try .init(try child(), parent: self)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from MultipleViewContent parent
   23|       |
   24|       |@available(iOS 14.0, macOS 11.0, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func disclosureGroup(_ index: Int) throws -> InspectableView<ViewType.DisclosureGroup> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Content Extraction
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |extension ViewType.DisclosureGroup: MultipleViewContent {
   37|       |    
   38|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   39|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   40|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   41|      0|    }
   42|       |}
   43|       |
   44|       |// MARK: - Non Standard Children
   45|       |
   46|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   47|       |extension ViewType.DisclosureGroup: SupplementaryChildrenLabelView { }
   48|       |
   49|       |// MARK: - Custom Attributes
   50|       |
   51|       |@available(iOS 14.0, macOS 11.0, *)
   52|       |@available(tvOS, unavailable)
   53|       |public extension InspectableView where View == ViewType.DisclosureGroup {
   54|       |    
   55|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   56|      0|        return try View.supplementaryChildren(self).element(at: 0)
   57|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   58|      0|    }
   59|       |    
   60|      0|    func isExpanded() throws -> Bool {
   61|      0|        guard let external = try isExpandedBinding() else {
   62|      0|            return try isExpandedState().wrappedValue
   63|      0|        }
   64|      0|        return external.wrappedValue
   65|      0|    }
   66|       |    
   67|      0|    func expand() throws { try set(isExpanded: true) }
   68|       |    
   69|      0|    func collapse() throws { try set(isExpanded: false) }
   70|       |    
   71|      0|    private func set(isExpanded: Bool) throws {
   72|      0|        if let external = try isExpandedBinding() {
   73|      0|            external.wrappedValue = isExpanded
   74|      0|        } else {
   75|      0|            // @State mutation from outside is ignored by SwiftUI
   76|      0|            // try isExpandedState().wrappedValue = isExpanded
   77|      0|            // swiftlint:disable line_length
   78|      0|            throw InspectionError.notSupported("You need to enable programmatic expansion by using `DisclosureGroup(isExpanded:, content:, label:`")
   79|      0|            // swiftlint:enable line_length
   80|      0|        }
   81|      0|    }
   82|       |}
   83|       |
   84|       |@available(iOS 14.0, macOS 11.0, *)
   85|       |@available(tvOS, unavailable)
   86|       |private extension InspectableView where View == ViewType.DisclosureGroup {
   87|      0|    func isExpandedState() throws -> State<Bool> {
   88|      0|        return try Inspector
   89|      0|            .attribute(path: "_isExpanded|state", value: content.view, type: State<Bool>.self)
   90|      0|    }
   91|       |    
   92|      0|    func isExpandedBinding() throws -> Binding<Bool>? {
   93|      0|        return try? Inspector
   94|      0|            .attribute(path: "_isExpanded|binding", value: content.view, type: Binding<Bool>.self)
   95|      0|    }
   96|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Divider.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Divider: KnownViewType {
    7|       |        public static var typePrefix: String = "Divider"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func divider() throws -> InspectableView<ViewType.Divider> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func divider(_ index: Int) throws -> InspectableView<ViewType.Divider> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/EditButton.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct EditButton: KnownViewType {
    7|       |        public static var typePrefix: String = "EditButton"
    8|       |    }
    9|       |}
   10|       |
   11|       |#if os(iOS)
   12|       |
   13|       |// MARK: - Extraction from SingleViewContent parent
   14|       |
   15|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   16|       |public extension InspectableView where View: SingleViewContent {
   17|       |    
   18|      0|    func editButton() throws -> InspectableView<ViewType.EditButton> {
   19|      0|        return try .init(try child(), parent: self)
   20|      0|    }
   21|       |}
   22|       |
   23|       |// MARK: - Extraction from MultipleViewContent parent
   24|       |
   25|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func editButton(_ index: Int) throws -> InspectableView<ViewType.EditButton> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Custom Attributes
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |public extension InspectableView where View == ViewType.EditButton {
   37|       |    
   38|      0|    func editMode() throws -> Binding<EditMode>? {
   39|      0|        let editMode = try Inspector.attribute(label: "editMode", value: content.view)
   40|      0|        typealias Env = Environment<Binding<EditMode>?>
   41|      0|        return (editMode as? Env)?.wrappedValue
   42|      0|    }
   43|       |}
   44|       |
   45|       |#endif

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/EmptyView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct EmptyView: KnownViewType {
    7|       |        public static var typePrefix: String = "EmptyView"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func emptyView() throws -> InspectableView<ViewType.EmptyView> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func emptyView(_ index: Int) throws -> InspectableView<ViewType.EmptyView> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/EnvironmentReaderView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType {
    5|       |    struct EnvironmentReaderView { }
    6|       |}
    7|       |
    8|       |// MARK: - Content Extraction
    9|       |
   10|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   11|       |extension ViewType.EnvironmentReaderView: SingleViewContent {
   12|       |    
   13|      0|    static func child(_ content: Content) throws -> Content {
   14|      0|        return content
   15|      0|    }
   16|       |}
   17|       |
   18|       |// MARK: - Extraction from SingleViewContent parent
   19|       |
   20|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   21|       |public extension InspectableView where View: SingleViewContent {
   22|       |    
   23|      0|    func navigationBarItems() throws -> InspectableView<ViewType.ClassifiedView> {
   24|      0|        return try navigationBarItems(AnyView.self)
   25|      0|    }
   26|       |    
   27|       |    func navigationBarItems<V>(_ viewType: V.Type) throws ->
   28|      0|        InspectableView<ViewType.ClassifiedView> where V: SwiftUI.View {
   29|      0|        return try navigationBarItems(viewType: viewType, content: try child())
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Extraction from MultipleViewContent parent
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |public extension InspectableView where View: MultipleViewContent {
   37|       |    
   38|      0|    func navigationBarItems(_ index: Int = 0) throws -> InspectableView<ViewType.ClassifiedView> {
   39|      0|        return try navigationBarItems(AnyView.self, index)
   40|      0|    }
   41|       |    
   42|       |    func navigationBarItems<V>(_ viewType: V.Type, _ index: Int = 0) throws ->
   43|      8|        InspectableView<ViewType.ClassifiedView> where V: SwiftUI.View {
   44|      8|        return try navigationBarItems(viewType: viewType, content: try child(at: index))
   45|      8|    }
   46|       |}
   47|       |
   48|       |// MARK: - Unwrapping the EnvironmentReaderView
   49|       |
   50|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   51|       |internal extension InspectableView {
   52|       |    
   53|       |    func navigationBarItems<V>(viewType: V.Type, content: Content) throws ->
   54|      8|        InspectableView<ViewType.ClassifiedView> where V: SwiftUI.View {
   55|      8|        
   56|      8|        typealias Closure = (EnvironmentValues) -> ModifiedContent<V,
   57|      8|            _PreferenceWritingModifier<FakeNavigationBarItemsKey>>
   58|      8|        guard let closure = try? Inspector.attribute(label: "content", value: content.view),
   59|      8|            let closureDesc = Inspector.typeName(value: closure) as String?,
   60|      8|            closureDesc.contains("_PreferenceWritingModifier<NavigationBarItemsKey>>") else {
   61|      8|            throw InspectionError.modifierNotFound(parent:
   62|      8|                Inspector.typeName(value: content.view), modifier: "navigationBarItems", index: 0)
   63|      0|        }
   64|      0|        
   65|      0|        let expectedViewType = closureDesc.navigationBarItemsWrappedViewType
   66|      0|        guard Inspector.typeName(type: viewType) == expectedViewType else {
   67|      0|            // swiftlint:disable line_length
   68|      0|            throw InspectionError.notSupported(
   69|      0|                "Please substitute '\(expectedViewType).self' as the parameter for 'navigationBarItems()' inspection call")
   70|      0|            // swiftlint:enable line_length
   71|      0|        }
   72|      0|        
   73|      0|        guard let typedClosure = withUnsafeBytes(of: closure, {
   74|      0|            $0.bindMemory(to: Closure.self).first
   75|      0|        }) else { throw InspectionError.typeMismatch(closure, Closure.self) }
   76|      0|        let view = typedClosure(EnvironmentValues())
   77|      0|        return try .init(try Inspector.unwrap(view: view, medium: content.medium), parent: self)
   78|      0|    }
   79|       |}
   80|       |
   81|       |private extension String {
   82|      0|    var navigationBarItemsWrappedViewType: String {
   83|      0|        let prefix = "(EnvironmentValues) -> ModifiedContent<"
   84|      0|        let suffix = ", _PreferenceWritingModifier<NavigationBarItemsKey>>"
   85|      0|        return components(separatedBy: prefix).last?
   86|      0|            .components(separatedBy: suffix).first ?? self
   87|      0|    }
   88|       |}
   89|       |
   90|       |private struct FakeNavigationBarItemsKey: PreferenceKey {
   91|       |    static var defaultValue: String = ""
   92|      0|    static func reduce(value: inout String, nextValue: () -> String) { }
   93|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/EquatableView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType {
    5|       |    struct EquatableView { }
    6|       |}
    7|       |
    8|       |// MARK: - Content Extraction
    9|       |
   10|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   11|       |extension ViewType.EquatableView: SingleViewContent {
   12|       |    
   13|      0|    static func child(_ content: Content) throws -> Content {
   14|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   15|      0|        return try Inspector.unwrap(view: view, medium: content.medium)
   16|      0|    }
   17|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ForEach.swift:
    1|       |import SwiftUI
    2|       |import UniformTypeIdentifiers.UTType
    3|       |
    4|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    5|       |public extension ViewType {
    6|       |    
    7|       |    struct ForEach: KnownViewType {
    8|      1|        public static var typePrefix: String { "ForEach" }
    9|       |    }
   10|       |}
   11|       |
   12|       |// MARK: - Content Extraction
   13|       |
   14|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   15|       |extension ViewType.ForEach: MultipleViewContent {
   16|       |    
   17|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   18|      0|        let provider = try Inspector.cast(value: content.view, type: ForEachContentProvider.self)
   19|      0|        let children = try provider.views()
   20|      0|        return LazyGroup(count: children.count) { index in
   21|      0|            try Inspector.unwrap(view: try children.element(at: index),
   22|      0|                                 medium: content.medium.resettingViewModifiers())
   23|      0|        }
   24|      0|    }
   25|       |}
   26|       |
   27|       |// MARK: - Extraction from SingleViewContent parent
   28|       |
   29|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   30|       |public extension InspectableView where View: SingleViewContent {
   31|       |    
   32|      0|    func forEach() throws -> InspectableView<ViewType.ForEach> {
   33|      0|        return try .init(try child(), parent: self)
   34|      0|    }
   35|       |}
   36|       |
   37|       |// MARK: - Extraction from MultipleViewContent parent
   38|       |
   39|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   40|       |public extension InspectableView where View: MultipleViewContent {
   41|       |    
   42|      0|    func forEach(_ index: Int) throws -> InspectableView<ViewType.ForEach> {
   43|      0|        return try .init(try child(at: index), parent: self, index: index)
   44|      0|    }
   45|       |}
   46|       |
   47|       |// MARK: - DynamicViewContent
   48|       |
   49|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   50|       |public extension InspectableView where View == ViewType.ForEach {
   51|       |    
   52|      0|    func callOnDelete(_ indexSet: IndexSet) throws {
   53|      0|        typealias Closure = (IndexSet) -> Void
   54|      0|        let closure = try modifierAttribute(
   55|      0|            modifierName: "_TraitWritingModifier<OnDeleteTraitKey>",
   56|      0|            path: "modifier|value|some", type: Closure.self, call: "onDelete(perform:)")
   57|      0|        closure(indexSet)
   58|      0|    }
   59|       |    
   60|      0|    func callOnMove(_ indexSet: IndexSet, _ index: Int) throws {
   61|      0|        typealias Closure = (IndexSet, Int) -> Void
   62|      0|        let closure = try modifierAttribute(
   63|      0|            modifierName: "_TraitWritingModifier<OnMoveTraitKey>",
   64|      0|            path: "modifier|value|some", type: Closure.self, call: "onMove(perform:)")
   65|      0|        closure(indexSet, index)
   66|      0|    }
   67|       |    
   68|       |    #if os(macOS)
   69|       |    @available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   70|       |    func callOnInsert(of types: [UTType], _ index: Int, _ providers: [NSItemProvider]) throws {
   71|       |        typealias Closure = (Int, [NSItemProvider]) -> Void
   72|       |        let closure = try modifierAttribute(modifierLookup: { modifier -> Bool in
   73|       |            guard modifier.modifierType == "_TraitWritingModifier<OnInsertTraitKey>",
   74|       |                  let typesValue = try? Inspector.attribute(
   75|       |                    path: "modifier|value|some|supportedContentTypes", value: modifier, type: [UTType].self)
   76|       |            else { return false }
   77|       |            return typesValue == types
   78|       |        }, path: "modifier|value|some|action", type: Closure.self,
   79|       |        call: "onInsert(of: \(types.map({ $0.identifier })), perform:)")
   80|       |        closure(index, providers)
   81|       |    }
   82|       |    #endif
   83|       |}
   84|       |
   85|       |// MARK: - Private
   86|       |
   87|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   88|       |private protocol ForEachContentProvider {
   89|       |    func views() throws -> LazyGroup<Any>
   90|       |}
   91|       |
   92|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   93|       |extension ForEach: ForEachContentProvider {
   94|       |    
   95|      0|    func views() throws -> LazyGroup<Any> {
   96|      0|        
   97|      0|        typealias Builder = (Data.Element) -> Content
   98|      0|        let data = try Inspector
   99|      0|            .attribute(label: "data", value: self, type: Data.self)
  100|      0|        let builder = try Inspector
  101|      0|            .attribute(label: "content", value: self, type: Builder.self)
  102|      0|        
  103|      0|        return LazyGroup(count: data.count) { int in
  104|      0|            let index = data.index(data.startIndex, offsetBy: int)
  105|      0|            return builder(data[index])
  106|      0|        }
  107|      0|    }
  108|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Form.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Form: KnownViewType {
    7|       |        public static let typePrefix: String = "Form"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.Form: MultipleViewContent {
   15|       |    
   16|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   18|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from SingleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   25|       |public extension InspectableView where View: SingleViewContent {
   26|       |    
   27|      0|    func form() throws -> InspectableView<ViewType.Form> {
   28|      0|        return try .init(try child(), parent: self)
   29|      0|    }
   30|       |}
   31|       |
   32|       |// MARK: - Extraction from MultipleViewContent parent
   33|       |
   34|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   35|       |public extension InspectableView where View: MultipleViewContent {
   36|       |    
   37|      0|    func form(_ index: Int) throws -> InspectableView<ViewType.Form> {
   38|      0|        return try .init(try child(at: index), parent: self, index: index)
   39|      0|    }
   40|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/GeometryReader.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct GeometryReader: KnownViewType {
    7|       |        public static var typePrefix: String = "GeometryReader"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.GeometryReader: SingleViewContent {
   15|       |    
   16|      8|    public static func child(_ content: Content) throws -> Content {
   17|      8|        let provider = try Inspector.cast(value: content.view, type: GeometryReaderContentProvider.self)
   18|      8|        let medium = content.medium.resettingViewModifiers()
   19|      8|        return try Inspector.unwrap(view: provider.view(), medium: medium)
   20|      8|    }
   21|       |}
   22|       |
   23|       |// MARK: - Extraction from SingleViewContent parent
   24|       |
   25|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   26|       |public extension InspectableView where View: SingleViewContent {
   27|       |    
   28|      8|    func geometryReader() throws -> InspectableView<ViewType.GeometryReader> {
   29|      8|        return try .init(try child(), parent: self)
   30|      8|    }
   31|       |}
   32|       |
   33|       |// MARK: - Extraction from MultipleViewContent parent
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |public extension InspectableView where View: MultipleViewContent {
   37|       |    
   38|      0|    func geometryReader(_ index: Int) throws -> InspectableView<ViewType.GeometryReader> {
   39|      0|        return try .init(try child(at: index), parent: self, index: index)
   40|      0|    }
   41|       |}
   42|       |
   43|       |// MARK: - Private
   44|       |
   45|       |private protocol GeometryReaderContentProvider {
   46|       |    func view() throws -> Any
   47|       |}
   48|       |
   49|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   50|       |extension GeometryReader: GeometryReaderContentProvider {
   51|      8|    func view() throws -> Any {
   52|      8|        typealias Builder = (GeometryProxy) -> Content
   53|      8|        let builder = try Inspector
   54|      8|            .attribute(label: "content", value: self, type: Builder.self)
   55|      8|        return builder(GeometryProxy())
   56|      8|    }
   57|       |}
   58|       |
   59|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   60|       |private extension GeometryProxy {
   61|       |    struct Allocator48 {
   62|      8|        let data: (Int64, Int64, Int64, Int64, Int64, Int64) = (0, 0, 0, 0, 0, 0)
   63|       |    }
   64|       |    struct Allocator52 {
   65|      8|        let data: (Allocator48, Int32) = (.init(), 0)
   66|       |    }
   67|       |    
   68|      8|    init() {
   69|      8|        if MemoryLayout<GeometryProxy>.size == 52 {
   70|      8|            self = unsafeBitCast(Allocator52(), to: GeometryProxy.self)
   71|      8|            return
   72|      0|        }
   73|      0|        self = unsafeBitCast(Allocator48(), to: GeometryProxy.self)
   74|      0|    }
   75|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Gesture.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public protocol GestureViewType {
    5|       |    associatedtype T: SwiftUI.Gesture & Inspectable
    6|       |}
    7|       |
    8|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    9|       |public extension ViewType {
   10|       |    
   11|       |    struct Gesture<T>: KnownViewType, GestureViewType
   12|       |    where T: SwiftUI.Gesture & Inspectable {
   13|      0|        public static var typePrefix: String {
   14|      0|            return Inspector.typeName(type: T.self, prefixOnly: true)
   15|      0|        }
   16|       |        
   17|      0|        public static var namespacedPrefixes: [String] {
   18|      0|            var prefixes = [
   19|      0|                "SwiftUI.AddGestureModifier",
   20|      0|                "SwiftUI.HighPriorityGestureModifier",
   21|      0|                "SwiftUI.SimultaneousGestureModifier",
   22|      0|                "SwiftUI._ChangedGesture",
   23|      0|                "SwiftUI._EndedGesture",
   24|      0|                "SwiftUI._MapGesture",
   25|      0|                "SwiftUI._ModifiersGesture",
   26|      0|                "SwiftUI.GestureStateGesture"
   27|      0|            ]
   28|      0|            prefixes.append(Inspector.typeName(type: T.self, namespaced: true, prefixOnly: true))
   29|      0|            return prefixes
   30|      0|        }
   31|       |        
   32|      0|        public static func inspectionCall(call: String, typeName: String, index: Int? = nil) -> String {
   33|      0|            if let index = index {
   34|      0|                return "\(call)(\(typeName.self).self, \(index))"
   35|      0|            } else {
   36|      0|                return "\(call)(\(typeName.self).self)"
   37|      0|            }
   38|      0|        }
   39|       |    }
   40|       |}
   41|       |
   42|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   43|       |public extension Gesture where Self: Inspectable {
   44|      0|    var entity: Content.InspectableEntity { .gesture }
   45|      0|    func extractContent(environmentObjects: [AnyObject]) throws -> Any { () }
   46|       |}
   47|       |
   48|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   49|       |extension AnyGesture: Inspectable {}
   50|       |
   51|       |@available(iOS 13.0, macOS 10.15, *)
   52|       |@available(tvOS, unavailable)
   53|       |extension DragGesture: Inspectable {}
   54|       |
   55|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   56|       |extension ExclusiveGesture: Inspectable {}
   57|       |
   58|       |@available(iOS 13.0, macOS 10.15, tvOS 14.0, *)
   59|       |extension LongPressGesture: Inspectable {}
   60|       |
   61|       |@available(iOS 13.0, macOS 10.15, *)
   62|       |@available(tvOS, unavailable)
   63|       |extension MagnificationGesture: Inspectable {}
   64|       |
   65|       |@available(iOS 13.0, macOS 10.15, *)
   66|       |@available(tvOS, unavailable)
   67|       |extension RotationGesture: Inspectable {}
   68|       |
   69|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   70|       |extension SequenceGesture: Inspectable {}
   71|       |
   72|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   73|       |extension SimultaneousGesture: Inspectable {}
   74|       |
   75|       |@available(iOS 13.0, macOS 10.15, *)
   76|       |@available(tvOS, unavailable)
   77|       |extension TapGesture: Inspectable {}
   78|       |
   79|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   80|       |public extension InspectableView {
   81|       |    
   82|       |    func gesture<T>(_ type: T.Type, _ index: Int? = nil) throws -> InspectableView<ViewType.Gesture<T>>
   83|      0|        where T: Gesture & Inspectable {
   84|      0|        return try gestureModifier(
   85|      0|            modifierName: "AddGestureModifier", path: "modifier",
   86|      0|            type: type, call: "gesture", index: index)
   87|      0|    }
   88|       |    
   89|       |    func highPriorityGesture<T>(_ type: T.Type, _ index: Int? = nil) throws -> InspectableView<ViewType.Gesture<T>>
   90|      0|        where T: Gesture & Inspectable {
   91|      0|        return try gestureModifier(
   92|      0|            modifierName: "HighPriorityGestureModifier", path: "modifier",
   93|      0|            type: type, call: "highPriorityGesture", index: index)
   94|      0|    }
   95|       |    
   96|       |    func simultaneousGesture<T>(_ type: T.Type, _ index: Int? = nil) throws -> InspectableView<ViewType.Gesture<T>>
   97|      0|        where T: Gesture & Inspectable {
   98|      0|        return try gestureModifier(
   99|      0|            modifierName: "SimultaneousGestureModifier", path: "modifier",
  100|      0|            type: type, call: "simultaneousGesture", index: index)
  101|      0|    }
  102|       |}
  103|       |
  104|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  105|       |public extension InspectableView where View: GestureViewType {
  106|       |
  107|      0|    func first<G: Gesture>(_ type: G.Type) throws -> InspectableView<ViewType.Gesture<G>> {
  108|      0|        return try gestureFromComposedGesture(type, .first)
  109|      0|    }
  110|       |    
  111|      0|    func second<G: Gesture>(_ type: G.Type) throws -> InspectableView<ViewType.Gesture<G>> {
  112|      0|        return try gestureFromComposedGesture(type, .second)
  113|      0|    }
  114|       |    
  115|      0|    func gestureMask() throws -> GestureMask {
  116|      0|        return try Inspector.attribute(
  117|      0|            path: "gestureMask", value: content.view, type: GestureMask.self)
  118|      0|    }
  119|       |    
  120|       |    func callUpdating<Value, State>(
  121|       |        value: Value,
  122|       |        state: inout State,
  123|      0|        transaction: inout Transaction) throws {
  124|      0|        typealias Callback = (Value, inout State, inout Transaction) -> Void
  125|      0|        let callbacks = try gestureCallbacks(
  126|      0|            name: "GestureStateGesture", path: "body",
  127|      0|            type: Callback.self, call: "updating")
  128|      0|        for callback in callbacks {
  129|      0|            callback(value, &state, &transaction)
  130|      0|        }
  131|      0|    }
  132|       |    
  133|      0|    func callOnChanged<Value>(value: Value) throws {
  134|      0|        typealias Callback = (Value) -> Void
  135|      0|        let callbacks = try gestureCallbacks(
  136|      0|            name: "_ChangedGesture", path: "_body|modifier|callbacks|changed",
  137|      0|            type: Callback.self, call: "onChanged")
  138|      0|        for callback in callbacks {
  139|      0|            callback(value)
  140|      0|        }
  141|      0|    }
  142|       |    
  143|      0|    func callOnEnded<Value>(value: Value) throws {
  144|      0|        typealias Callback = (Value) -> Void
  145|      0|        let callbacks = try gestureCallbacks(
  146|      0|            name: "_EndedGesture", path: "_body|modifier|callbacks|ended",
  147|      0|            type: Callback.self, call: "onEnded")
  148|      0|        for callback in callbacks {
  149|      0|            callback(value)
  150|      0|        }
  151|      0|    }
  152|       |
  153|      0|    func actualGesture() throws -> View.T {
  154|      0|        let typeName = Inspector.typeName(type: View.T.self)
  155|      0|        let valueName = Inspector.typeName(value: content.view)
  156|      0|        let (_, modifiers) = gestureInfo(typeName, valueName)
  157|      0|        if modifiers.count > 0 {
  158|      0|            let path = modifiers.reduce("") { return addSegment(knownGestureModifier($1)!, to: $0) }
  159|      0|            return try Inspector.attribute(path: path, value: content.view, type: View.T.self)
  160|      0|        }
  161|      0|        return try Inspector.cast(value: content.view, type: View.T.self)
  162|      0|    }
  163|       |}
  164|       |
  165|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  166|       |public extension InspectableView {
  167|       |    
  168|       |    @available(macOS 10.15, *)
  169|       |    @available(iOS, unavailable)
  170|       |    @available(tvOS, unavailable)
  171|       |    func gestureModifiers<T>() throws -> EventModifiers
  172|      0|    where T: Gesture & Inspectable, View == ViewType.Gesture<T> {
  173|      0|        let typeName = Inspector.typeName(type: T.self)
  174|      0|        let valueName = Inspector.typeName(value: content.view)
  175|      0|        let (_, modifiers) = gestureInfo(typeName, valueName)
  176|      0|        let result = try modifiers.reduce((path: "", eventModifiers: EventModifiers())) { result, modifier in
  177|      0|            var eventModifiers = result.eventModifiers
  178|      0|            if modifier == "_ModifiersGesture" {
  179|      0|                let value = try Inspector.attribute(
  180|      0|                    path: addSegment("_body|modifier|modifiers|rawValue", to: result.path),
  181|      0|                    value: content.view,
  182|      0|                    type: Int.self)
  183|      0|                eventModifiers.formUnion(EventModifiers.init(rawValue: value))
  184|      0|            }
  185|      0|            return (path: addSegment(knownGestureModifier(modifier)!, to: result.path), eventModifiers: eventModifiers)
  186|      0|        }
  187|      0|        return result.eventModifiers
  188|      0|    }
  189|       |}
  190|       |
  191|       |// MARK: - Private
  192|       |
  193|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  194|       |internal extension InspectableView {
  195|       |    
  196|       |    func gestureModifier<T>(
  197|       |        modifierName: String,
  198|       |        path: String,
  199|       |        type: T.Type,
  200|       |        call: String,
  201|       |        index: Int? = nil) throws -> InspectableView<ViewType.Gesture<T>>
  202|      0|        where T: Gesture, T: Inspectable {
  203|      0|        let typeName = Inspector.typeName(type: type)
  204|      0|        let modifierCall = ViewType.Gesture<T>.inspectionCall(call: call, typeName: typeName, index: nil)
  205|      0|        
  206|      0|        let rootView = try modifierAttribute(modifierName: modifierName, path: path, type: Any.self,
  207|      0|                                             call: modifierCall, index: index ?? 0)
  208|      0|        
  209|      0|        let (name, _) = gestureInfo(typeName, Inspector.typeName(value: rootView))
  210|      0|        guard name == typeName else {
  211|      0|            throw InspectionError.typeMismatch(factual: name, expected: typeName)
  212|      0|        }
  213|      0|
  214|      0|        return try InspectableView<ViewType.Gesture<T>>.init(
  215|      0|            Content(rootView), parent: self,
  216|      0|            call: ViewType.Gesture<T>.inspectionCall(call: call, typeName: typeName, index: index))
  217|      0|    }
  218|       |
  219|       |    enum GestureOrder {
  220|       |        case first
  221|       |        case second
  222|       |    }
  223|       |    
  224|       |    func gestureFromComposedGesture<T: Gesture>(
  225|       |        _ type: T.Type,
  226|      0|        _ order: GestureOrder) throws -> InspectableView<ViewType.Gesture<T>> {
  227|      0|        let valueName = Inspector.typeName(value: content.view)
  228|      0|        let typeName = Inspector.typeName(type: type)
  229|      0|        let (name1, modifiers1) = gestureInfo(typeName, valueName)
  230|      0|        guard isComposedGesture(name1) else {
  231|      0|            throw InspectionError.typeMismatch(
  232|      0|                factual: name1,
  233|      0|                expected: "ExclusiveGesture, SequenceGesture, or SimultaneousGesture")
  234|      0|        }
  235|      0|        
  236|      0|        var path = modifiers1.reduce("") { addSegment(knownGestureModifier($1)!, to: $0) }
  237|      0|        let call: String
  238|      0|        switch order {
  239|      0|        case .first:
  240|      0|            path = addSegment("first", to: path)
  241|      0|            call = ViewType.Gesture<T>.inspectionCall(call: "first", typeName: typeName)
  242|      0|        case .second:
  243|      0|            path = addSegment("second", to: path)
  244|      0|            call = ViewType.Gesture<T>.inspectionCall(call: "second", typeName: typeName)
  245|      0|        }
  246|      0|        
  247|      0|        let rootView = try Inspector.attribute(path: path, value: content.view)
  248|      0|        
  249|      0|        let (name2, _) = gestureInfo(typeName, Inspector.typeName(value: rootView))
  250|      0|        let gestureTypeName = Inspector.typeName(type: type)
  251|      0|        guard name2 == gestureTypeName else {
  252|      0|            throw InspectionError.typeMismatch(factual: name2, expected: gestureTypeName)
  253|      0|        }
  254|      0|        return try .init(Inspector.unwrap(content: Content(rootView)), parent: self, call: call)
  255|      0|    }
  256|       |    
  257|       |    func gestureCallbacks<T>(
  258|       |        name: String,
  259|       |        path callbackPath: String,
  260|       |        type: T.Type,
  261|      0|        call: String) throws -> [T] {
  262|      0|        let valueName = Inspector.typeName(value: content.view)
  263|      0|        let typeName = Inspector.typeName(type: type)
  264|      0|        let (_, modifiers) = gestureInfo(typeName, valueName)
  265|      0|        let result = try modifiers.reduce((path: "", callbacks: [T]())) { result, modifier in
  266|      0|            var callbacks = result.callbacks
  267|      0|            if modifier == name {
  268|      0|                let object = try Inspector.attribute(
  269|      0|                    path: addSegment(callbackPath, to: result.path),
  270|      0|                    value: content.view,
  271|      0|                    type: T.self)
  272|      0|                callbacks.append(object)
  273|      0|            }
  274|      0|            return (path: addSegment(knownGestureModifier(modifier)!, to: result.path), callbacks: callbacks)
  275|      0|        }
  276|      0|        
  277|      0|        if result.callbacks.count == 0 {
  278|      0|            throw InspectionError.callbackNotFound(
  279|      0|                parent: Inspector.typeName(value: content.view),
  280|      0|                callback: call)
  281|      0|        }
  282|      0|        return result.callbacks.reversed()
  283|      0|    }
  284|       |    
  285|       |    typealias GestureInfo = (name: String, modifiers: [String])
  286|       |    
  287|      0|    func gestureInfo(_ name: String, _ valueName: String) -> GestureInfo {
  288|      0|        var modifiers = parseModifiers(valueName)
  289|      0|        return gestureInfo(name, &modifiers)
  290|      0|    }
  291|       |    
  292|      0|    func gestureInfo(_ name: String, _ modifiers: inout [String]) -> GestureInfo {
  293|      0|        let modifier = modifiers.removeLast()
  294|      0|        if let gestureClass = knownGesture(modifier) {
  295|      0|            switch gestureClass {
  296|      0|            case .simple:
  297|      0|                return (modifier, [])
  298|      0|            case .composed:
  299|      0|                return traverseComposedGesture(modifier, name, &modifiers)
  300|      0|            case .state :
  301|      0|                return traverseStateGesture(modifier, name, &modifiers)
  302|      0|            }
  303|      0|        } else if modifier == name {
  304|      0|            return (modifier, [])
  305|      0|        } else if knownGestureModifier(modifier) != nil {
  306|      0|            let result = gestureInfo(name, &modifiers)
  307|      0|            return (result.0, [modifier] + result.1)
  308|      0|        }
  309|      0|        return (name, modifiers)
  310|      0|    }
  311|       |    
  312|      0|    func parseModifiers(_ name: String) -> [String] {
  313|      0|        let separators = CharacterSet(charactersIn: "<>, ")
  314|      0|        return name
  315|      0|            .components(separatedBy: separators)
  316|      0|            .compactMap { $0 == "" ? nil : $0 }
  317|      0|            .reversed()
  318|      0|    }
  319|       |    
  320|       |    func traverseComposedGesture(_ modifier: String, _ name: String,
  321|      0|                                 _ modifiers: inout [String]) -> GestureInfo {
  322|      0|        let (first, _) = gestureInfo(name, &modifiers)
  323|      0|        let (second, _) = gestureInfo(name, &modifiers)
  324|      0|        return ("\(modifier)<\(first), \(second)>", [])
  325|      0|    }
  326|       |    
  327|       |    func traverseStateGesture(_ modifier: String, _ name: String,
  328|      0|                              _ modifiers: inout [String]) -> GestureInfo {
  329|      0|        let result = gestureInfo(name, &modifiers)
  330|      0|        _ = modifiers.popLast()
  331|      0|        return (result.0, [modifier] + result.1)
  332|      0|    }
  333|       |    
  334|      0|    func addSegment(_ segment: String, to path: String) -> String {
  335|      0|        return (path == "") ? segment : path + "|" + segment
  336|      0|    }
  337|       |    
  338|       |    enum GestureClass {
  339|       |        case simple
  340|       |        case composed
  341|       |        case state
  342|       |    }
  343|       |    
  344|      0|    func knownGesture(_ name: String) -> GestureClass? {
  345|      0|        let knownGestures: [String: GestureClass] = [
  346|      0|            "DragGesture": .simple,
  347|      0|            "ExclusiveGesture": .composed,
  348|      0|            "GestureStateGesture": .state,
  349|      0|            "LongPressGesture": .simple,
  350|      0|            "MagnificationGesture": .simple,
  351|      0|            "RotationGesture": .simple,
  352|      0|            "SequenceGesture": .composed,
  353|      0|            "SimultaneousGesture": .composed,
  354|      0|            "TapGesture": .simple,
  355|      0|        ]
  356|      0|        return knownGestures[name]
  357|      0|    }
  358|       |    
  359|      0|    func knownGestureModifier(_ name: String) -> String? {
  360|      0|        let knownGestureModifiers: [String: String] = [
  361|      0|            "AddGestureModifier": "gesture",
  362|      0|            "HighPriorityGestureModifier": "gesture",
  363|      0|            "SimultaneousGestureModifier": "gesture",
  364|      0|            "_ChangedGesture": "_body|content",
  365|      0|            "_EndedGesture": "_body|content",
  366|      0|            "_MapGesture": "_body|content",
  367|      0|            "_ModifiersGesture": "_body|content",
  368|      0|            "GestureStateGesture": "base",
  369|      0|            "Optional": "some",
  370|      0|        ]
  371|      0|        return knownGestureModifiers[name]
  372|      0|    }
  373|       |    
  374|      0|    func isComposedGesture(_ name: String) -> Bool {
  375|      0|        let parts = parseModifiers(name)
  376|      0|        return knownGesture(parts.last!) == .composed
  377|      0|    }
  378|       |}
  379|       |
  380|       |// MARK: - Gesture Value initializers
  381|       |
  382|       |@available(iOS 13.0, macOS 10.15, *)
  383|       |@available(tvOS, unavailable)
  384|       |public extension DragGesture.Value {
  385|       |    
  386|       |    private struct Allocator {
  387|       |        var time: Date
  388|       |        var location: CGPoint
  389|       |        var startLocation: CGPoint
  390|       |        var velocity: CGVector
  391|       |    }
  392|       |
  393|      0|    init(time: Date, location: CGPoint, startLocation: CGPoint, velocity: CGVector) {
  394|      0|        self = unsafeBitCast(
  395|      0|            Allocator(
  396|      0|                time: time,
  397|      0|                location: location,
  398|      0|                startLocation: startLocation,
  399|      0|                velocity: velocity),
  400|      0|            to: DragGesture.Value.self
  401|      0|        )
  402|      0|   }
  403|       |}
  404|       |
  405|       |@available(iOS 13.0, macOS 10.15, tvOS 14.0, *)
  406|       |public extension LongPressGesture.Value {
  407|       |    
  408|       |    private struct Allocator {
  409|       |        var finished: Bool
  410|       |    }
  411|       |
  412|      0|    init(finished: Bool) {
  413|      0|        self = unsafeBitCast(
  414|      0|            Allocator(finished: finished),
  415|      0|            to: LongPressGesture.Value.self
  416|      0|        )
  417|      0|   }
  418|       |}
  419|       |
  420|       |@available(iOS 13.0, macOS 10.15, *)
  421|       |@available(tvOS, unavailable)
  422|       |public extension MagnificationGesture.Value {
  423|       |    
  424|       |    private struct Allocator {
  425|       |        var magnifyBy: CGFloat
  426|       |    }
  427|       |
  428|      0|    init(magnifyBy: CGFloat) {
  429|      0|        self = unsafeBitCast(
  430|      0|            Allocator(magnifyBy: magnifyBy),
  431|      0|            to: MagnificationGesture.Value.self
  432|      0|        )
  433|      0|   }
  434|       |}
  435|       |
  436|       |@available(iOS 13.0, macOS 10.15, *)
  437|       |@available(tvOS, unavailable)
  438|       |public extension RotationGesture.Value {
  439|       |    
  440|       |    private struct Allocator {
  441|       |        var angle: Angle
  442|       |    }
  443|       |
  444|      0|    init(angle: Angle) {
  445|      0|        self = unsafeBitCast(
  446|      0|            Allocator(angle: angle),
  447|      0|            to: RotationGesture.Value.self
  448|      0|        )
  449|      0|   }
  450|       |}
  451|       |
  452|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  453|       |public extension SimultaneousGesture.Value {
  454|       |    
  455|       |    private struct Allocator {
  456|       |        var first: First.Value?
  457|       |        var second: Second.Value?
  458|       |    }
  459|       |    
  460|      0|    init(first: First.Value?, second: Second.Value?) {
  461|      0|        self = unsafeBitCast(
  462|      0|            Allocator(first: first, second: second),
  463|      0|            to: SimultaneousGesture.Value.self)
  464|      0|    }
  465|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Group.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Group: KnownViewType {
    7|       |        public static let typePrefix: String = "Group"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.Group: MultipleViewContent {
   15|       |    
   16|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   18|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from SingleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   25|       |public extension InspectableView where View: SingleViewContent {
   26|       |    
   27|      2|    func group() throws -> InspectableView<ViewType.Group> {
   28|      2|        return try .init(try child(), parent: self)
   29|      2|    }
   30|       |}
   31|       |
   32|       |// MARK: - Extraction from MultipleViewContent parent
   33|       |
   34|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   35|       |public extension InspectableView where View: MultipleViewContent {
   36|       |    
   37|      0|    func group(_ index: Int) throws -> InspectableView<ViewType.Group> {
   38|      0|        return try .init(try child(at: index), parent: self, index: index)
   39|      0|    }
   40|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/GroupBox.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct GroupBox: KnownViewType {
    7|       |        public static let typePrefix: String = "GroupBox"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.GroupBox: MultipleViewContent {
   15|       |    
   16|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   18|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from SingleViewContent parent
   23|       |
   24|       |@available(iOS 14.0, macOS 10.15, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: SingleViewContent {
   27|       |    
   28|      0|    func groupBox() throws -> InspectableView<ViewType.GroupBox> {
   29|      0|        return try .init(try child(), parent: self)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Extraction from MultipleViewContent parent
   34|       |
   35|       |@available(iOS 14.0, macOS 10.15, *)
   36|       |@available(tvOS, unavailable)
   37|       |public extension InspectableView where View: MultipleViewContent {
   38|       |    
   39|      0|    func groupBox(_ index: Int) throws -> InspectableView<ViewType.GroupBox> {
   40|      0|        return try .init(try child(at: index), parent: self, index: index)
   41|      0|    }
   42|       |}
   43|       |
   44|       |// MARK: - Non Standard Children
   45|       |
   46|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   47|       |extension ViewType.GroupBox: SupplementaryChildrenLabelView { }
   48|       |
   49|       |// MARK: - Custom Attributes
   50|       |
   51|       |@available(iOS 14.0, macOS 10.15, *)
   52|       |@available(tvOS, unavailable)
   53|       |public extension InspectableView where View == ViewType.GroupBox {
   54|       |    
   55|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   56|      0|        return try View.supplementaryChildren(self).element(at: 0)
   57|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   58|      0|    }
   59|       |}
   60|       |
   61|       |// MARK: - Global View Modifiers
   62|       |
   63|       |@available(iOS 14.0, macOS 11.0, *)
   64|       |@available(tvOS, unavailable)
   65|       |public extension InspectableView {
   66|       |
   67|      0|    func groupBoxStyle() throws -> Any {
   68|      0|        let modifier = try self.modifier({ modifier -> Bool in
   69|      0|            return modifier.modifierType.hasPrefix("GroupBoxStyleModifier")
   70|      0|        }, call: "groupBoxStyle")
   71|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   72|      0|    }
   73|       |}
   74|       |
   75|       |// MARK: - GroupBoxStyle inspection
   76|       |
   77|       |@available(iOS 14.0, macOS 11.0, *)
   78|       |@available(tvOS, unavailable)
   79|       |public extension GroupBoxStyle {
   80|      0|    func inspect() throws -> InspectableView<ViewType.ClassifiedView> {
   81|      0|        let config = GroupBoxStyleConfiguration()
   82|      0|        let view = try makeBody(configuration: config).inspect()
   83|      0|        return try .init(view.content, parent: nil, index: nil)
   84|      0|    }
   85|       |}
   86|       |
   87|       |// MARK: - Style Configuration initializer
   88|       |
   89|       |@available(iOS 14.0, macOS 11.0, *)
   90|       |@available(tvOS, unavailable)
   91|       |private extension GroupBoxStyleConfiguration {
   92|       |    private struct Allocator { }
   93|      0|    init() {
   94|      0|        self = unsafeBitCast(Allocator(), to: Self.self)
   95|      0|    }
   96|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/HStack.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |
    6|       |    struct HStack: KnownViewType {
    7|       |        public static let typePrefix: String = "HStack"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.HStack: MultipleViewContent {
   15|       |
   16|     17|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|     17|        let container = try Inspector.attribute(path: "_tree|content", value: content.view)
   18|     17|        return try Inspector.viewsInContainer(view: container, medium: content.medium)
   19|     17|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from SingleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   25|       |public extension InspectableView where View: SingleViewContent {
   26|       |
   27|      0|    func hStack() throws -> InspectableView<ViewType.HStack> {
   28|      0|        return try .init(try child(), parent: self)
   29|      0|    }
   30|       |}
   31|       |
   32|       |// MARK: - Extraction from MultipleViewContent parent
   33|       |
   34|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   35|       |public extension InspectableView where View: MultipleViewContent {
   36|       |
   37|      0|    func hStack(_ index: Int) throws -> InspectableView<ViewType.HStack> {
   38|      0|        return try .init(try child(at: index), parent: self, index: index)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Custom Attributes
   43|       |
   44|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   45|       |public extension InspectableView where View == ViewType.HStack {
   46|       |
   47|      0|    func spacing() throws -> CGFloat? {
   48|      0|        return try Inspector.attribute(
   49|      0|            path: "spacing", value: hStackLayout(), type: CGFloat?.self)
   50|      0|    }
   51|       |
   52|      0|    func alignment() throws -> VerticalAlignment? {
   53|      0|        return try Inspector.attribute(
   54|      0|            path: "alignment", value: hStackLayout(), type: VerticalAlignment?.self)
   55|      0|    }
   56|       |
   57|      0|    private func hStackLayout() throws -> Any {
   58|      0|        return try Inspector.attribute(path: "_tree|root", value: content.view)
   59|      0|    }
   60|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/IDView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType {
    5|       |    struct IDView { }
    6|       |}
    7|       |
    8|       |// MARK: - Content Extraction
    9|       |
   10|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   11|       |extension ViewType.IDView: SingleViewContent {
   12|       |    
   13|      0|    static func child(_ content: Content) throws -> Content {
   14|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   15|      0|        let medium = content.medium.appending(viewModifier: IDViewModifier(view: content.view))
   16|      0|        return try Inspector.unwrap(view: view, medium: medium)
   17|      0|    }
   18|       |}
   19|       |
   20|       |// MARK: - Private
   21|       |
   22|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   23|       |private struct IDViewModifier: ModifierNameProvider {
   24|      0|    static var modifierName: String { "IDView" }
   25|      0|    func modifierType(prefixOnly: Bool) -> String { IDViewModifier.modifierName }
   26|      0|    var customModifier: Inspectable? { nil }
   27|       |    let view: Any
   28|       |}
   29|       |
   30|       |// MARK: - Global View Modifiers
   31|       |
   32|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   33|       |public extension InspectableView {
   34|       |    
   35|      0|    func id() throws -> AnyHashable {
   36|      0|        return try modifierAttribute(
   37|      0|            modifierName: IDViewModifier.modifierName,
   38|      0|            path: "view|id", type: AnyHashable.self, call: "id")
   39|      0|    }
   40|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Image.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Image: KnownViewType {
    7|       |        public static let typePrefix: String = "Image"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func image() throws -> InspectableView<ViewType.Image> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func image(_ index: Int) throws -> InspectableView<ViewType.Image> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Non Standard Children
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.Image: SupplementaryChildren {
   35|      0|    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView> {
   36|      0|        return .init(count: 1) { index in
   37|      0|            let image = try Inspector.cast(value: parent.content.view, type: Image.self)
   38|      0|                .rootImage()
   39|      0|            let labelView: Any = try {
   40|      0|                if let view = try? Inspector.attribute(path: "provider|base|label|some|text", value: image) {
   41|      0|                    return view
   42|      0|                }
   43|      0|                return try Inspector.attribute(path: "provider|base|label", value: image)
   44|      0|            }()
   45|      0|            let medium = parent.content.medium.resettingViewModifiers()
   46|      0|            let content = try Inspector.unwrap(content: Content(labelView, medium: medium))
   47|      0|            return try InspectableView<ViewType.ClassifiedView>(
   48|      0|                content, parent: parent, call: "labelView()")
   49|      0|        }
   50|      0|    }
   51|       |}
   52|       |
   53|       |// MARK: - Custom Attributes
   54|       |
   55|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   56|       |public extension InspectableView where View == ViewType.Image {
   57|       |    
   58|      1|    func actualImage() throws -> Image {
   59|      1|        return try Inspector.cast(value: content.view, type: Image.self)
   60|      1|    }
   61|       |    
   62|      0|    func labelView() throws -> InspectableView<ViewType.Text> {
   63|      0|        return try View.supplementaryChildren(self).element(at: 0)
   64|      0|            .asInspectableView(ofType: ViewType.Text.self)
   65|      0|    }
   66|       |}
   67|       |
   68|       |// MARK: - Image
   69|       |
   70|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   71|       |public extension SwiftUI.Image {
   72|       |    
   73|      0|    func rootImage() throws -> Image {
   74|      0|        return try Inspector.cast(value: imageContent().view, type: Image.self)
   75|      0|    }
   76|       |    
   77|      0|    func name() throws -> String {
   78|      0|        return try Inspector
   79|      0|            .attribute(label: "name", value: rawImage(), type: String.self)
   80|      0|    }
   81|       |    
   82|       |    #if os(iOS) || os(tvOS)
   83|      1|    func uiImage() throws -> UIImage {
   84|      1|        return try Inspector.cast(value: try rawImage(), type: UIImage.self)
   85|      1|    }
   86|       |    #else
   87|       |    func nsImage() throws -> NSImage {
   88|       |        return try Inspector.cast(value: try rawImage(), type: NSImage.self)
   89|       |    }
   90|       |    #endif
   91|       |    
   92|      0|    func cgImage() throws -> CGImage {
   93|      0|        return try Inspector
   94|      0|            .attribute(label: "image", value: rawImage(), type: CGImage.self)
   95|      0|    }
   96|       |    
   97|      0|    func orientation() throws -> Image.Orientation {
   98|      0|        return try Inspector
   99|      0|            .attribute(label: "orientation", value: rawImage(), type: Image.Orientation.self)
  100|      0|    }
  101|       |    
  102|      0|    func scale() throws -> CGFloat {
  103|      0|        return try Inspector
  104|      0|            .attribute(label: "scale", value: rawImage(), type: CGFloat.self)
  105|      0|    }
  106|       |    
  107|      1|    private func rawImage() throws -> Any {
  108|      1|        return try Inspector.attribute(path: "provider|base", value: try imageContent().view)
  109|      1|    }
  110|       |    
  111|      1|    private func imageContent() throws -> Content {
  112|      1|        return try Inspector.unwrap(image: self)
  113|      1|    }
  114|       |}
  115|       |
  116|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  117|       |private extension Inspector {
  118|      2|    static func unwrap(image: Image) throws -> Content {
  119|      2|        let provider = try Inspector.attribute(path: "provider|base", value: image)
  120|      1|        if let child = try? Inspector.attribute(label: "base", value: provider, type: Image.self) {
  121|      1|            let content = try unwrap(image: child)
  122|      1|            let medium = content.medium.appending(viewModifier: provider)
  123|      1|            return Content(content.view, medium: medium)
  124|      1|        }
  125|      1|        return Content(image)
  126|      2|    }
  127|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Label.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Label: KnownViewType {
    7|       |        public static let typePrefix: String = "Label"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func label() throws -> InspectableView<ViewType.Label> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func label(_ index: Int) throws -> InspectableView<ViewType.Label> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Non Standard Children
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.Label: SupplementaryChildren {
   35|      0|    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView> {
   36|      0|        return .init(count: 2) { index in
   37|      0|            let medium = parent.content.medium.resettingViewModifiers()
   38|      0|            if index == 0 {
   39|      0|                let child = try Inspector.attribute(label: "title", value: parent.content.view)
   40|      0|                let content = try Inspector.unwrap(content: Content(child, medium: medium))
   41|      0|                return try InspectableView<ViewType.ClassifiedView>(
   42|      0|                    content, parent: parent, call: "title()")
   43|      0|            } else {
   44|      0|                let child = try Inspector.attribute(label: "icon", value: parent.content.view)
   45|      0|                let content = try Inspector.unwrap(content: Content(child, medium: medium))
   46|      0|                return try InspectableView<ViewType.ClassifiedView>(
   47|      0|                    content, parent: parent, call: "icon()")
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|       |}
   52|       |
   53|       |// MARK: - Custom Attributes
   54|       |
   55|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   56|       |public extension InspectableView where View == ViewType.Label {
   57|       |    
   58|      0|    func title() throws -> InspectableView<ViewType.ClassifiedView> {
   59|      0|        return try View.supplementaryChildren(self).element(at: 0)
   60|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   61|      0|    }
   62|       |    
   63|      0|    func icon() throws -> InspectableView<ViewType.ClassifiedView> {
   64|      0|        return try View.supplementaryChildren(self).element(at: 1)
   65|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   66|      0|    }
   67|       |}
   68|       |
   69|       |// MARK: - Global View Modifiers
   70|       |
   71|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   72|       |public extension InspectableView {
   73|       |
   74|      0|    func labelStyle() throws -> Any {
   75|      0|        let modifier = try self.modifier({ modifier -> Bool in
   76|      0|            return modifier.modifierType.hasPrefix("LabelStyleModifier")
   77|      0|        }, call: "labelStyle")
   78|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   79|      0|    }
   80|       |}
   81|       |
   82|       |// MARK: - LabelStyle inspection
   83|       |
   84|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   85|       |public extension LabelStyle {
   86|      0|    func inspect() throws -> InspectableView<ViewType.ClassifiedView> {
   87|      0|        let config = LabelStyleConfiguration()
   88|      0|        let view = try makeBody(configuration: config).inspect()
   89|      0|        return try .init(view.content, parent: nil, index: nil)
   90|      0|    }
   91|       |}
   92|       |
   93|       |// MARK: - Style Configuration initializer
   94|       |
   95|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   96|       |private extension LabelStyleConfiguration {
   97|       |    struct Allocator { }
   98|      0|    init() {
   99|      0|        self = unsafeBitCast(Allocator(), to: Self.self)
  100|      0|    }
  101|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/LazyHGrid.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct LazyHGrid: KnownViewType {
    7|       |        public static var typePrefix: String = "LazyHGrid"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func lazyHGrid() throws -> InspectableView<ViewType.LazyHGrid> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func lazyHGrid(_ index: Int) throws -> InspectableView<ViewType.LazyHGrid> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Content Extraction
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.LazyHGrid: MultipleViewContent {
   35|       |    
   36|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   37|      0|        let view = try Inspector.attribute(path: "tree|content", value: content.view)
   38|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Custom Attributes
   43|       |
   44|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   45|       |public extension InspectableView where View == ViewType.LazyHGrid {
   46|       |    
   47|      0|    func alignment() throws -> VerticalAlignment {
   48|      0|        return try Inspector.attribute(
   49|      0|            label: "alignment", value: lazyHGridLayout(), type: VerticalAlignment.self)
   50|      0|    }
   51|       |    
   52|      0|    func spacing() throws -> CGFloat? {
   53|      0|        return try Inspector.attribute(
   54|      0|            label: "spacing", value: lazyHGridLayout(), type: CGFloat?.self)
   55|      0|    }
   56|       |    
   57|      0|    func pinnedViews() throws -> PinnedScrollableViews {
   58|      0|        return try Inspector.attribute(
   59|      0|            label: "pinnedViews", value: lazyHGridLayout(), type: PinnedScrollableViews.self)
   60|      0|    }
   61|       |    
   62|      0|    func rows() throws -> [GridItem] {
   63|      0|        return try Inspector.attribute(
   64|      0|            label: "rows", value: lazyHGridLayout(), type: [GridItem].self)
   65|      0|    }
   66|       |    
   67|      0|    private func lazyHGridLayout() throws -> Any {
   68|      0|        return try Inspector.attribute(path: "tree|root", value: content.view)
   69|      0|    }
   70|       |}
   71|       |
   72|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   73|       |extension GridItem: Equatable {
   74|      0|    public static func == (lhs: GridItem, rhs: GridItem) -> Bool {
   75|      0|        return lhs.size == rhs.size
   76|      0|            && lhs.spacing == rhs.spacing
   77|      0|            && lhs.alignment == rhs.alignment
   78|      0|    }
   79|       |}
   80|       |
   81|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   82|       |extension GridItem.Size: Equatable {
   83|      0|    public static func == (lhs: GridItem.Size, rhs: GridItem.Size) -> Bool {
   84|      0|        switch (lhs, rhs) {
   85|      0|        case let (.fixed(lhsValue), .fixed(rhsValue)):
   86|      0|            return lhsValue == rhsValue
   87|      0|        case let (.flexible(lhsMin, lhsMax), .flexible(rhsMin, rhsMax)):
   88|      0|            return lhsMin == rhsMin && lhsMax == rhsMax
   89|      0|        case let (.adaptive(lhsMin, lhsMax), .adaptive(rhsMin, rhsMax)):
   90|      0|            return lhsMin == rhsMin && lhsMax == rhsMax
   91|      0|        default:
   92|      0|            return false
   93|      0|        }
   94|      0|    }
   95|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/LazyHStack.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct LazyHStack: KnownViewType {
    7|       |        public static var typePrefix: String = "LazyHStack"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func lazyHStack() throws -> InspectableView<ViewType.LazyHStack> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func lazyHStack(_ index: Int) throws -> InspectableView<ViewType.LazyHStack> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Content Extraction
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.LazyHStack: MultipleViewContent {
   35|       |    
   36|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   37|      0|        let view = try Inspector.attribute(path: "tree|content", value: content.view)
   38|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Custom Attributes
   43|       |
   44|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   45|       |public extension InspectableView where View == ViewType.LazyHStack {
   46|       |    
   47|      0|    func alignment() throws -> VerticalAlignment {
   48|      0|        return try Inspector.attribute(
   49|      0|            path: "base|alignment", value: lazyHStackLayout(), type: VerticalAlignment.self)
   50|      0|    }
   51|       |    
   52|      0|    func spacing() throws -> CGFloat? {
   53|      0|        return try Inspector.attribute(
   54|      0|            path: "base|spacing", value: lazyHStackLayout(), type: CGFloat?.self)
   55|      0|    }
   56|       |    
   57|      0|    func pinnedViews() throws -> PinnedScrollableViews {
   58|      0|        return try Inspector.attribute(
   59|      0|            label: "pinnedViews", value: lazyHStackLayout(), type: PinnedScrollableViews.self)
   60|      0|    }
   61|       |    
   62|      0|    private func lazyHStackLayout() throws -> Any {
   63|      0|        return try Inspector.attribute(path: "tree|root", value: content.view)
   64|      0|    }
   65|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/LazyVGrid.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct LazyVGrid: KnownViewType {
    7|       |        public static var typePrefix: String = "LazyVGrid"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func lazyVGrid() throws -> InspectableView<ViewType.LazyVGrid> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func lazyVGrid(_ index: Int) throws -> InspectableView<ViewType.LazyVGrid> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Content Extraction
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.LazyVGrid: MultipleViewContent {
   35|       |    
   36|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   37|      0|        let view = try Inspector.attribute(path: "tree|content", value: content.view)
   38|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Custom Attributes
   43|       |
   44|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   45|       |public extension InspectableView where View == ViewType.LazyVGrid {
   46|       |    
   47|      0|    func alignment() throws -> HorizontalAlignment {
   48|      0|        return try Inspector.attribute(
   49|      0|            label: "alignment", value: lazyVGridLayout(), type: HorizontalAlignment.self)
   50|      0|    }
   51|       |    
   52|      0|    func spacing() throws -> CGFloat? {
   53|      0|        return try Inspector.attribute(
   54|      0|            label: "spacing", value: lazyVGridLayout(), type: CGFloat?.self)
   55|      0|    }
   56|       |    
   57|      0|    func pinnedViews() throws -> PinnedScrollableViews {
   58|      0|        return try Inspector.attribute(
   59|      0|            label: "pinnedViews", value: lazyVGridLayout(), type: PinnedScrollableViews.self)
   60|      0|    }
   61|       |    
   62|      0|    func columns() throws -> [GridItem] {
   63|      0|        return try Inspector.attribute(
   64|      0|            label: "columns", value: lazyVGridLayout(), type: [GridItem].self)
   65|      0|    }
   66|       |    
   67|      0|    private func lazyVGridLayout() throws -> Any {
   68|      0|        return try Inspector.attribute(path: "tree|root", value: content.view)
   69|      0|    }
   70|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/LazyVStack.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct LazyVStack: KnownViewType {
    7|       |        public static var typePrefix: String = "LazyVStack"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func lazyVStack() throws -> InspectableView<ViewType.LazyVStack> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func lazyVStack(_ index: Int) throws -> InspectableView<ViewType.LazyVStack> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Content Extraction
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.LazyVStack: MultipleViewContent {
   35|       |    
   36|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   37|      0|        let view = try Inspector.attribute(path: "tree|content", value: content.view)
   38|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Custom Attributes
   43|       |
   44|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   45|       |public extension InspectableView where View == ViewType.LazyVStack {
   46|       |    
   47|      0|    func alignment() throws -> HorizontalAlignment {
   48|      0|        return try Inspector.attribute(
   49|      0|            path: "base|alignment", value: lazyVStackLayout(), type: HorizontalAlignment.self)
   50|      0|    }
   51|       |    
   52|      0|    func spacing() throws -> CGFloat? {
   53|      0|        return try Inspector.attribute(
   54|      0|            path: "base|spacing", value: lazyVStackLayout(), type: CGFloat?.self)
   55|      0|    }
   56|       |    
   57|      0|    func pinnedViews() throws -> PinnedScrollableViews {
   58|      0|        return try Inspector.attribute(
   59|      0|            label: "pinnedViews", value: lazyVStackLayout(), type: PinnedScrollableViews.self)
   60|      0|    }
   61|       |    
   62|      0|    private func lazyVStackLayout() throws -> Any {
   63|      0|        return try Inspector.attribute(path: "tree|root", value: content.view)
   64|      0|    }
   65|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/LinearGradient.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct LinearGradient: KnownViewType {
    7|       |        public static var typePrefix: String = "LinearGradient"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func linearGradient() throws -> InspectableView<ViewType.LinearGradient> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func linearGradient(_ index: Int) throws -> InspectableView<ViewType.LinearGradient> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Custom Attributes
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |public extension InspectableView where View == ViewType.LinearGradient {
   35|       |    
   36|      0|    func gradient() throws -> Gradient {
   37|      0|        return try Inspector
   38|      0|            .attribute(label: "gradient", value: content.view, type: Gradient.self)
   39|      0|    }
   40|       |    
   41|      0|    func startPoint() throws -> UnitPoint {
   42|      0|        return try Inspector
   43|      0|            .attribute(label: "startPoint", value: content.view, type: UnitPoint.self)
   44|      0|    }
   45|       |    
   46|      0|    func endPoint() throws -> UnitPoint {
   47|      0|        return try Inspector
   48|      0|            .attribute(label: "endPoint", value: content.view, type: UnitPoint.self)
   49|      0|    }
   50|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Link.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Link: KnownViewType {
    7|       |        public static let typePrefix: String = "Link"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func link() throws -> InspectableView<ViewType.Link> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func link(_ index: Int) throws -> InspectableView<ViewType.Link> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Non Standard Children
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.Link: SupplementaryChildrenLabelView { }
   35|       |
   36|       |// MARK: - Custom Attributes
   37|       |
   38|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   39|       |public extension InspectableView where View == ViewType.Link {
   40|       |    
   41|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   42|      0|        return try View.supplementaryChildren(self).element(at: 0)
   43|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   44|      0|    }
   45|       |    
   46|      0|    func url() throws -> URL {
   47|      0|        return try Inspector.attribute(
   48|      0|            path: "destination|configuration|url", value: content.view, type: URL.self)
   49|      0|    }
   50|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/List.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct List: KnownViewType {
    7|       |        public static let typePrefix: String = "List"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.List: MultipleViewContent {
   15|       |    
   16|      3|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      3|        let view = try Inspector.attribute(label: "content", value: content.view)
   18|      3|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   19|      3|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from SingleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   25|       |public extension InspectableView where View: SingleViewContent {
   26|       |    
   27|      0|    func list() throws -> InspectableView<ViewType.List> {
   28|      0|        return try .init(try child(), parent: self)
   29|      0|    }
   30|       |}
   31|       |
   32|       |// MARK: - Extraction from MultipleViewContent parent
   33|       |
   34|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   35|       |public extension InspectableView where View: MultipleViewContent {
   36|       |    
   37|      0|    func list(_ index: Int) throws -> InspectableView<ViewType.List> {
   38|      0|        return try .init(try child(at: index), parent: self, index: index)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Global View Modifiers
   43|       |
   44|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   45|       |public extension InspectableView {
   46|       |    
   47|      0|    func listRowInsets() throws -> EdgeInsets {
   48|      0|        return try modifierAttribute(
   49|      0|            modifierName: "_TraitWritingModifier<ListRowInsetsTraitKey>",
   50|      0|            path: "modifier|value|some", type: EdgeInsets.self, call: "listRowInsets")
   51|      0|    }
   52|       |    
   53|      0|    func listRowBackground() throws -> InspectableView<ViewType.ClassifiedView> {
   54|      0|        return try contentForModifierLookup.listRowBackground(parent: self)
   55|      0|    }
   56|       |
   57|      0|    func listStyle() throws -> Any {
   58|      0|        let modifier = try self.modifier({ modifier -> Bool in
   59|      0|            return modifier.modifierType.hasPrefix("ListStyleWriter")
   60|      0|        }, call: "listStyle")
   61|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   62|      0|    }
   63|       |}
   64|       |
   65|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   66|       |internal extension Content {
   67|       |    
   68|      0|    func listRowBackground(parent: UnwrappedView) throws -> InspectableView<ViewType.ClassifiedView> {
   69|      0|        let view = try modifierAttribute(
   70|      0|            modifierName: "_TraitWritingModifier<ListRowBackgroundTraitKey>",
   71|      0|            path: "modifier|value|some|storage|view", type: Any.self, call: "listRowBackground")
   72|      0|        let medium = self.medium.resettingViewModifiers()
   73|      0|        return try .init(try Inspector.unwrap(content: Content(view, medium: medium)), parent: parent)
   74|      0|    }
   75|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Map.swift:
    1|       |#if canImport(MapKit)
    2|       |import MapKit
    3|       |import SwiftUI
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension ViewType {
    7|       |    struct Map: KnownViewType {
    8|       |        public static let typePrefix: String = "Map"
    9|      4|        public static var namespacedPrefixes: [String] {
   10|      4|            return ["_MapKit_SwiftUI." + typePrefix]
   11|      4|        }
   12|      0|        public static func inspectionCall(typeName: String) -> String {
   13|      0|            return "map(\(ViewType.indexPlaceholder))"
   14|      0|        }
   15|       |    }
   16|       |}
   17|       |
   18|       |// MARK: - Extraction from SingleViewContent parent
   19|       |
   20|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   21|       |public extension InspectableView where View: SingleViewContent {
   22|      0|    func map() throws -> InspectableView<ViewType.Map> {
   23|      0|        return try .init(try child(), parent: self)
   24|      0|    }
   25|       |}
   26|       |
   27|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   28|       |public extension InspectableView where View: MultipleViewContent {
   29|      0|    func map(_ index: Int) throws -> InspectableView<ViewType.Map> {
   30|      0|        return try .init(try child(at: index), parent: self, index: index)
   31|      0|    }
   32|       |}
   33|       |
   34|       |// MARK: - Custom Attributes
   35|       |
   36|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   37|       |public extension InspectableView where View == ViewType.Map {
   38|       |    
   39|      0|    func coordinateRegion() throws -> MKCoordinateRegion {
   40|      0|        return try coordinateRegionBinding().wrappedValue
   41|      0|    }
   42|       |    
   43|      0|    func setCoordinateRegion(_ region: MKCoordinateRegion) throws {
   44|      0|        try guardIsResponsive()
   45|      0|        try coordinateRegionBinding().wrappedValue = region
   46|      0|    }
   47|       |    
   48|      0|    func mapRect() throws -> MKMapRect {
   49|      0|        return try mapRectBinding().wrappedValue
   50|      0|    }
   51|       |    
   52|      0|    func setMapRect(_ rect: MKMapRect) throws {
   53|      0|        try guardIsResponsive()
   54|      0|        try mapRectBinding().wrappedValue = rect
   55|      0|    }
   56|       |    
   57|      0|    func userTrackingMode() throws -> MapUserTrackingMode {
   58|      0|        return try userTrackingModeBinding()?.wrappedValue ?? .none
   59|      0|    }
   60|       |    
   61|      0|    func setUserTrackingMode(_ mode: MapUserTrackingMode) throws {
   62|      0|        try guardIsResponsive()
   63|      0|        try userTrackingModeBinding()?.wrappedValue = mode
   64|      0|    }
   65|       |    
   66|      0|    func interactionModes() throws -> MapInteractionModes {
   67|      0|        return try Inspector.attribute(path: "provider|interactionModes",
   68|      0|                                       value: content.view,
   69|      0|                                       type: MapInteractionModes.self)
   70|      0|    }
   71|       |
   72|      0|    func showsUserLocation() throws -> Bool {
   73|      0|        return try Inspector.attribute(path: "provider|showsUserLocation",
   74|      0|                                       value: content.view,
   75|      0|                                       type: Bool.self)
   76|      0|    }
   77|       |    
   78|       |    func mapAnnotation<I>(_ item: I) throws -> InspectableView<ViewType.MapAnnotation>
   79|      0|    where I: Identifiable {
   80|      0|        let call = "mapAnnotation(id<\(item.id)>)"
   81|      0|        guard let provider = try? Inspector
   82|      0|                .attribute(label: "provider", value: content.view, type: IdentifiableItemsContainer.self),
   83|      0|              provider.contains(item) else {
   84|      0|            throw InspectionError.viewNotFound(parent: call)
   85|      0|        }
   86|      0|        typealias Builder = (I) -> _MapAnnotationData
   87|      0|        let builder = try Inspector.attribute(
   88|      0|            path: "provider|content|some", value: content.view, type: Builder.self)
   89|      0|        let annotation = builder(item)
   90|      0|        let medium = content.medium.resettingViewModifiers()
   91|      0|        return try .init(Content(annotation, medium: medium), parent: self, call: call)
   92|      0|    }
   93|       |}
   94|       |
   95|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   96|       |private extension InspectableView where View == ViewType.Map {
   97|       |    
   98|      0|    func coordinateRegionBinding() throws -> Binding<MKCoordinateRegion> {
   99|      0|        return try Inspector.attribute(path: "provider|region|region",
  100|      0|                                       value: content.view,
  101|      0|                                       type: Binding<MKCoordinateRegion>.self)
  102|      0|    }
  103|       |    
  104|      0|    func mapRectBinding() throws -> Binding<MKMapRect> {
  105|      0|        return try Inspector.attribute(path: "provider|region|rect",
  106|      0|                                       value: content.view,
  107|      0|                                       type: Binding<MKMapRect>.self)
  108|      0|    }
  109|       |    
  110|      0|    func userTrackingModeBinding() throws -> Binding<MapUserTrackingMode>? {
  111|      0|        return try Inspector.attribute(path: "provider|userTrackingMode",
  112|      0|                                       value: content.view,
  113|      0|                                       type: Binding<MapUserTrackingMode>?.self)
  114|      0|    }
  115|       |}
  116|       |
  117|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
  118|       |internal protocol IdentifiableItemsContainer {
  119|       |    func contains<T: Identifiable>(_ item: T) -> Bool
  120|       |}
  121|       |
  122|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
  123|       |extension _DefaultAnnotatedMapContent: IdentifiableItemsContainer {
  124|      0|    func contains<T: Identifiable>(_ item: T) -> Bool {
  125|      0|        guard let item = item as? Items.Element,
  126|      0|              let items = try? Inspector.attribute(label: "items", value: self, type: Items?.self)
  127|      0|        else { return false }
  128|      0|        return items.lazy.map({ $0.id }).contains(item.id)
  129|      0|    }
  130|       |}
  131|       |
  132|       |#endif

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/MapAnnotation.swift:
    1|       |#if canImport(MapKit)
    2|       |import MapKit
    3|       |import SwiftUI
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension ViewType {
    7|       |    struct MapAnnotation: KnownViewType {
    8|       |        public static let typePrefix: String = "_MapAnnotationData"
    9|      0|        public static var namespacedPrefixes: [String] {
   10|      0|            return ["_MapKit_SwiftUI." + typePrefix]
   11|      0|        }
   12|       |    }
   13|       |}
   14|       |
   15|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   16|       |public extension ViewType.MapAnnotation {
   17|       |    enum ViewType: String {
   18|       |        case pin
   19|       |        case marker
   20|       |        case custom
   21|       |    }
   22|       |}
   23|       |
   24|       |// MARK: - Custom Attributes
   25|       |
   26|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   27|       |public extension InspectableView where View == ViewType.MapAnnotation {
   28|       |    
   29|      0|    func coordinate() throws -> CLLocationCoordinate2D {
   30|      0|        return try Inspector.attribute(
   31|      0|            label: "coordinate", value: content.view, type: CLLocationCoordinate2D.self)
   32|      0|    }
   33|       |    
   34|      0|    var viewType: ViewType.MapAnnotation.ViewType {
   35|      0|        let value = try? Inspector.attribute(label: "viewType", value: content.view)
   36|      0|        return value
   37|      0|            .flatMap { String(describing: $0) }
   38|      0|            .flatMap { ViewType.MapAnnotation.ViewType(rawValue: $0) } ?? .custom
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - SwiftUI MapAnnotation
   43|       |
   44|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   45|       |public extension MapAnnotation {
   46|       |    
   47|      0|    func coordinate() throws -> CLLocationCoordinate2D {
   48|      0|        return try Inspector.attribute(
   49|      0|            label: "coordinate", value: self, type: CLLocationCoordinate2D.self)
   50|      0|    }
   51|       |    
   52|      0|    func anchorPoint() throws -> CGPoint {
   53|      0|        return try Inspector.attribute(
   54|      0|            label: "anchorPoint", value: self, type: CGPoint.self)
   55|      0|    }
   56|       |    
   57|      0|    func contentView() throws -> InspectableView<ViewType.ClassifiedView> {
   58|      0|        let view = try Inspector.attribute(label: "content", value: self)
   59|      0|        let content = ViewInspector.Content(view, medium: .empty)
   60|      0|        return try .init(try Inspector.unwrap(content: content), parent: nil)
   61|      0|    }
   62|       |}
   63|       |
   64|       |// MARK: - SwiftUI MapMarker
   65|       |
   66|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   67|       |public extension MapMarker {
   68|       |    
   69|      0|    func coordinate() throws -> CLLocationCoordinate2D {
   70|      0|        return try Inspector.attribute(
   71|      0|            label: "coordinate", value: self, type: CLLocationCoordinate2D.self)
   72|      0|    }
   73|       |    
   74|      0|    func tintColor() throws -> Color? {
   75|      0|        return try Inspector.attribute(
   76|      0|            label: "tintColor", value: self, type: Color?.self)
   77|      0|    }
   78|       |}
   79|       |
   80|       |// MARK: - SwiftUI MapPin
   81|       |
   82|       |@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
   83|       |public extension MapPin {
   84|       |    
   85|      0|    func coordinate() throws -> CLLocationCoordinate2D {
   86|      0|        return try Inspector.attribute(
   87|      0|            label: "coordinate", value: self, type: CLLocationCoordinate2D.self)
   88|      0|    }
   89|       |    
   90|      0|    func tintColor() throws -> Color? {
   91|      0|        return try Inspector.attribute(
   92|      0|            label: "tintColor", value: self, type: Color?.self)
   93|      0|    }
   94|       |}
   95|       |
   96|       |#endif

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Menu.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Menu: KnownViewType {
    7|       |        public static let typePrefix: String = "Menu"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, *)
   14|       |@available(tvOS, unavailable)
   15|       |public extension InspectableView where View: SingleViewContent {
   16|       |    
   17|      0|    func menu() throws -> InspectableView<ViewType.Menu> {
   18|      0|        return try .init(try child(), parent: self)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from MultipleViewContent parent
   23|       |
   24|       |@available(iOS 14.0, macOS 11.0, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func menu(_ index: Int) throws -> InspectableView<ViewType.Menu> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Content Extraction
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |extension ViewType.Menu: MultipleViewContent {
   37|       |    
   38|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   39|      0|        let view = try Inspector.attribute(path: "content", value: content.view)
   40|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   41|      0|    }
   42|       |}
   43|       |
   44|       |// MARK: - Non Standard Children
   45|       |
   46|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   47|       |extension ViewType.Menu: SupplementaryChildrenLabelView { }
   48|       |
   49|       |// MARK: - Custom Attributes
   50|       |
   51|       |@available(iOS 14.0, macOS 11.0, *)
   52|       |@available(tvOS, unavailable)
   53|       |public extension InspectableView where View == ViewType.Menu {
   54|       |    
   55|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   56|      0|        return try View.supplementaryChildren(self).element(at: 0)
   57|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   58|      0|    }
   59|       |}
   60|       |
   61|       |// MARK: - Global View Modifiers
   62|       |
   63|       |@available(iOS 14.0, macOS 11.0, *)
   64|       |@available(tvOS, unavailable)
   65|       |public extension InspectableView {
   66|       |
   67|      0|    func menuStyle() throws -> Any {
   68|      0|        let modifier = try self.modifier({ modifier -> Bool in
   69|      0|            return modifier.modifierType.hasPrefix("MenuStyleModifier")
   70|      0|        }, call: "menuStyle")
   71|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   72|      0|    }
   73|       |}
   74|       |
   75|       |// MARK: - MenuStyle inspection
   76|       |
   77|       |@available(iOS 14.0, macOS 11.0, *)
   78|       |@available(tvOS, unavailable)
   79|       |public extension MenuStyle {
   80|      0|    func inspect() throws -> InspectableView<ViewType.ClassifiedView> {
   81|      0|        let config = MenuStyleConfiguration()
   82|      0|        let view = try makeBody(configuration: config).inspect()
   83|      0|        return try .init(view.content, parent: nil, index: nil)
   84|      0|    }
   85|       |}
   86|       |
   87|       |// MARK: - Style Configuration initializer
   88|       |
   89|       |@available(iOS 14.0, macOS 11.0, *)
   90|       |@available(tvOS, unavailable)
   91|       |private extension MenuStyleConfiguration {
   92|       |    struct Allocator { }
   93|      0|    init() {
   94|      0|        self = unsafeBitCast(Allocator(), to: Self.self)
   95|      0|    }
   96|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/NavigationLink.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct NavigationLink: KnownViewType {
    7|       |        public static var typePrefix: String = "NavigationLink"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.NavigationLink: SingleViewContent {
   15|       |    
   16|      0|    public static func child(_ content: Content) throws -> Content {
   17|      0|        let view = try Inspector.attribute(label: "destination", value: content.view)
   18|      0|        let medium = content.medium.resettingViewModifiers()
   19|      0|        return try Inspector.unwrap(view: view, medium: medium)
   20|      0|    }
   21|       |}
   22|       |
   23|       |// MARK: - Extraction from SingleViewContent parent
   24|       |
   25|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   26|       |public extension InspectableView where View: SingleViewContent {
   27|       |    
   28|      0|    func navigationLink() throws -> InspectableView<ViewType.NavigationLink> {
   29|      0|        return try .init(try child(), parent: self)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Extraction from MultipleViewContent parent
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |public extension InspectableView where View: MultipleViewContent {
   37|       |    
   38|      0|    func navigationLink(_ index: Int) throws -> InspectableView<ViewType.NavigationLink> {
   39|      0|        return try .init(try child(at: index), parent: self, index: index)
   40|      0|    }
   41|       |}
   42|       |
   43|       |// MARK: - Non Standard Children
   44|       |
   45|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   46|       |extension ViewType.NavigationLink: SupplementaryChildrenLabelView { }
   47|       |
   48|       |// MARK: - Custom Attributes
   49|       |
   50|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   51|       |public extension InspectableView where View == ViewType.NavigationLink {
   52|       |    
   53|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   54|      0|        return try View.supplementaryChildren(self).element(at: 0)
   55|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   56|      0|    }
   57|       |    
   58|      0|    func isActive() throws -> Bool {
   59|      0|        guard let external = try isActiveBinding() else {
   60|      0|            return try isActiveState().wrappedValue
   61|      0|        }
   62|      0|        return external.wrappedValue
   63|      0|    }
   64|       |    
   65|      0|    func activate() throws { try set(isActive: true) }
   66|       |    
   67|      0|    func deactivate() throws { try set(isActive: false) }
   68|       |    
   69|      0|    private func set(isActive: Bool) throws {
   70|      0|        if let external = try isActiveBinding() {
   71|      0|            external.wrappedValue = isActive
   72|      0|        } else {
   73|      0|            // @State mutation from outside is ignored by SwiftUI
   74|      0|            // try isActiveState().wrappedValue = isActive
   75|      0|            // swiftlint:disable line_length
   76|      0|            throw InspectionError.notSupported("Enable programmatic navigation by using `NavigationLink(destination:, tag:, selection:)`")
   77|      0|            // swiftlint:enable line_length
   78|      0|        }
   79|      0|    }
   80|       |}
   81|       |
   82|       |// MARK: - Private
   83|       |
   84|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   85|       |private extension InspectableView where View == ViewType.NavigationLink {
   86|      0|    func isActiveState() throws -> State<Bool> {
   87|      0|        if #available(iOS 14, tvOS 14, macOS 10.16, *) {
   88|      0|            return try Inspector
   89|      0|                .attribute(path: "_isActive|state", value: content.view, type: State<Bool>.self)
   90|      0|        }
   91|      0|        return try Inspector
   92|      0|            .attribute(label: "__internalIsActive", value: content.view, type: State<Bool>.self)
   93|      0|    }
   94|       |    
   95|      0|    func isActiveBinding() throws -> Binding<Bool>? {
   96|      0|        if #available(iOS 14, tvOS 14, macOS 10.16, *) {
   97|      0|            return try? Inspector
   98|      0|                .attribute(path: "_isActive|binding", value: content.view, type: Binding<Bool>.self)
   99|      0|        }
  100|      0|        return try? Inspector
  101|      0|            .attribute(label: "_externalIsActive", value: content.view, type: Binding<Bool>.self)
  102|      0|    }
  103|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/NavigationView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct NavigationView: KnownViewType {
    7|       |        public static var typePrefix: String = "NavigationView"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.NavigationView: MultipleViewContent {
   15|       |    
   16|     12|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|     12|        let path: String
   18|     12|        if #available(iOS 13.1, *) {
   19|     12|            path = "content"
   20|     12|        } else {
   21|      0|            path = "_tree|content"
   22|     12|        }
   23|     12|        let view = try Inspector.attribute(path: path, value: content.view)
   24|     12|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   25|     12|    }
   26|       |}
   27|       |
   28|       |// MARK: - Extraction from SingleViewContent parent
   29|       |
   30|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   31|       |public extension InspectableView where View: SingleViewContent {
   32|       |    
   33|      8|    func navigationView() throws -> InspectableView<ViewType.NavigationView> {
   34|      8|        return try .init(try child(), parent: self)
   35|      8|    }
   36|       |}
   37|       |
   38|       |// MARK: - Extraction from MultipleViewContent parent
   39|       |
   40|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   41|       |public extension InspectableView where View: MultipleViewContent {
   42|       |    
   43|      0|    func navigationView(_ index: Int) throws -> InspectableView<ViewType.NavigationView> {
   44|      0|        return try .init(try child(at: index), parent: self, index: index)
   45|      0|    }
   46|       |}
   47|       |
   48|       |// MARK: - Global View Modifiers
   49|       |
   50|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   51|       |public extension InspectableView {
   52|       |
   53|      0|    func navigationViewStyle() throws -> Any {
   54|      0|        let modifier = try self.modifier({ modifier -> Bool in
   55|      0|            return modifier.modifierType.hasPrefix("NavigationViewStyleModifier")
   56|      0|        }, call: "navigationViewStyle")
   57|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   58|      0|    }
   59|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/OptionalContent.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType {
    5|       |    struct OptionalContent {}
    6|       |}
    7|       |
    8|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    9|       |extension ViewType.OptionalContent: SingleViewContent {
   10|       |
   11|     13|    static func child(_ content: Content) throws -> Content {
   12|      0|        guard let child = try? Inspector.attribute(label: "some", value: content.view) else {
   13|      0|            throw InspectionError.viewNotFound(parent: Inspector.typeName(value: content.view as Any))
   14|     13|        }
   15|     13|        return try Inspector.unwrap(view: child, medium: content.medium)
   16|     13|    }
   17|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/OutlineGroup.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct OutlineGroup: KnownViewType {
    7|       |        public static var typePrefix: String = "OutlineGroup"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, *)
   14|       |@available(tvOS, unavailable)
   15|       |public extension InspectableView where View: SingleViewContent {
   16|       |    
   17|      0|    func outlineGroup() throws -> InspectableView<ViewType.OutlineGroup> {
   18|      0|        return try .init(try child(), parent: self)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from MultipleViewContent parent
   23|       |
   24|       |@available(iOS 14.0, macOS 11.0, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func outlineGroup(_ index: Int) throws -> InspectableView<ViewType.OutlineGroup> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Custom Attributes
   34|       |
   35|       |@available(iOS 14.0, macOS 11.0, *)
   36|       |@available(tvOS, unavailable)
   37|       |public extension InspectableView where View == ViewType.OutlineGroup {
   38|       |    
   39|      0|    func sourceData<T>(_ type: T.Type) throws -> T {
   40|      0|        let root = try (try? Inspector.attribute(path: "base|forest", value: content.view)) ??
   41|      0|            (try Inspector.attribute(path: "base|tree", value: content.view))
   42|      0|        guard let data = root as? T else {
   43|      0|            throw InspectionError.typeMismatch(root, T.self)
   44|      0|        }
   45|      0|        return data
   46|      0|    }
   47|       |    
   48|      0|    func leaf(_ dataElement: Any) throws -> InspectableView<ViewType.ClassifiedView> {
   49|      0|        let provider = try Inspector.cast(value: content.view, type: LeafContentProvider.self)
   50|      0|        let medium = content.medium.resettingViewModifiers()
   51|      0|        return try .init(Content(try provider.view(dataElement), medium: medium), parent: self)
   52|      0|    }
   53|       |}
   54|       |
   55|       |// MARK: - Private
   56|       |
   57|       |private protocol LeafContentProvider {
   58|       |    func view(_ element: Any) throws -> Any
   59|       |}
   60|       |
   61|       |@available(iOS 14.0, macOS 11.0, *)
   62|       |@available(tvOS, unavailable)
   63|       |extension OutlineGroup: LeafContentProvider {
   64|      0|    func view(_ element: Any) throws -> Any {
   65|      0|        guard let data = element as? Data.Element else {
   66|      0|            throw InspectionError.typeMismatch(element, Data.Element.self)
   67|      0|        }
   68|      0|        typealias Builder = (Data.Element) -> Leaf
   69|      0|        let builder = try Inspector
   70|      0|            .attribute(label: "leafContent", value: self, type: Builder.self)
   71|      0|        return builder(data)
   72|      0|    }
   73|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Overlay.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Overlay: KnownViewType {
    7|       |        public static var typePrefix: String = ""
    8|      0|        public static var isTransitive: Bool { true }
    9|       |    }
   10|       |}
   11|       |
   12|       |// MARK: - Extraction
   13|       |
   14|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   15|       |public extension InspectableView {
   16|       |
   17|      0|    func overlay() throws -> InspectableView<ViewType.Overlay> {
   18|      0|        return try contentForModifierLookup.overlay(parent: self)
   19|      0|    }
   20|       |    
   21|      0|    func background() throws -> InspectableView<ViewType.Overlay> {
   22|      0|        return try contentForModifierLookup.background(parent: self)
   23|      0|    }
   24|       |}
   25|       |
   26|       |// MARK: - Content
   27|       |
   28|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   29|       |extension ViewType.Overlay: SingleViewContent {
   30|       |    
   31|      0|    public static func child(_ content: Content) throws -> Content {
   32|      0|        return content
   33|      0|    }
   34|       |}
   35|       |
   36|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   37|       |extension ViewType.Overlay: MultipleViewContent {
   38|       |    
   39|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   40|      0|        return try Inspector.viewsInContainer(view: content.view, medium: content.medium)
   41|      0|    }
   42|       |}
   43|       |
   44|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   45|       |internal extension Content {
   46|       |    
   47|      0|    func overlay(parent: UnwrappedView) throws -> InspectableView<ViewType.Overlay> {
   48|      0|        let modifier = try self.modifier({ modifier -> Bool in
   49|      0|            return modifier.modifierType.contains("_OverlayModifier")
   50|      0|        }, call: "overlay")
   51|      0|        let rootView = try Inspector.attribute(path: "modifier|overlay", value: modifier)
   52|      0|        let alignment = try Inspector.attribute(path: "modifier|alignment", value: modifier, type: Alignment.self)
   53|      0|        let overlayParams = ViewType.Overlay.Params(alignment: alignment)
   54|      0|        let medium = self.medium.resettingViewModifiers()
   55|      0|            .appending(viewModifier: overlayParams)
   56|      0|        let content = try Inspector.unwrap(content: Content(rootView, medium: medium))
   57|      0|        return try .init(content, parent: parent, call: "overlay()")
   58|      0|    }
   59|       |    
   60|      0|    func background(parent: UnwrappedView) throws -> InspectableView<ViewType.Overlay> {
   61|      0|        let modifier = try self.modifier({ modifier -> Bool in
   62|      0|            return modifier.modifierType.contains("_BackgroundModifier")
   63|      0|        }, call: "background")
   64|      0|        let rootView = try Inspector.attribute(path: "modifier|background", value: modifier)
   65|      0|        let alignment = try Inspector.attribute(path: "modifier|alignment", value: modifier, type: Alignment.self)
   66|      0|        let overlayParams = ViewType.Overlay.Params(alignment: alignment)
   67|      0|        let medium = self.medium.resettingViewModifiers()
   68|      0|            .appending(viewModifier: overlayParams)
   69|      0|        let content = try Inspector.unwrap(content: Content(rootView, medium: medium))
   70|      0|        return try .init(content, parent: parent, call: "background()")
   71|      0|    }
   72|       |}
   73|       |
   74|       |// MARK: - Custom Attributes
   75|       |
   76|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   77|       |public extension InspectableView where View == ViewType.Overlay {
   78|       |
   79|      0|    func alignment() throws -> Alignment {
   80|      0|        guard let params = content.medium.viewModifiers
   81|      0|            .compactMap({ $0 as? ViewType.Overlay.Params }).first else {
   82|      0|            throw InspectionError.attributeNotFound(label: "alignment", type: "Overlay")
   83|      0|        }
   84|      0|        return params.alignment
   85|      0|    }
   86|       |}
   87|       |
   88|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   89|       |private extension ViewType.Overlay {
   90|       |    struct Params {
   91|       |        let alignment: Alignment
   92|       |    }
   93|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Picker.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Picker: KnownViewType {
    7|       |        public static let typePrefix: String = "Picker"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.Picker: MultipleViewContent {
   15|       |    
   16|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   18|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from SingleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   25|       |public extension InspectableView where View: SingleViewContent {
   26|       |    
   27|      0|    func picker() throws -> InspectableView<ViewType.Picker> {
   28|      0|        return try .init(try child(), parent: self)
   29|      0|    }
   30|       |}
   31|       |
   32|       |// MARK: - Extraction from MultipleViewContent parent
   33|       |
   34|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   35|       |public extension InspectableView where View: MultipleViewContent {
   36|       |    
   37|      0|    func picker(_ index: Int) throws -> InspectableView<ViewType.Picker> {
   38|      0|        return try .init(try child(at: index), parent: self, index: index)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Non Standard Children
   43|       |
   44|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   45|       |extension ViewType.Picker: SupplementaryChildrenLabelView { }
   46|       |
   47|       |// MARK: - Custom Attributes
   48|       |
   49|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   50|       |public extension InspectableView where View == ViewType.Picker {
   51|       |    
   52|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   53|      0|        return try View.supplementaryChildren(self).element(at: 0)
   54|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   55|      0|    }
   56|       |    
   57|      0|    func select<SelectionValue>(value: SelectionValue) throws where SelectionValue: Hashable {
   58|      0|        try guardIsResponsive()
   59|      0|        let binding = try Inspector.attribute(path: "selection", value: content.view)
   60|      0|        let typeName = Inspector.typeName(value: binding)
   61|      0|        guard let casted = binding as? Binding<SelectionValue> else {
   62|      0|            let expected = String(Array(Array(typeName)[8..<typeName.count - 1]))
   63|      0|            let factual = Inspector.typeName(type: SelectionValue.self)
   64|      0|            throw InspectionError
   65|      0|            .notSupported("select(value:) expects a value of type \(expected) but received \(factual)")
   66|      0|        }
   67|      0|        casted.wrappedValue = value
   68|      0|    }
   69|       |}
   70|       |
   71|       |// MARK: - Global View Modifiers
   72|       |
   73|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   74|       |public extension InspectableView {
   75|       |
   76|      0|    func pickerStyle() throws -> Any {
   77|      0|        let modifier = try self.modifier({ modifier -> Bool in
   78|      0|            return modifier.modifierType.hasPrefix("PickerStyleWriter")
   79|      0|        }, call: "pickerStyle")
   80|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   81|      0|    }
   82|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Popover.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Popover: KnownViewType {
    7|       |        public static var typePrefix: String = ""
    8|      0|        public static var isTransitive: Bool { true }
    9|       |    }
   10|       |}
   11|       |
   12|       |// MARK: - Extraction
   13|       |
   14|       |@available(iOS 14.2, macOS 11.0, *)
   15|       |@available(tvOS, unavailable)
   16|       |public extension InspectableView {
   17|       |    
   18|      0|    func popover() throws -> InspectableView<ViewType.Popover> {
   19|      0|        return try contentForModifierLookup.popover(parent: self)
   20|      0|    }
   21|       |}
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |internal extension Content {
   25|       |    
   26|      0|    func popover(parent: UnwrappedView) throws -> InspectableView<ViewType.Popover> {
   27|      0|        let modifier = try modifierAttribute(
   28|      0|            modifierName: "PopoverPresentationModifier", path: "modifier",
   29|      0|            type: Any.self, call: "popover")
   30|      0|        let medium = self.medium.resettingViewModifiers()
   31|      0|        return try .init(try Inspector.unwrap(content: Content(modifier, medium: medium)),
   32|      0|                         parent: parent, call: "popover()")
   33|      0|    }
   34|       |}
   35|       |
   36|       |// MARK: - Custom Attributes
   37|       |
   38|       |@available(iOS 14.2, macOS 11.0, *)
   39|       |@available(tvOS, unavailable)
   40|       |public extension InspectableView where View == ViewType.Popover {
   41|       |    
   42|      0|    func contentView() throws -> InspectableView<ViewType.ClassifiedView> {
   43|      0|        return try contentView(EmptyView.self)
   44|      0|    }
   45|       |    
   46|      0|    func contentView<T>(_ viewType: T.Type) throws -> InspectableView<ViewType.ClassifiedView> {
   47|      0|        
   48|      0|        typealias Closure = () -> T
   49|      0|        let closure = try Inspector.attribute(label: "popoverContent", value: content.view)
   50|      0|        let closureDesc = Inspector.typeName(value: closure)
   51|      0|        
   52|      0|        let expectedViewType = closureDesc.components(separatedBy: "() -> ").last ?? ""
   53|      0|        guard Inspector.typeName(type: viewType) == expectedViewType else {
   54|      0|            throw InspectionError.notSupported(
   55|      0|                "Please substitute '\(expectedViewType).self' as the parameter for 'contentView()' inspection call")
   56|      0|        }
   57|      0|        guard let typedClosure = withUnsafeBytes(of: closure, {
   58|      0|            $0.bindMemory(to: Closure.self).first
   59|      0|        }) else { throw InspectionError.typeMismatch(closure, Closure.self) }
   60|      0|        let view = typedClosure()
   61|      0|        let medium = content.medium.resettingViewModifiers()
   62|      0|        return try .init(try Inspector.unwrap(content: Content(view, medium: medium)), parent: self)
   63|      0|    }
   64|       |    
   65|      0|    func arrowEdge() throws -> Edge {
   66|      0|        return try Inspector.attribute(label: "arrowEdge", value: content.view, type: Edge.self)
   67|      0|    }
   68|       |    
   69|      0|    func attachmentAnchor() throws -> PopoverAttachmentAnchor {
   70|      0|        return try Inspector.attribute(label: "attachmentAnchor", value: content.view,
   71|      0|                                       type: PopoverAttachmentAnchor.self)
   72|      0|    }
   73|       |    
   74|      0|    func isPresented() throws -> Bool {
   75|      0|        return try isPresentedBinding().wrappedValue
   76|      0|    }
   77|       |    
   78|      0|    func dismiss() throws {
   79|      0|        typealias OnDismiss = () -> Void
   80|      0|        let onDismiss = try Inspector.attribute(
   81|      0|            label: "onDismiss", value: content.view, type: OnDismiss.self)
   82|      0|        onDismiss()
   83|      0|        try isPresentedBinding().wrappedValue = false
   84|      0|    }
   85|       |    
   86|      0|    private func isPresentedBinding() throws -> Binding<Bool> {
   87|      0|        return try Inspector.attribute(
   88|      0|            label: "_isPresented", value: content.view, type: Binding<Bool>.self)
   89|      0|    }
   90|       |}
   91|       |
   92|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   93|       |extension PopoverAttachmentAnchor: Equatable {
   94|      0|    public static func == (lhs: PopoverAttachmentAnchor, rhs: PopoverAttachmentAnchor) -> Bool {
   95|      0|        switch (lhs, rhs) {
   96|      0|        case let (.rect(lhsAnchor), .rect(rhsAnchor)):
   97|      0|            return lhsAnchor == rhsAnchor
   98|      0|        case let (.point(lhsPoint), .point(rhsPoint)):
   99|      0|            return lhsPoint == rhsPoint
  100|      0|        default:
  101|      0|            return false
  102|      0|        }
  103|      0|    }
  104|       |}
  105|       |
  106|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  107|       |extension Anchor.Source: Equatable where Value == CGRect {
  108|      0|    public static func == (lhs: Anchor<Value>.Source, rhs: Anchor<Value>.Source) -> Bool {
  109|      0|        return String(describing: lhs) == String(describing: rhs)
  110|      0|    }
  111|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ProgressView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct ProgressView: KnownViewType {
    7|       |        public static var typePrefix: String = "ProgressView"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func progressView() throws -> InspectableView<ViewType.ProgressView> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func progressView(_ index: Int) throws -> InspectableView<ViewType.ProgressView> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Non Standard Children
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.ProgressView: SupplementaryChildren {
   35|      0|    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView> {
   36|      0|        return .init(count: 2) { index in
   37|      0|            let medium = parent.content.medium.resettingViewModifiers()
   38|      0|            if index == 0 {
   39|      0|                let child = try Inspector.attribute(
   40|      0|                    path: "base|custom|label|some", value: parent.content.view)
   41|      0|                let content = try Inspector.unwrap(content: Content(child, medium: medium))
   42|      0|                return try InspectableView<ViewType.ClassifiedView>(
   43|      0|                    content, parent: parent, call: "labelView()")
   44|      0|            } else {
   45|      0|                let child = try Inspector.attribute(
   46|      0|                    path: "base|custom|currentValueLabel|some", value: parent.content.view)
   47|      0|                let content = try Inspector.unwrap(content: Content(child, medium: medium))
   48|      0|                return try InspectableView<ViewType.ClassifiedView>(
   49|      0|                    content, parent: parent, call: "currentValueLabelView()")
   50|      0|            }
   51|      0|        }
   52|      0|    }
   53|       |}
   54|       |
   55|       |// MARK: - Custom Attributes
   56|       |
   57|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   58|       |public extension InspectableView where View == ViewType.ProgressView {
   59|       |    
   60|      0|    func fractionCompleted() throws -> Double? {
   61|      0|        return try Inspector
   62|      0|            .attribute(path: "base|custom|fractionCompleted", value: content.view, type: Double?.self)
   63|      0|    }
   64|       |    
   65|      0|    func progress() throws -> Progress {
   66|      0|        if let value = try? Inspector
   67|      0|            .attribute(path: "base|observing|_progress|wrappedValue|base",
   68|      0|                       value: content.view, type: Progress.self) {
   69|      0|            return value
   70|      0|        }
   71|      0|        return try Inspector
   72|      0|            .attribute(path: "base|observing|progress",
   73|      0|                       value: content.view, type: Progress.self)
   74|      0|    }
   75|       |    
   76|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   77|      0|        return try View.supplementaryChildren(self).element(at: 0)
   78|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   79|      0|    }
   80|       |    
   81|      0|    func currentValueLabelView() throws -> InspectableView<ViewType.ClassifiedView> {
   82|      0|        return try View.supplementaryChildren(self).element(at: 1)
   83|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   84|      0|    }
   85|       |}
   86|       |
   87|       |// MARK: - Global View Modifiers
   88|       |
   89|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   90|       |public extension InspectableView {
   91|       |
   92|      0|    func progressViewStyle() throws -> Any {
   93|      0|        let modifier = try self.modifier({ modifier -> Bool in
   94|      0|            return modifier.modifierType.hasPrefix("ProgressViewStyleModifier")
   95|      0|        }, call: "progressViewStyle")
   96|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   97|      0|    }
   98|       |}
   99|       |
  100|       |// MARK: - ProgressViewStyle inspection
  101|       |
  102|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
  103|       |public extension ProgressViewStyle {
  104|      0|    func inspect(fractionCompleted: Double? = nil) throws -> InspectableView<ViewType.ClassifiedView> {
  105|      0|        let config = ProgressViewStyleConfiguration(fractionCompleted: fractionCompleted)
  106|      0|        let view = try makeBody(configuration: config).inspect()
  107|      0|        return try .init(view.content, parent: nil, index: nil)
  108|      0|    }
  109|       |}
  110|       |
  111|       |// MARK: - Style Configuration initializer
  112|       |
  113|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
  114|       |internal extension ProgressViewStyleConfiguration {
  115|       |    private struct Allocator {
  116|       |        let fractionCompleted: Double?
  117|       |        let data: Int16 = 0
  118|       |    }
  119|      0|    init(fractionCompleted: Double?) {
  120|      0|        self = unsafeBitCast(Allocator(fractionCompleted: fractionCompleted), to: Self.self)
  121|      0|    }
  122|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/RadialGradient.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct RadialGradient: KnownViewType {
    7|       |        public static var typePrefix: String = "RadialGradient"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func radialGradient() throws -> InspectableView<ViewType.RadialGradient> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func radialGradient(_ index: Int) throws -> InspectableView<ViewType.RadialGradient> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Custom Attributes
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |public extension InspectableView where View == ViewType.RadialGradient {
   35|       |    
   36|      0|    func gradient() throws -> Gradient {
   37|      0|        return try Inspector
   38|      0|            .attribute(label: "gradient", value: content.view, type: Gradient.self)
   39|      0|    }
   40|       |    
   41|      0|    func center() throws -> UnitPoint {
   42|      0|        return try Inspector
   43|      0|            .attribute(label: "center", value: content.view, type: UnitPoint.self)
   44|      0|    }
   45|       |    
   46|      0|    func startRadius() throws -> CGFloat {
   47|      0|        return try Inspector
   48|      0|            .attribute(label: "startRadius", value: content.view, type: CGFloat.self)
   49|      0|    }
   50|       |    
   51|      0|    func endRadius() throws -> CGFloat {
   52|      0|        return try Inspector
   53|      0|            .attribute(label: "endRadius", value: content.view, type: CGFloat.self)
   54|      0|    }
   55|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ScrollView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct ScrollView: KnownViewType {
    7|       |        public static var typePrefix: String = "ScrollView"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.ScrollView: SingleViewContent {
   15|       |    
   16|      0|    public static func child(_ content: Content) throws -> Content {
   17|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   18|      0|        let medium = content.medium.resettingViewModifiers()
   19|      0|        return try Inspector.unwrap(view: view, medium: medium)
   20|      0|    }
   21|       |}
   22|       |
   23|       |// MARK: - Extraction from SingleViewContent parent
   24|       |
   25|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   26|       |public extension InspectableView where View: SingleViewContent {
   27|       |    
   28|      0|    func scrollView() throws -> InspectableView<ViewType.ScrollView> {
   29|      0|        return try .init(try child(), parent: self)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Extraction from MultipleViewContent parent
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |public extension InspectableView where View: MultipleViewContent {
   37|       |    
   38|      0|    func scrollView(_ index: Int) throws -> InspectableView<ViewType.ScrollView> {
   39|      0|        return try .init(try child(at: index), parent: self, index: index)
   40|      0|    }
   41|       |}
   42|       |
   43|       |// MARK: - Custom Attributes
   44|       |
   45|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   46|       |public extension InspectableView where View == ViewType.ScrollView {
   47|       |    
   48|      0|    func contentInsets() throws -> EdgeInsets {
   49|      0|        return try Inspector.attribute(path: "configuration|contentInsets",
   50|      0|                                       value: content.view, type: EdgeInsets.self)
   51|      0|    }
   52|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ScrollViewReader.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct ScrollViewReader: KnownViewType {
    7|       |        public static var typePrefix: String = "ScrollViewReader"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func scrollViewReader() throws -> InspectableView<ViewType.ScrollViewReader> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func scrollViewReader(_ index: Int) throws -> InspectableView<ViewType.ScrollViewReader> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Content Extraction
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.ScrollViewReader: SingleViewContent {
   35|       |    
   36|      0|    public static func child(_ content: Content) throws -> Content {
   37|      0|        let provider = try Inspector.cast(value: content.view, type: ScrollViewReaderContentProvider.self)
   38|      0|        let medium = content.medium.resettingViewModifiers()
   39|      0|        return try Inspector.unwrap(view: provider.view(), medium: medium)
   40|      0|    }
   41|       |}
   42|       |
   43|       |// MARK: - Private
   44|       |
   45|       |private protocol ScrollViewReaderContentProvider {
   46|       |    func view() throws -> Any
   47|       |}
   48|       |
   49|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   50|       |extension ScrollViewReader: ScrollViewReaderContentProvider {
   51|      0|    func view() throws -> Any {
   52|      0|        typealias Builder = (ScrollViewProxy) -> Content
   53|      0|        let builder = try Inspector
   54|      0|            .attribute(label: "content", value: self, type: Builder.self)
   55|      0|        return builder(ScrollViewProxy())
   56|      0|    }
   57|       |}
   58|       |
   59|       |@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   60|       |private extension ScrollViewProxy {
   61|       |    struct Allocator8 {
   62|       |        let data: Int64 = 0
   63|       |    }
   64|       |    
   65|      0|    init() {
   66|      0|        self = unsafeBitCast(Allocator8(), to: ScrollViewProxy.self)
   67|      0|    }
   68|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Section.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Section: KnownViewType {
    7|       |        public static let typePrefix: String = "Section"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.Section: MultipleViewContent {
   15|       |    
   16|      9|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      9|        let view = try Inspector.attribute(label: "content", value: content.view)
   18|      9|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   19|      9|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from SingleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   25|       |public extension InspectableView where View: SingleViewContent {
   26|       |    
   27|      0|    func section() throws -> InspectableView<ViewType.Section> {
   28|      0|        return try .init(try child(), parent: self)
   29|      0|    }
   30|       |}
   31|       |
   32|       |// MARK: - Extraction from MultipleViewContent parent
   33|       |
   34|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   35|       |public extension InspectableView where View: MultipleViewContent {
   36|       |    
   37|      0|    func section(_ index: Int) throws -> InspectableView<ViewType.Section> {
   38|      0|        return try .init(try child(at: index), parent: self, index: index)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Non Standard Children
   43|       |
   44|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   45|       |extension ViewType.Section: SupplementaryChildren {
   46|      9|    static func supplementaryChildren(_ parent: UnwrappedView) throws -> LazyGroup<SupplementaryView> {
   47|      0|        return .init(count: 2) { index in
   48|      0|            let medium = parent.content.medium.resettingViewModifiers()
   49|      0|            if index == 0 {
   50|      0|                let child = try Inspector.attribute(label: "header", value: parent.content.view)
   51|      0|                let content = try Inspector.unwrap(content: Content(child, medium: medium))
   52|      0|                return try InspectableView<ViewType.ClassifiedView>(content, parent: parent, call: "header()")
   53|      0|            } else {
   54|      0|                let child = try Inspector.attribute(label: "footer", value: parent.content.view)
   55|      0|                let content = try Inspector.unwrap(content: Content(child, medium: medium))
   56|      0|                return try InspectableView<ViewType.ClassifiedView>(content, parent: parent, call: "footer()")
   57|      0|            }
   58|      0|        }
   59|      9|    }
   60|       |}
   61|       |
   62|       |// MARK: - Custom Attributes
   63|       |
   64|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   65|       |public extension InspectableView where View == ViewType.Section {
   66|       |    
   67|      0|    func header() throws -> InspectableView<ViewType.ClassifiedView> {
   68|      0|        return try View.supplementaryChildren(self).element(at: 0)
   69|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   70|      0|    }
   71|       |    
   72|      0|    func footer() throws -> InspectableView<ViewType.ClassifiedView> {
   73|      0|        return try View.supplementaryChildren(self).element(at: 1)
   74|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   75|      0|    }
   76|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/SecureField.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct SecureField: KnownViewType {
    7|       |        public static var typePrefix: String = "SecureField"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func secureField() throws -> InspectableView<ViewType.SecureField> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func secureField(_ index: Int) throws -> InspectableView<ViewType.SecureField> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Non Standard Children
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.SecureField: SupplementaryChildrenLabelView { }
   35|       |
   36|       |// MARK: - Custom Attributes
   37|       |
   38|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   39|       |public extension InspectableView where View == ViewType.SecureField {
   40|       |    
   41|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   42|      0|        return try View.supplementaryChildren(self).element(at: 0)
   43|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   44|      0|    }
   45|       |    
   46|      0|    func input() throws -> String {
   47|      0|        return try inputBinding().wrappedValue
   48|      0|    }
   49|       |    
   50|      0|    func setInput(_ value: String) throws {
   51|      0|        try guardIsResponsive()
   52|      0|        try inputBinding().wrappedValue = value
   53|      0|    }
   54|       |    
   55|      0|    private func inputBinding() throws -> Binding<String> {
   56|      0|        return try Inspector.attribute(
   57|      0|            label: "text", value: content.view, type: Binding<String>.self)
   58|      0|    }
   59|       |    
   60|      0|    func callOnCommit() throws {
   61|      0|        typealias Callback = () -> Void
   62|      0|        let callback = try Inspector
   63|      0|            .attribute(label: "onCommit", value: content.view, type: Callback.self)
   64|      0|        callback()
   65|      0|    }
   66|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Shape.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Shape: KnownViewType {
    7|       |        public static var typePrefix: String = ""
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func shape() throws -> InspectableView<ViewType.Shape> {
   17|      0|        let content = try child()
   18|      0|        try guardShapeIsInspectable(content.view)
   19|      0|        return try .init(content, parent: self)
   20|      0|    }
   21|       |}
   22|       |
   23|       |// MARK: - Extraction from MultipleViewContent parent
   24|       |
   25|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func shape(_ index: Int) throws -> InspectableView<ViewType.Shape> {
   29|      0|        let content = try child(at: index)
   30|      0|        try guardShapeIsInspectable(content.view)
   31|      0|        return try .init(content, parent: self, index: index)
   32|      0|    }
   33|       |}
   34|       |
   35|       |// MARK: - Custom Attributes
   36|       |
   37|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   38|       |public extension InspectableView where View == ViewType.Shape {
   39|       |    
   40|      0|    func path(in rect: CGRect) throws -> Path {
   41|      0|        guard let shape = content.view as? InspectableShape else {
   42|      0|            throw InspectionError.notSupported(
   43|      0|                "Please put a void '.offset()' modifier before or after '.inset(by:)'")
   44|      0|        }
   45|      0|        return shape.path(in: rect)
   46|      0|    }
   47|       |    
   48|      0|    func inset() throws -> CGFloat {
   49|      0|        return try shapeAttribute(content.view, "_Inset", "amount", CGFloat.self)
   50|      0|    }
   51|       |    
   52|      0|    func offset() throws -> CGSize {
   53|      0|        return try shapeAttribute(content.view, "OffsetShape", "offset", CGSize.self)
   54|      0|    }
   55|       |    
   56|      0|    func scale() throws -> (x: CGFloat, y: CGFloat, anchor: UnitPoint) {
   57|      0|        let size = try shapeAttribute(content.view, "ScaledShape", "scale", CGSize.self)
   58|      0|        let anchor = try shapeAttribute(content.view, "ScaledShape", "anchor", UnitPoint.self)
   59|      0|        return (size.width, size.height, anchor)
   60|      0|    }
   61|       |    
   62|      0|    func rotation() throws -> (angle: Angle, anchor: UnitPoint) {
   63|      0|        let angle = try shapeAttribute(content.view, "RotatedShape", "angle", Angle.self)
   64|      0|        let anchor = try shapeAttribute(content.view, "RotatedShape", "anchor", UnitPoint.self)
   65|      0|        return (angle, anchor)
   66|      0|    }
   67|       |    
   68|      0|    func transform() throws -> CGAffineTransform {
   69|      0|        return try shapeAttribute(content.view, "TransformedShape", "transform", CGAffineTransform.self)
   70|      0|    }
   71|       |    
   72|      0|    func size() throws -> CGSize {
   73|      0|        return try shapeAttribute(content.view, "_SizedShape", "size", CGSize.self)
   74|      0|    }
   75|       |    
   76|      0|    func strokeStyle() throws -> StrokeStyle {
   77|      0|        return try shapeAttribute(content.view, "_StrokedShape", "style", StrokeStyle.self)
   78|      0|    }
   79|       |    
   80|      0|    func trim() throws -> (from: CGFloat, to: CGFloat) {
   81|      0|        let from = try shapeAttribute(content.view, "_TrimmedShape", "startFraction", CGFloat.self)
   82|      0|        let to = try shapeAttribute(content.view, "_TrimmedShape", "endFraction", CGFloat.self)
   83|      0|        return (from, to)
   84|      0|    }
   85|       |    
   86|      0|    func fillShapeStyle<S>(_ style: S.Type) throws -> S where S: ShapeStyle {
   87|      0|        return try shapeAttribute(content.view, "_ShapeView", "style", S.self)
   88|      0|    }
   89|       |    
   90|      0|    func fillStyle() throws -> FillStyle {
   91|      0|        return try shapeAttribute(content.view, "_ShapeView", "fillStyle", FillStyle.self)
   92|      0|    }
   93|       |}
   94|       |
   95|       |// MARK: - Private
   96|       |
   97|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   98|       |private extension InspectableView {
   99|       |    
  100|      0|    func guardShapeIsInspectable(_ view: Any) throws {
  101|      0|        guard view is InspectableShape || Inspector.typeName(value: view) == "_Inset" else {
  102|      0|            throw InspectionError.typeMismatch(view, InspectableShape.self)
  103|      0|        }
  104|      0|    }
  105|       |    
  106|       |    func shapeAttribute<T>(_ view: Any, _ shapeType: String, _ label: String, _ attributeType: T.Type
  107|      0|    ) throws -> T {
  108|      0|        let shape = try lookupShape(view, typeName: shapeType, label: label)
  109|      0|        return try Inspector.attribute(label: label, value: shape, type: attributeType)
  110|      0|    }
  111|       |    
  112|      0|    func lookupShape(_ view: Any, typeName: String, label: String) throws -> Any {
  113|      0|        let name = Inspector.typeName(value: view, prefixOnly: true)
  114|      0|        if name.hasPrefix(typeName) {
  115|      0|            return view
  116|      0|        }
  117|      0|        guard let containedShape = try? Inspector.attribute(label: "shape", value: view) else {
  118|      0|            let typeName = Inspector.typeName(value: view)
  119|      0|            throw InspectionError.attributeNotFound(label: label, type: typeName)
  120|      0|        }
  121|      0|        return try lookupShape(containedShape, typeName: typeName, label: label)
  122|      0|    }
  123|       |}
  124|       |
  125|       |// MARK: - InspectableShape
  126|       |
  127|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  128|       |public protocol InspectableShape {
  129|       |    func path(in rect: CGRect) -> Path
  130|       |}
  131|       |
  132|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  133|       |extension Rectangle: InspectableShape { }
  134|       |
  135|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  136|       |extension Circle: InspectableShape { }
  137|       |
  138|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  139|       |extension Ellipse: InspectableShape { }
  140|       |
  141|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  142|       |extension Capsule: InspectableShape { }
  143|       |
  144|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  145|       |extension Path: InspectableShape { }
  146|       |
  147|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  148|       |extension RoundedRectangle: InspectableShape { }
  149|       |
  150|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  151|       |extension TransformedShape: InspectableShape { }
  152|       |
  153|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  154|       |extension OffsetShape: InspectableShape { }
  155|       |
  156|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  157|       |extension RotatedShape: InspectableShape { }
  158|       |
  159|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  160|       |extension ScaledShape: InspectableShape { }
  161|       |
  162|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  163|       |extension _SizedShape: InspectableShape { }
  164|       |
  165|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  166|       |extension _StrokedShape: InspectableShape { }
  167|       |
  168|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  169|       |extension _TrimmedShape: InspectableShape { }
  170|       |
  171|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  172|       |extension _ShapeView: InspectableShape {
  173|      0|    public func path(in rect: CGRect) -> Path {
  174|      0|        return shape.path(in: rect)
  175|      0|    }
  176|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Sheet.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Sheet
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public extension ViewType {
    7|       |    
    8|       |    struct Sheet: KnownViewType {
    9|       |        public static var typePrefix: String = "ViewType.Sheet.Container"
   10|      8|        public static var namespacedPrefixes: [String] {
   11|      8|            return ["ViewInspector." + typePrefix]
   12|      8|        }
   13|      0|        public static func inspectionCall(typeName: String) -> String {
   14|      0|            return "sheet(\(ViewType.indexPlaceholder))"
   15|      0|        }
   16|       |    }
   17|       |}
   18|       |
   19|       |// MARK: - Content Extraction
   20|       |
   21|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   22|       |extension ViewType.Sheet: SingleViewContent {
   23|       |    
   24|      0|    public static func child(_ content: Content) throws -> Content {
   25|      0|        let view = try Inspector.attribute(label: "view", value: content.view)
   26|      0|        let medium = content.medium.resettingViewModifiers()
   27|      0|        return try Inspector.unwrap(view: view, medium: medium)
   28|      0|    }
   29|       |}
   30|       |
   31|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   32|       |extension ViewType.Sheet: MultipleViewContent {
   33|       |    
   34|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   35|      0|        let view = try Inspector.attribute(label: "view", value: content.view)
   36|      0|        let medium = content.medium.resettingViewModifiers()
   37|      0|        return try Inspector.viewsInContainer(view: view, medium: medium)
   38|      0|    }
   39|       |}
   40|       |
   41|       |// MARK: - Extraction
   42|       |
   43|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   44|       |public extension InspectableView {
   45|       |
   46|      0|    func sheet(_ index: Int? = nil) throws -> InspectableView<ViewType.Sheet> {
   47|      0|        return try contentForModifierLookup.sheet(parent: self, index: index)
   48|      0|    }
   49|       |}
   50|       |
   51|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   52|       |internal extension Content {
   53|       |    
   54|     98|    func sheet(parent: UnwrappedView, index: Int?) throws -> InspectableView<ViewType.Sheet> {
   55|     98|        guard let sheetBuilder = try? self.modifierAttribute(
   56|    212|                modifierLookup: { isSheetBuilder(modifier: $0) }, path: "modifier",
   57|      0|                type: SheetBuilder.self, call: "", index: index ?? 0)
   58|     98|        else {
   59|    212|            _ = try self.modifier({
   60|    212|                $0.modifierType == "IdentifiedPreferenceTransformModifier<Key>"
   61|    212|                || $0.modifierType.contains("SheetPresentationModifier")
   62|    212|            }, call: "sheet")
   63|     98|            throw InspectionError.notSupported(
   64|     98|                """
   65|     98|                Please refer to the Guide for inspecting the Sheet: \
   66|     98|                https://github.com/nalexn/ViewInspector/blob/master/guide.md#sheet
   67|     98|                """)
   68|      0|        }
   69|      0|        let view = try sheetBuilder.buildSheet()
   70|      0|        let container = ViewType.Sheet.Container(view: view, builder: sheetBuilder)
   71|      0|        let medium = self.medium.resettingViewModifiers()
   72|      0|        let content = Content(container, medium: medium)
   73|      0|        let call = ViewType.inspectionCall(
   74|      0|            base: ViewType.Sheet.inspectionCall(typeName: ""), index: index)
   75|      0|        return try .init(content, parent: parent, call: call, index: index)
   76|     98|    }
   77|       |    
   78|    124|    func sheetsForSearch() -> [ViewSearch.ModifierIdentity] {
   79|    124|        let count = medium.viewModifiers
   80|    114|            .compactMap { isSheetBuilder(modifier: $0) }
   81|    124|            .count
   82|    114|        return Array(0..<count).map { _ in
   83|     98|            .init(name: "", builder: { parent, index in
   84|     98|                try parent.content.sheet(parent: parent, index: index)
   85|     98|            })
   86|    114|        }
   87|    124|    }
   88|       |    
   89|    326|    private func isSheetBuilder(modifier: Any) -> Bool {
   90|    326|        return (try? Inspector.attribute(
   91|    326|            label: "modifier", value: modifier, type: SheetBuilder.self)) != nil
   92|    326|    }
   93|       |}
   94|       |
   95|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   96|       |internal extension ViewType.Sheet {
   97|       |    struct Container: CustomViewIdentityMapping {
   98|       |        let view: Any
   99|       |        let builder: SheetBuilder
  100|       |        
  101|      0|        var viewTypeForSearch: KnownViewType.Type { ViewType.Sheet.self }
  102|       |    }
  103|       |}
  104|       |
  105|       |// MARK: - Custom Attributes
  106|       |
  107|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  108|       |public extension InspectableView where View == ViewType.Sheet {
  109|       |
  110|      0|    func callOnDismiss() throws {
  111|      0|        let sheet = try Inspector.cast(value: content.view, type: ViewType.Sheet.Container.self)
  112|      0|        sheet.builder.dismissPopup()
  113|      0|    }
  114|       |}
  115|       |
  116|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  117|       |public protocol SheetBuilder: SystemPopupPresenter {
  118|       |    var onDismiss: (() -> Void)? { get }
  119|       |    func buildSheet() throws -> Any
  120|       |}
  121|       |
  122|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  123|       |public protocol SheetProvider: SheetBuilder {
  124|       |    var isPresented: Binding<Bool> { get }
  125|       |    var sheetBuilder: () -> Any { get }
  126|       |}
  127|       |
  128|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  129|       |public protocol SheetItemProvider: SheetBuilder {
  130|       |    associatedtype Item: Identifiable
  131|       |    var item: Binding<Item?> { get }
  132|       |    var sheetBuilder: (Item) -> Any { get }
  133|       |}
  134|       |
  135|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  136|       |public extension SheetProvider {
  137|       |    
  138|      0|    func buildSheet() throws -> Any {
  139|      0|        guard isPresented.wrappedValue else {
  140|      0|            throw InspectionError.viewNotFound(parent: "Sheet")
  141|      0|        }
  142|      0|        return sheetBuilder()
  143|      0|    }
  144|       |    
  145|      0|    func dismissPopup() {
  146|      0|        isPresented.wrappedValue = false
  147|      0|        onDismiss?()
  148|      0|    }
  149|       |}
  150|       |
  151|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  152|       |public extension SheetItemProvider {
  153|       |    
  154|      0|    func buildSheet() throws -> Any {
  155|      0|        guard let value = item.wrappedValue else {
  156|      0|            throw InspectionError.viewNotFound(parent: "Sheet")
  157|      0|        }
  158|      0|        return sheetBuilder(value)
  159|      0|    }
  160|       |    
  161|      0|    func dismissPopup() {
  162|      0|        item.wrappedValue = nil
  163|      0|        onDismiss?()
  164|      0|    }
  165|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Slider.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Slider: KnownViewType {
    7|       |        public static var typePrefix: String = "Slider"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, *)
   14|       |@available(tvOS, unavailable)
   15|       |public extension InspectableView where View: SingleViewContent {
   16|       |    
   17|      0|    func slider() throws -> InspectableView<ViewType.Slider> {
   18|      0|        return try .init(try child(), parent: self)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from MultipleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func slider(_ index: Int) throws -> InspectableView<ViewType.Slider> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Non Standard Children
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |extension ViewType.Slider: SupplementaryChildrenLabelView { }
   37|       |
   38|       |// MARK: - Custom Attributes
   39|       |
   40|       |@available(iOS 13.0, macOS 10.15, *)
   41|       |@available(tvOS, unavailable)
   42|       |public extension InspectableView where View == ViewType.Slider {
   43|       |    
   44|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   45|      0|        return try View.supplementaryChildren(self).element(at: 0)
   46|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   47|      0|    }
   48|       |    
   49|      0|    func value() throws -> Double {
   50|      0|        return try valueBinding().wrappedValue
   51|      0|    }
   52|       |    
   53|      0|    func setValue(_ value: Double) throws {
   54|      0|        try guardIsResponsive()
   55|      0|        try valueBinding().wrappedValue = value
   56|      0|    }
   57|       |    
   58|      0|    private func valueBinding() throws -> Binding<Double> {
   59|      0|        return try Inspector
   60|      0|            .attribute(label: "_value", value: content.view, type: Binding<Double>.self)
   61|      0|    }
   62|       |    
   63|      0|    func callOnEditingChanged() throws {
   64|      0|        typealias Callback = (Bool) -> Void
   65|      0|        let callback = try Inspector
   66|      0|            .attribute(label: "onEditingChanged", value: content.view, type: Callback.self)
   67|      0|        callback(false)
   68|      0|    }
   69|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Spacer.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Spacer: KnownViewType {
    7|       |        public static var typePrefix: String = "Spacer"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func spacer() throws -> InspectableView<ViewType.Spacer> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func spacer(_ index: Int) throws -> InspectableView<ViewType.Spacer> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Custom Attributes
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |public extension InspectableView where View == ViewType.Spacer {
   35|       |    
   36|      0|    func minLength() throws -> CGFloat? {
   37|      0|        return try Inspector
   38|      0|            .attribute(label: "minLength", value: content.view, type: CGFloat?.self)
   39|      0|    }
   40|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Stepper.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Stepper: KnownViewType {
    7|       |        public static var typePrefix: String = "Stepper"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, *)
   14|       |@available(tvOS, unavailable)
   15|       |public extension InspectableView where View: SingleViewContent {
   16|       |    
   17|      0|    func stepper() throws -> InspectableView<ViewType.Stepper> {
   18|      0|        return try .init(try child(), parent: self)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from MultipleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func stepper(_ index: Int) throws -> InspectableView<ViewType.Stepper> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Non Standard Children
   34|       |
   35|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   36|       |extension ViewType.Stepper: SupplementaryChildrenLabelView { }
   37|       |
   38|       |// MARK: - Custom Attributes
   39|       |
   40|       |@available(iOS 13.0, macOS 10.15, *)
   41|       |@available(tvOS, unavailable)
   42|       |public extension InspectableView where View == ViewType.Stepper {
   43|       |    
   44|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   45|      0|        return try View.supplementaryChildren(self).element(at: 0)
   46|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   47|      0|    }
   48|       |    
   49|      0|    func increment() throws {
   50|      0|        try guardIsResponsive()
   51|      0|        typealias Callback = () -> Void
   52|      0|        let callback = try Inspector
   53|      0|            .attribute(path: path(to: "onIncrement"), value: content.view, type: Callback.self)
   54|      0|        callback()
   55|      0|    }
   56|       |    
   57|      0|    func decrement() throws {
   58|      0|        try guardIsResponsive()
   59|      0|        typealias Callback = () -> Void
   60|      0|        let callback = try Inspector
   61|      0|            .attribute(path: path(to: "onDecrement"), value: content.view, type: Callback.self)
   62|      0|        callback()
   63|      0|    }
   64|       |    
   65|      0|    func callOnEditingChanged() throws {
   66|      0|        typealias Callback = (Bool) -> Void
   67|      0|        let callback = try Inspector
   68|      0|            .attribute(path: path(to: "onEditingChanged"), value: content.view, type: Callback.self)
   69|      0|        callback(false)
   70|      0|    }
   71|       |    
   72|      0|    private func path(to attribute: String) -> String {
   73|      0|        if #available(iOS 13.4, macOS 10.15.4, *) {
   74|      0|            return "configuration|\(attribute)"
   75|      0|        }
   76|      0|        return attribute
   77|      0|    }
   78|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/StyleConfiguration.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    struct StyleConfiguration { }
    6|       |}
    7|       |
    8|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    9|       |public extension ViewType.StyleConfiguration {
   10|       |    struct Label: KnownViewType {
   11|       |        public static var typePrefix: String = "Label"
   12|       |        
   13|      0|        public static var namespacedPrefixes: [String] {
   14|      0|            var types: [Any.Type] = [
   15|      0|                PrimitiveButtonStyleConfiguration.Label.self,
   16|      0|                ButtonStyleConfiguration.Label.self,
   17|      0|                ToggleStyleConfiguration.Label.self
   18|      0|            ]
   19|      0|            if #available(iOS 14.0, macOS 11.0, tvOS 14.0, *) {
   20|      0|                types.append(ProgressViewStyleConfiguration.Label.self)
   21|      0|                #if !os(tvOS)
   22|      0|                types.append(GroupBoxStyleConfiguration.Label.self)
   23|      0|                types.append(MenuStyleConfiguration.Label.self)
   24|      0|                #endif
   25|      0|            }
   26|      0|            return types
   27|      0|                .map { Inspector.typeName(type: $0, namespaced: true, prefixOnly: true) }
   28|      0|        }
   29|       |        
   30|      0|        public static func inspectionCall(typeName: String) -> String {
   31|      0|            return "styleConfigurationLabel(\(ViewType.indexPlaceholder))"
   32|      0|        }
   33|       |    }
   34|       |    
   35|       |    struct Content: KnownViewType {
   36|       |        public static var typePrefix: String = "Content"
   37|       |        
   38|     11|        public static var namespacedPrefixes: [String] {
   39|     11|            var types: [Any.Type] = []
   40|     11|            if #available(iOS 14.0, macOS 11.0, tvOS 14.0, *) {
   41|     11|                #if !os(tvOS)
   42|     11|                types.append(GroupBoxStyleConfiguration.Content.self)
   43|     11|                types.append(MenuStyleConfiguration.Content.self)
   44|     11|                #endif
   45|     11|            }
   46|     11|            return types
   47|     22|                .map { Inspector.typeName(type: $0, namespaced: true, prefixOnly: true) }
   48|     11|        }
   49|       |        
   50|      0|        public static func inspectionCall(typeName: String) -> String {
   51|      0|            return "styleConfigurationContent(\(ViewType.indexPlaceholder))"
   52|      0|        }
   53|       |    }
   54|       |    
   55|       |    struct Title: KnownViewType {
   56|       |        public static var typePrefix: String = "Title"
   57|       |        
   58|      7|        public static var namespacedPrefixes: [String] {
   59|      7|            var types: [Any.Type] = []
   60|      7|            if #available(iOS 14.0, macOS 11.0, tvOS 14.0, *) {
   61|      7|                types.append(LabelStyleConfiguration.Title.self)
   62|      7|            }
   63|      7|            return types
   64|      7|                .map { Inspector.typeName(type: $0, namespaced: true, prefixOnly: true) }
   65|      7|        }
   66|       |        
   67|      0|        public static func inspectionCall(typeName: String) -> String {
   68|      0|            return "styleConfigurationTitle(\(ViewType.indexPlaceholder))"
   69|      0|        }
   70|       |    }
   71|       |    
   72|       |    struct Icon: KnownViewType {
   73|       |        public static var typePrefix: String = "Icon"
   74|       |        
   75|      0|        public static var namespacedPrefixes: [String] {
   76|      0|            var types: [Any.Type] = []
   77|      0|            if #available(iOS 14.0, macOS 11.0, tvOS 14.0, *) {
   78|      0|                types.append(LabelStyleConfiguration.Icon.self)
   79|      0|            }
   80|      0|            return types
   81|      0|                .map { Inspector.typeName(type: $0, namespaced: true, prefixOnly: true) }
   82|      0|        }
   83|       |        
   84|      0|        public static func inspectionCall(typeName: String) -> String {
   85|      0|            return "styleConfigurationIcon(\(ViewType.indexPlaceholder))"
   86|      0|        }
   87|       |    }
   88|       |    
   89|       |    struct CurrentValueLabel: KnownViewType {
   90|       |        public static var typePrefix: String = "CurrentValueLabel"
   91|       |        
   92|     11|        public static var namespacedPrefixes: [String] {
   93|     11|            var types: [Any.Type] = []
   94|     11|            if #available(iOS 14.0, macOS 11.0, tvOS 14.0, *) {
   95|     11|                types.append(ProgressViewStyleConfiguration.CurrentValueLabel.self)
   96|     11|            }
   97|     11|            return types
   98|     11|                .map { Inspector.typeName(type: $0, namespaced: true, prefixOnly: true) }
   99|     11|        }
  100|       |        
  101|      0|        public static func inspectionCall(typeName: String) -> String {
  102|      0|            return "styleConfigurationCurrentValueLabel(\(ViewType.indexPlaceholder))"
  103|      0|        }
  104|       |    }
  105|       |}
  106|       |
  107|       |// MARK: - Extraction from SingleViewContent parent
  108|       |
  109|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  110|       |public extension InspectableView where View: SingleViewContent {
  111|       |    
  112|      0|    func styleConfigurationLabel() throws -> InspectableView<ViewType.StyleConfiguration.Label> {
  113|      0|        return try .init(try child(), parent: self)
  114|      0|    }
  115|       |    
  116|      0|    func styleConfigurationContent() throws -> InspectableView<ViewType.StyleConfiguration.Content> {
  117|      0|        return try .init(try child(), parent: self)
  118|      0|    }
  119|       |    
  120|      0|    func styleConfigurationTitle() throws -> InspectableView<ViewType.StyleConfiguration.Title> {
  121|      0|        return try .init(try child(), parent: self)
  122|      0|    }
  123|       |    
  124|      0|    func styleConfigurationIcon() throws -> InspectableView<ViewType.StyleConfiguration.Icon> {
  125|      0|        return try .init(try child(), parent: self)
  126|      0|    }
  127|       |    
  128|       |    func styleConfigurationCurrentValueLabel() throws ->
  129|      0|    InspectableView<ViewType.StyleConfiguration.CurrentValueLabel> {
  130|      0|        return try .init(try child(), parent: self)
  131|      0|    }
  132|       |}
  133|       |
  134|       |// MARK: - Extraction from MultipleViewContent parent
  135|       |
  136|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  137|       |public extension InspectableView where View: MultipleViewContent {
  138|       |    
  139|      0|    func styleConfigurationLabel(_ index: Int) throws -> InspectableView<ViewType.StyleConfiguration.Label> {
  140|      0|        return try .init(try child(at: index), parent: self, index: index)
  141|      0|    }
  142|       |    
  143|      0|    func styleConfigurationContent(_ index: Int) throws -> InspectableView<ViewType.StyleConfiguration.Content> {
  144|      0|        return try .init(try child(at: index), parent: self, index: index)
  145|      0|    }
  146|       |    
  147|      0|    func styleConfigurationTitle(_ index: Int) throws -> InspectableView<ViewType.StyleConfiguration.Title> {
  148|      0|        return try .init(try child(at: index), parent: self, index: index)
  149|      0|    }
  150|       |    
  151|      0|    func styleConfigurationIcon(_ index: Int) throws -> InspectableView<ViewType.StyleConfiguration.Icon> {
  152|      0|        return try .init(try child(at: index), parent: self, index: index)
  153|      0|    }
  154|       |    
  155|       |    func styleConfigurationCurrentValueLabel(_ index: Int) throws ->
  156|      0|    InspectableView<ViewType.StyleConfiguration.CurrentValueLabel> {
  157|      0|        return try .init(try child(at: index), parent: self, index: index)
  158|      0|    }
  159|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/SubscriptionView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType {
    5|       |    struct SubscriptionView {}
    6|       |}
    7|       |
    8|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    9|       |extension ViewType.SubscriptionView: SingleViewContent {
   10|       |
   11|    237|    static func child(_ content: Content) throws -> Content {
   12|    237|        let view = try Inspector.attribute(label: "content", value: content.view)
   13|    237|        return try Inspector.unwrap(view: view, medium: content.medium)
   14|    237|    }
   15|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/TabView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct TabView: KnownViewType {
    7|       |        public static var typePrefix: String = "TabView"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.TabView: MultipleViewContent {
   15|       |    
   16|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      0|        let view = try Inspector.attribute(label: "content", value: content.view)
   18|      0|        return try Inspector.viewsInContainer(view: view, medium: content.medium)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from SingleViewContent parent
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   25|       |public extension InspectableView where View: SingleViewContent {
   26|       |    
   27|      0|    func tabView() throws -> InspectableView<ViewType.TabView> {
   28|      0|        return try .init(try child(), parent: self)
   29|      0|    }
   30|       |}
   31|       |
   32|       |// MARK: - Extraction from MultipleViewContent parent
   33|       |
   34|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   35|       |public extension InspectableView where View: MultipleViewContent {
   36|       |    
   37|      0|    func tabView(_ index: Int) throws -> InspectableView<ViewType.TabView> {
   38|      0|        return try .init(try child(at: index), parent: self, index: index)
   39|      0|    }
   40|       |}
   41|       |
   42|       |// MARK: - Global View Modifiers
   43|       |
   44|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   45|       |public extension InspectableView {
   46|       |    
   47|      0|    func tag() throws -> AnyHashable {
   48|      0|        return try modifierAttribute(
   49|      0|            modifierName: "TagValueTraitKey",
   50|      0|            path: "modifier|value|tagged", type: AnyHashable.self, call: "tag")
   51|      0|    }
   52|       |    
   53|      0|    func tabItem() throws -> InspectableView<ViewType.ClassifiedView> {
   54|      0|        return try contentForModifierLookup.tabItem(parent: self)
   55|      0|    }
   56|       |
   57|       |    @available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   58|      0|    func tabViewStyle() throws -> Any {
   59|      0|        let modifier = try self.modifier({ modifier -> Bool in
   60|      0|            return modifier.modifierType.hasPrefix("_TabViewStyleWriter")
   61|      0|        }, call: "tabViewStyle")
   62|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   63|      0|    }
   64|       |    
   65|       |    @available(iOS 14.0, tvOS 14.0, *)
   66|       |    @available(macOS, unavailable)
   67|      0|    func indexViewStyle() throws -> Any {
   68|      0|        let modifier = try self.modifier({ modifier -> Bool in
   69|      0|            return modifier.modifierType.hasPrefix("IndexViewStyleModifier")
   70|      0|        }, call: "indexViewStyle")
   71|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   72|      0|    }
   73|       |}
   74|       |
   75|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   76|       |internal extension Content {
   77|       |    
   78|      0|    func tabItem(parent: UnwrappedView) throws -> InspectableView<ViewType.ClassifiedView> {
   79|      0|        let rootView = try modifierAttribute(
   80|      0|            modifierName: "TabItemTraitKey", path: "modifier|value|some|storage|view|content",
   81|      0|            type: Any.self, call: "tabItem")
   82|      0|        let medium = self.medium.resettingViewModifiers()
   83|      0|        let view = try InspectableView<ViewType.ClassifiedView>(
   84|      0|            try Inspector.unwrap(content: Content(rootView, medium: medium)), parent: parent, call: "tabItem()")
   85|      0|        if #available(iOS 14.2, tvOS 14.2, *) {
   86|      0|            return try InspectableView<ViewType.ClassifiedView>(
   87|      0|            try Inspector.unwrap(content: try view.zStack().child(at: 0)), parent: parent, call: "tabItem()")
   88|      0|        } else {
   89|      0|            return view
   90|      0|        }
   91|      0|    }
   92|       |}
   93|       |
   94|       |@available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
   95|       |@available(macOS, unavailable)
   96|       |extension PageTabViewStyle: Equatable {
   97|       |    
   98|      0|    public var indexDisplayMode: PageTabViewStyle.IndexDisplayMode {
   99|      0|        return (try? Inspector.attribute(label: "indexDisplayMode", value: self,
  100|      0|                                         type: PageTabViewStyle.IndexDisplayMode.self)
  101|      0|        ) ?? .automatic
  102|      0|    }
  103|       |    
  104|      0|    public static func == (lhs: PageTabViewStyle, rhs: PageTabViewStyle) -> Bool {
  105|      0|        return lhs.indexDisplayMode == rhs.indexDisplayMode
  106|      0|    }
  107|       |}
  108|       |
  109|       |@available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  110|       |@available(macOS, unavailable)
  111|       |extension PageTabViewStyle.IndexDisplayMode: Equatable {
  112|      0|    public static func == (lhs: PageTabViewStyle.IndexDisplayMode, rhs: PageTabViewStyle.IndexDisplayMode) -> Bool {
  113|      0|        let lhsBacking = try? Inspector.attribute(label: "backing", value: lhs)
  114|      0|        let rhsBacking = try? Inspector.attribute(label: "backing", value: rhs)
  115|      0|        return String(describing: lhsBacking) == String(describing: rhsBacking)
  116|      0|    }
  117|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Text.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension Locale {
    5|       |    /**
    6|       |     A global value used as a default parameter for `Text` string inspection
    7|       |     and `find` functions. You can set to other value before the tests run:
    8|       |     ````
    9|       |     override class func setUp() {
   10|       |        Locale.testsDefault = .current
   11|       |     }
   12|       |     ````
   13|       |     */
   14|       |    static var testsDefault: Locale = Locale(identifier: "en")
   15|       |}
   16|       |
   17|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   18|       |public extension ViewType {
   19|       |    
   20|       |    struct Text: KnownViewType {
   21|       |        public static let typePrefix: String = "Text"
   22|       |    }
   23|       |}
   24|       |
   25|       |// MARK: - Extraction from SingleViewContent parent
   26|       |
   27|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   28|       |public extension InspectableView where View: SingleViewContent {
   29|       |    
   30|      0|    func text() throws -> InspectableView<ViewType.Text> {
   31|      0|        return try .init(try child(), parent: self)
   32|      0|    }
   33|       |}
   34|       |
   35|       |// MARK: - Extraction from MultipleViewContent parent
   36|       |
   37|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   38|       |public extension InspectableView where View: MultipleViewContent {
   39|       |    
   40|      0|    func text(_ index: Int) throws -> InspectableView<ViewType.Text> {
   41|      0|        return try .init(try child(at: index), parent: self, index: index)
   42|      0|    }
   43|       |}
   44|       |
   45|       |// MARK: - Custom Attributes
   46|       |
   47|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   48|       |public extension InspectableView where View == ViewType.Text {
   49|       |    
   50|       |    /**
   51|       |     Extracts the formatted and localized string value from the Text view
   52|       |
   53|       |      - Parameter locale: Defaults to `Locale(identifier: "en")`,
   54|       |      which is a global default value in the tests scope.
   55|       |      You can change it by assigning a value to Locale.testsDefault
   56|       |    */
   57|     12|    func string(locale: Locale = .testsDefault) throws -> String {
   58|     12|        return try ViewType.Text.extractString(from: self, locale: locale)
   59|     12|    }
   60|       |    
   61|      5|    func attributes() throws -> ViewType.Text.Attributes {
   62|      5|        return try ViewType.Text.Attributes.extract(from: self)
   63|      5|    }
   64|       |    
   65|      0|    func images() throws -> [Image] {
   66|      0|        return try ViewType.Text.extractImages(from: self)
   67|      0|    }
   68|       |}
   69|       |
   70|       |// MARK: - String extraction
   71|       |
   72|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   73|       |private extension ViewType.Text {
   74|       |    
   75|       |    static func extractString(from view: InspectableView<ViewType.Text>,
   76|     12|                              locale: Locale) throws -> String {
   77|     12|        let storage = try Inspector.attribute(label: "storage", value: view.content.view)
   78|     12|        if let verbatim = try? Inspector
   79|      2|            .attribute(label: "verbatim", value: storage, type: String.self) {
   80|      2|            return verbatim
   81|     10|        }
   82|     10|        let textStorage = try Inspector.attribute(path: "anyTextStorage", value: storage)
   83|     10|        let storageType = Inspector.typeName(value: textStorage)
   84|     10|        switch storageType {
   85|      0|        case "ConcatenatedTextStorage":
   86|      0|            return try extractString(concatenatedTextStorage: textStorage, locale)
   87|     10|        case "LocalizedTextStorage":
   88|     10|            return try extractString(localizedTextStorage: textStorage, locale)
   89|      0|        case "AttachmentTextStorage":
   90|      0|            return try extractString(attachmentTextStorage: textStorage)
   91|      0|        case "DateTextStorage":
   92|      0|            return try extractString(dateTextStorage: textStorage)
   93|      0|        case "FormatterTextStorage":
   94|      0|            return try extractString(formatterTextStorage: textStorage)
   95|      0|        default:
   96|      0|            throw InspectionError.notSupported("Unknown text storage: \(storageType)")
   97|     10|        }
   98|     10|    }
   99|       |    
  100|       |    // MARK: - ConcatenatedTextStorage
  101|       |    
  102|      0|    private static func extractTexts(concatenatedTextStorage: Any) throws -> (Text, Text) {
  103|      0|        let firstText = try Inspector
  104|      0|            .attribute(label: "first", value: concatenatedTextStorage, type: Text.self)
  105|      0|        let secondText = try Inspector
  106|      0|            .attribute(label: "second", value: concatenatedTextStorage, type: Text.self)
  107|      0|        return (firstText, secondText)
  108|      0|    }
  109|       |    
  110|      0|    private static func extractString(concatenatedTextStorage: Any, _ locale: Locale) throws -> String {
  111|      0|        let (firstText, secondText) = try extractTexts(concatenatedTextStorage: concatenatedTextStorage)
  112|      0|        return (try firstText.inspect().text().string(locale: locale))
  113|      0|            + (try secondText.inspect().text().string(locale: locale))
  114|      0|    }
  115|       |    
  116|       |    // MARK: - FormatterTextStorage
  117|       |    
  118|      0|    private static func extractString(formatterTextStorage: Any) throws -> String {
  119|      0|        let formatter = try Inspector
  120|      0|            .attribute(label: "formatter", value: formatterTextStorage, type: Formatter.self)
  121|      0|        let object = try Inspector.attribute(label: "object", value: formatterTextStorage)
  122|      0|        return formatter.string(for: object) ?? ""
  123|      0|    }
  124|       |    
  125|       |    // MARK: - AttachmentTextStorage
  126|       |    
  127|      0|    private static func extractString(attachmentTextStorage: Any) throws -> String {
  128|      0|        let image = try extractImage(attachmentTextStorage: attachmentTextStorage)
  129|      0|        let description: String = {
  130|      0|            guard let name = try? image.inspect().image().actualImage().name()
  131|      0|            else { return "" }
  132|      0|            return "'\(name)'"
  133|      0|        }()
  134|      0|        return "Image(\(description))"
  135|      0|    }
  136|       |    
  137|       |    // MARK: - DateTextStorage
  138|       |    
  139|      0|    private static func extractString(dateTextStorage: Any) throws -> String {
  140|      0|        throw InspectionError.notSupported("Inspection of formatted Date is currently not supported")
  141|      0|    }
  142|       |    
  143|       |    // MARK: - LocalizedTextStorage
  144|       |    
  145|     10|    private static func extractString(localizedTextStorage: Any, _ locale: Locale) throws -> String {
  146|     10|        let stringContainer = try Inspector
  147|     10|            .attribute(label: "key", value: localizedTextStorage)
  148|     10|        let format = try Inspector
  149|     10|            .attribute(label: "key", value: stringContainer, type: String.self)
  150|     10|        let hasFormatting = try Inspector
  151|     10|            .attribute(label: "hasFormatting", value: stringContainer, type: Bool.self)
  152|     10|        let bundle = try? Inspector
  153|     10|            .attribute(label: "bundle", value: localizedTextStorage, type: Bundle.self)
  154|     10|        let table = try? Inspector
  155|     10|            .attribute(label: "table", value: localizedTextStorage, type: String?.self)
  156|     10|        let localized = (bundle ?? Bundle.main)?
  157|     10|            .path(forResource: locale.identifier
  158|     10|                    .replacingOccurrences(of: "_", with: "-"),
  159|     10|                  ofType: "lproj").flatMap({ Bundle(path: $0) })?
  160|      0|            .localizedString(forKey: format, value: format, table: table) ?? format
  161|     10|        guard hasFormatting else { return localized }
  162|      0|        let arguments = try formattingArguments(stringContainer, locale: locale)
  163|      0|        return String(format: localized, arguments: arguments)
  164|     10|    }
  165|       |    
  166|      0|    private static func formattingArguments(_ container: Any, locale: Locale) throws -> [CVarArg] {
  167|      0|        return try Inspector
  168|      0|            .attribute(label: "arguments", value: container, type: [Any].self)
  169|      0|            .map { try formattingArgument($0, locale) }
  170|      0|    }
  171|       |    
  172|      0|    private static func formattingArgument(_ container: Any, _ locale: Locale) throws -> CVarArg {
  173|      0|        if let text = try? Inspector.attribute(path: "storage|text|.0", value: container, type: Text.self) {
  174|      0|            return try text.inspect().text().string(locale: locale)
  175|      0|        }
  176|      0|        let valuePath: String
  177|      0|        let formatterPath: String
  178|      0|        if #available(iOS 14, macOS 10.16, tvOS 14, *) {
  179|      0|            valuePath = "storage|value|.0"
  180|      0|            formatterPath = "storage|value|.1"
  181|      0|        } else {
  182|      0|            valuePath = "value"
  183|      0|            formatterPath = "formatter"
  184|      0|        }
  185|      0|        let value = try Inspector.attribute(path: valuePath, value: container, type: CVarArg.self)
  186|      0|        let formatter = try Inspector.attribute(path: formatterPath, value: container, type: Formatter?.self)
  187|      0|        return formatter.flatMap({ $0.string(for: value) }) ?? value
  188|      0|    }
  189|       |}
  190|       |
  191|       |// MARK: - Image extraction
  192|       |
  193|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  194|       |private extension ViewType.Text {
  195|       |    
  196|      0|    static func extractImages(from view: InspectableView<ViewType.Text>) throws -> [Image] {
  197|      0|        let storage = try Inspector.attribute(label: "storage", value: view.content.view)
  198|      0|        let textStorage = try Inspector.attribute(path: "anyTextStorage", value: storage)
  199|      0|        let storageType = Inspector.typeName(value: textStorage)
  200|      0|        switch storageType {
  201|      0|        case "ConcatenatedTextStorage":
  202|      0|            return try extractImages(concatenatedTextStorage: textStorage)
  203|      0|        case "AttachmentTextStorage":
  204|      0|            return [try extractImage(attachmentTextStorage: textStorage)]
  205|      0|        case "LocalizedTextStorage":
  206|      0|            return try extractImages(localizedTextStorage: textStorage)
  207|      0|        default:
  208|      0|            return []
  209|      0|        }
  210|      0|    }
  211|       |    
  212|       |    // MARK: - ConcatenatedTextStorage
  213|       |    
  214|      0|    private static func extractImages(concatenatedTextStorage: Any) throws -> [Image] {
  215|      0|        let (firstText, secondText) = try extractTexts(concatenatedTextStorage: concatenatedTextStorage)
  216|      0|        return try firstText.inspect().text().images() + secondText.inspect().text().images()
  217|      0|    }
  218|       |    
  219|       |    // MARK: - AttachmentTextStorage
  220|       |    
  221|      0|    private static func extractImage(attachmentTextStorage: Any) throws -> Image {
  222|      0|        return try Inspector
  223|      0|            .attribute(label: "image", value: attachmentTextStorage, type: Image.self)
  224|      0|    }
  225|       |    
  226|       |    // MARK: - LocalizedTextStorage
  227|       |    
  228|      0|    private static func extractImages(localizedTextStorage: Any) throws -> [Image] {
  229|      0|        let stringContainer = try Inspector
  230|      0|            .attribute(label: "key", value: localizedTextStorage)
  231|      0|        let hasFormatting = try Inspector
  232|      0|            .attribute(label: "hasFormatting", value: stringContainer, type: Bool.self)
  233|      0|        guard hasFormatting else { return [] }
  234|      0|        return try extractImageArguments(stringContainer)
  235|      0|    }
  236|       |    
  237|      0|    private static func extractImageArguments(_ container: Any) throws -> [Image] {
  238|      0|        return try Inspector
  239|      0|            .attribute(label: "arguments", value: container, type: [Any].self)
  240|      0|            .map { try imageArguments($0) }
  241|      0|            .flatMap { $0 }
  242|      0|    }
  243|       |    
  244|      0|    private static func imageArguments(_ container: Any) throws -> [Image] {
  245|      0|        if let text = try? Inspector.attribute(path: "storage|text|.0", value: container, type: Text.self) {
  246|      0|            return try text.inspect().text().images()
  247|      0|        }
  248|      0|        return []
  249|      0|    }
  250|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/TextAttributes.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType.Text.Attributes {
    5|       |    
    6|      5|    static func extract(from view: InspectableView<ViewType.Text>) throws -> ViewType.Text.Attributes {
    7|      5|        if let first = try? Inspector
    8|      5|            .attribute(path: "storage|anyTextStorage|first", value: view.content.view, type: Text.self),
    9|      5|            let second = try? Inspector
   10|      0|                .attribute(path: "storage|anyTextStorage|second", value: view.content.view, type: Text.self) {
   11|      0|            let firstAttr = try first.inspect().text().attributes()
   12|      0|            let secondAttr = try second.inspect().text().attributes()
   13|      0|            return firstAttr + secondAttr
   14|      5|        }
   15|      5|        let string = try view.string()
   16|      5|        let modifiers = try Inspector.attribute(label: "modifiers", value: view.content.view, type: [Any].self)
   17|      5|        let environment = Environment(
   18|      5|            font: try? view.font(checkIfText: false),
   19|      5|            foregroundColor: try? view.foregroundColor(checkIfText: false))
   20|      5|        return .init(string: string, modifiers: modifiers, environment: environment)
   21|      5|    }
   22|       |}
   23|       |
   24|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   25|       |public extension ViewType.Text.Attributes {
   26|       |    
   27|      0|    subscript<Range>(_ range: Range) -> Self where Range: RangeExpression, Range.Bound == Int {
   28|      0|        let relativeRange = range.relative(to: 0..<string.count)
   29|      0|        let chunksInRange = zip(chunkRanges, chunks)
   30|      0|            .filter { relativeRange.overlaps($0.0) }
   31|      0|            .map { $0.1 }
   32|      0|        return .init(chunks: chunksInRange, environment: environment)
   33|      0|    }
   34|       |
   35|      0|    subscript<Range>(_ range: Range) -> Self where Range: RangeExpression, Range.Bound == String.Index {
   36|      0|        let relativeRange = range.relative(to: string)
   37|      0|        let chunksInRange = zip(chunkStringRanges, chunks)
   38|      0|            .filter { relativeRange.overlaps($0.0) }
   39|      0|            .map { $0.1 }
   40|      0|        return .init(chunks: chunksInRange, environment: environment)
   41|      0|    }
   42|       |    
   43|      0|    func isItalic() throws -> Bool {
   44|      0|        return try commonTrait(name: "italic") { modifier in
   45|      0|            String(describing: modifier) == "italic" ? true : nil
   46|      0|        } == true
   47|      0|    }
   48|       |    
   49|      0|    func isBold() throws -> Bool {
   50|      0|        do {
   51|      0|            return try fontWeight(attributeName: "bold") == .bold
   52|      0|        } catch {
   53|      0|            if case .textAttribute = error as? InspectionError {
   54|      0|                throw error
   55|      0|            }
   56|      0|        }
   57|      0|        return try commonTrait(name: "bold") { modifier in
   58|      0|            guard let child = try? Inspector.attribute(label: "anyTextModifier", value: modifier)
   59|      0|                else { return nil }
   60|      0|            return Inspector.typeName(value: child) == "BoldTextModifier" ? true : nil
   61|      0|        } == true
   62|      0|    }
   63|       |    
   64|      0|    func fontWeight() throws -> Font.Weight {
   65|      0|        return try fontWeight(attributeName: "fontWeight")
   66|      0|    }
   67|       |    
   68|      0|    private func fontWeight(attributeName: String) throws -> Font.Weight {
   69|      0|        return try commonTrait(name: attributeName) { modifier -> Font.Weight? in
   70|      0|            guard let fontWeight = try? Inspector
   71|      0|                .attribute(path: "weight|some", value: modifier, type: Font.Weight.self)
   72|      0|                else { return nil }
   73|      0|            return fontWeight
   74|      0|        }
   75|      0|    }
   76|       |    
   77|      0|    func font() throws -> Font {
   78|      0|        do {
   79|      0|            return try commonTrait(name: "font") { modifier -> Font? in
   80|      0|                return try? Inspector.attribute(path: "font|some", value: modifier, type: Font.self)
   81|      0|            }
   82|      0|        } catch {
   83|      0|            if let err = error as? InspectionError, case .modifierNotFound = err,
   84|      0|               let font = environment.font {
   85|      0|                return font
   86|      0|            }
   87|      0|            throw error
   88|      0|        }
   89|      0|    }
   90|       |    
   91|      0|    func foregroundColor() throws -> Color {
   92|      0|        do {
   93|      0|            return try commonTrait(name: "foregroundColor") { modifier -> Color? in
   94|      0|                guard let color = try? Inspector
   95|      0|                    .attribute(path: "color|some", value: modifier, type: Color.self)
   96|      0|                    else { return nil }
   97|      0|                return color
   98|      0|            }
   99|      0|        } catch {
  100|      0|            if let err = error as? InspectionError, case .modifierNotFound = err,
  101|      0|               let font = environment.foregroundColor {
  102|      0|                return font
  103|      0|            }
  104|      0|            throw error
  105|      0|        }
  106|      0|    }
  107|       |    
  108|      0|    func isStrikethrough() throws -> Bool {
  109|      0|        return try commonTrait(name: "strikethrough") { modifier -> Bool? in
  110|      0|            guard let child = try? Inspector.attribute(label: "anyTextModifier", value: modifier),
  111|      0|                Inspector.typeName(value: child) == "StrikethroughTextModifier",
  112|      0|                let active = try? Inspector
  113|      0|                    .attribute(path: "lineStyle|some|active", value: child, type: Bool.self)
  114|      0|                else { return nil }
  115|      0|            return active
  116|      0|        }
  117|      0|    }
  118|       |    
  119|      0|    func strikethroughColor() throws -> Color? {
  120|      0|        return try commonTrait(name: "strikethrough") { modifier -> Color? in
  121|      0|            guard let child = try? Inspector.attribute(label: "anyTextModifier", value: modifier),
  122|      0|                Inspector.typeName(value: child) == "StrikethroughTextModifier",
  123|      0|                let color = try? Inspector
  124|      0|                    .attribute(path: "lineStyle|some|color", value: child, type: Color?.self)
  125|      0|                else { return nil }
  126|      0|            return color
  127|      0|        }
  128|      0|    }
  129|       |    
  130|      0|    func isUnderline() throws -> Bool {
  131|      0|        return try commonTrait(name: "underline") { modifier -> Bool? in
  132|      0|            guard let child = try? Inspector.attribute(label: "anyTextModifier", value: modifier),
  133|      0|                Inspector.typeName(value: child) == "UnderlineTextModifier",
  134|      0|                let active = try? Inspector
  135|      0|                    .attribute(path: "lineStyle|some|active", value: child, type: Bool.self)
  136|      0|                else { return nil }
  137|      0|            return active
  138|      0|        }
  139|      0|    }
  140|       |    
  141|      0|    func underlineColor() throws -> Color? {
  142|      0|        return try commonTrait(name: "underline") { modifier -> Color? in
  143|      0|            guard let child = try? Inspector.attribute(label: "anyTextModifier", value: modifier),
  144|      0|                Inspector.typeName(value: child) == "UnderlineTextModifier",
  145|      0|                let color = try? Inspector
  146|      0|                    .attribute(path: "lineStyle|some|color", value: child, type: Color?.self)
  147|      0|                else { return nil }
  148|      0|            return color
  149|      0|        }
  150|      0|    }
  151|       |    
  152|      0|    func kerning() throws -> CGFloat {
  153|      0|        return try commonTrait(name: "kerning") { modifier -> CGFloat? in
  154|      0|            guard let kerning = try? Inspector
  155|      0|                .attribute(label: "kerning", value: modifier, type: CGFloat.self)
  156|      0|                else { return nil }
  157|      0|            return kerning
  158|      0|        }
  159|      0|    }
  160|       |    
  161|      0|    func tracking() throws -> CGFloat {
  162|      0|        return try commonTrait(name: "tracking") { modifier -> CGFloat? in
  163|      0|            guard let kerning = try? Inspector
  164|      0|                .attribute(label: "tracking", value: modifier, type: CGFloat.self)
  165|      0|                else { return nil }
  166|      0|            return kerning
  167|      0|        }
  168|      0|    }
  169|       |    
  170|      0|    func baselineOffset() throws -> CGFloat {
  171|      0|        return try commonTrait(name: "baselineOffset") { modifier -> CGFloat? in
  172|      0|            guard let kerning = try? Inspector
  173|      0|                .attribute(label: "baseline", value: modifier, type: CGFloat.self)
  174|      0|                else { return nil }
  175|      0|            return kerning
  176|      0|        }
  177|      0|    }
  178|       |}
  179|       |
  180|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  181|       |public extension ViewType.Text {
  182|       |    struct Attributes {
  183|       |        fileprivate struct Environment {
  184|       |            let font: Font?
  185|       |            let foregroundColor: Color?
  186|       |        }
  187|       |        private struct Chunk {
  188|       |            let string: String
  189|       |            let modifiers: [Any]
  190|       |
  191|      0|            var length: Int {
  192|      0|                string.count
  193|      0|            }
  194|       |        }
  195|       |        private let chunks: [Chunk]
  196|       |        private let environment: Environment
  197|       |        
  198|      5|        private init(chunks: [Chunk], environment: Environment) {
  199|      5|            self.chunks = chunks
  200|      5|            self.environment = environment
  201|      5|        }
  202|       |        
  203|      5|        fileprivate init(string: String, modifiers: [Any], environment: Environment) {
  204|      5|            self.init(chunks: [Chunk(string: string, modifiers: modifiers)], environment: environment)
  205|      5|        }
  206|       |        
  207|      0|        fileprivate static func + (lhs: Attributes, rhs: Attributes) -> Attributes {
  208|      0|            return Attributes(chunks: lhs.chunks + rhs.chunks, environment: lhs.environment)
  209|      0|        }
  210|       |        
  211|      0|        private var chunkRanges: [Range<Int>] {
  212|      0|            return chunks.reduce([]) { (array, chunk) in
  213|      0|                let start = array.last?.upperBound ?? 0
  214|      0|                return array + [start ..< start + chunk.length]
  215|      0|            }
  216|      0|        }
  217|       |
  218|      0|        private var chunkStringRanges: [Range<String.Index>] {
  219|      0|            var totalString = ""
  220|      0|            return chunks.reduce([]) { (array, chunk) in
  221|      0|                let start = totalString.endIndex
  222|      0|                totalString += chunk.string
  223|      0|                let end = totalString.endIndex
  224|      0|                return array + [start ..< end]
  225|      0|            }
  226|      0|        }
  227|       |
  228|      0|        private var string: String {
  229|      0|            chunks.map { $0.string }.joined()
  230|      0|        }
  231|       |        
  232|      0|        private func commonTrait<V>(name: String, _ trait: (Any) throws -> V?) throws -> V where V: Equatable {
  233|      0|            guard chunks.count > 0 else {
  234|      0|                throw InspectionError.textAttribute("Invalid text range")
  235|      0|            }
  236|      0|            let traits = try chunks.compactMap { chunk -> V? in
  237|      0|                for modifier in chunk.modifiers {
  238|      0|                    if let value = try trait(modifier) {
  239|      0|                        return value
  240|      0|                    }
  241|      0|                }
  242|      0|                return nil
  243|      0|            }
  244|      0|            guard let trait = traits.first else {
  245|      0|                throw InspectionError.modifierNotFound(parent: "Text", modifier: name, index: 0)
  246|      0|            }
  247|      0|            guard traits.count == chunks.count else {
  248|      0|                throw InspectionError.textAttribute("Modifier '\(name)' is applied only to a subrange")
  249|      0|            }
  250|      0|            guard traits.allSatisfy({ $0 == trait }) else {
  251|      0|                throw InspectionError.textAttribute("Modifier '\(name)' has different values in subranges")
  252|      0|            }
  253|      0|            return trait
  254|      0|        }
  255|       |    }
  256|       |}
  257|       |
  258|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  259|       |public extension Font {
  260|       |    
  261|      0|    func size() throws -> CGFloat {
  262|      0|        do {
  263|      0|            return try Inspector
  264|      0|                .attribute(path: "provider|base|size", value: self, type: CGFloat.self)
  265|      0|        } catch {
  266|      0|            throw InspectionError.attributeNotFound(label: "size", type: "Font")
  267|      0|        }
  268|      0|    }
  269|       |    
  270|      0|    func isFixedSize() -> Bool {
  271|      0|        guard #available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
  272|      0|        else { return false }
  273|      0|        guard let provider = try? Inspector.attribute(path: "provider|base", value: self),
  274|      0|              Inspector.typeName(value: provider) == "NamedProvider"
  275|      0|        else { return false }
  276|      0|        return (try? style()) == nil
  277|      0|    }
  278|       |    
  279|      0|    func name() throws -> String {
  280|      0|        do {
  281|      0|            return try Inspector
  282|      0|                .attribute(path: "provider|base|name", value: self, type: String.self)
  283|      0|        } catch {
  284|      0|            throw InspectionError.attributeNotFound(label: "name", type: "Font")
  285|      0|        }
  286|      0|    }
  287|       |    
  288|      0|    func weight() throws -> Font.Weight {
  289|      0|        do {
  290|      0|            return try Inspector
  291|      0|                .attribute(path: "provider|base|weight", value: self, type: Font.Weight.self)
  292|      0|        } catch {
  293|      0|            throw InspectionError.attributeNotFound(label: "weight", type: "Font")
  294|      0|        }
  295|      0|    }
  296|       |    
  297|      0|    func design() throws -> Font.Design {
  298|      0|        do {
  299|      0|            return try Inspector
  300|      0|                .attribute(path: "provider|base|design", value: self, type: Font.Design.self)
  301|      0|        } catch {
  302|      0|            throw InspectionError.attributeNotFound(label: "design", type: "Font")
  303|      0|        }
  304|      0|    }
  305|       |    
  306|      0|    func style() throws -> Font.TextStyle {
  307|      0|        do {
  308|      0|            return try (try? Inspector
  309|      0|                .attribute(path: "provider|base|style", value: self, type: Font.TextStyle.self))
  310|      0|                ?? (try Inspector
  311|      0|                .attribute(path: "provider|base|textStyle", value: self, type: Font.TextStyle.self))
  312|      0|        } catch {
  313|      0|            throw InspectionError.attributeNotFound(label: "style", type: "Font")
  314|      0|        }
  315|      0|    }
  316|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/TextEditor.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct TextEditor: KnownViewType {
    7|       |        public static var typePrefix: String = "TextEditor"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 14.0, macOS 11.0, *)
   14|       |@available(tvOS, unavailable)
   15|       |public extension InspectableView where View: SingleViewContent {
   16|       |    
   17|      0|    func textEditor() throws -> InspectableView<ViewType.TextEditor> {
   18|      0|        return try .init(try child(), parent: self)
   19|      0|    }
   20|       |}
   21|       |
   22|       |// MARK: - Extraction from MultipleViewContent parent
   23|       |
   24|       |@available(iOS 14.0, macOS 11.0, *)
   25|       |@available(tvOS, unavailable)
   26|       |public extension InspectableView where View: MultipleViewContent {
   27|       |    
   28|      0|    func textEditor(_ index: Int) throws -> InspectableView<ViewType.TextEditor> {
   29|      0|        return try .init(try child(at: index), parent: self, index: index)
   30|      0|    }
   31|       |}
   32|       |
   33|       |// MARK: - Custom Attributes
   34|       |
   35|       |@available(iOS 14.0, macOS 11.0, *)
   36|       |@available(tvOS, unavailable)
   37|       |public extension InspectableView where View == ViewType.TextEditor {
   38|       |    
   39|      0|    func input() throws -> String {
   40|      0|        return try inputBinding().wrappedValue
   41|      0|    }
   42|       |    
   43|      0|    func setInput(_ value: String) throws {
   44|      0|        try guardIsResponsive()
   45|      0|        try inputBinding().wrappedValue = value
   46|      0|    }
   47|       |    
   48|      0|    private func inputBinding() throws -> Binding<String> {
   49|      0|        return try Inspector.attribute(
   50|      0|            label: "_text", value: content.view, type: Binding<String>.self)
   51|      0|    }
   52|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/TextField.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct TextField: KnownViewType {
    7|       |        public static var typePrefix: String = "TextField"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func textField() throws -> InspectableView<ViewType.TextField> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func textField(_ index: Int) throws -> InspectableView<ViewType.TextField> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Non Standard Children
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.TextField: SupplementaryChildrenLabelView { }
   35|       |
   36|       |// MARK: - Custom Attributes
   37|       |
   38|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   39|       |public extension InspectableView where View == ViewType.TextField {
   40|       |    
   41|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   42|      0|        return try View.supplementaryChildren(self).element(at: 0)
   43|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   44|      0|    }
   45|       |    
   46|      0|    func callOnEditingChanged() throws {
   47|      0|        try guardIsResponsive()
   48|      0|        typealias Callback = (Bool) -> Void
   49|      0|        let callback = try Inspector
   50|      0|            .attribute(label: "onEditingChanged", value: content.view, type: Callback.self)
   51|      0|        callback(false)
   52|      0|    }
   53|       |    
   54|      0|    func callOnCommit() throws {
   55|      0|        try guardIsResponsive()
   56|      0|        typealias Callback = () -> Void
   57|      0|        let callback = try Inspector
   58|      0|            .attribute(label: "onCommit", value: content.view, type: Callback.self)
   59|      0|        callback()
   60|      0|    }
   61|       |    
   62|      0|    func input() throws -> String {
   63|      0|        return try inputBinding().wrappedValue
   64|      0|    }
   65|       |    
   66|      0|    func setInput(_ value: String) throws {
   67|      0|        try guardIsResponsive()
   68|      0|        try inputBinding().wrappedValue = value
   69|      0|    }
   70|       |    
   71|      0|    private func inputBinding() throws -> Binding<String> {
   72|      0|        let label: String
   73|      0|        if #available(iOS 13.2, macOS 10.17, tvOS 13.2, *) {
   74|      0|            label = "_text"
   75|      0|        } else {
   76|      0|            label = "text"
   77|      0|        }
   78|      0|        return try Inspector.attribute(label: label, value: content.view, type: Binding<String>.self)
   79|      0|    }
   80|       |}
   81|       |
   82|       |// MARK: - Global View Modifiers
   83|       |
   84|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   85|       |public extension InspectableView {
   86|       |
   87|      0|    func textFieldStyle() throws -> Any {
   88|      0|        let modifier = try self.modifier({ modifier -> Bool in
   89|      0|            return modifier.modifierType.hasPrefix("TextFieldStyleModifier")
   90|      0|        }, call: "textFieldStyle")
   91|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   92|      0|    }
   93|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/Toggle.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct Toggle: KnownViewType {
    7|       |        public static var typePrefix: String = "Toggle"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Extraction from SingleViewContent parent
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |public extension InspectableView where View: SingleViewContent {
   15|       |    
   16|      0|    func toggle() throws -> InspectableView<ViewType.Toggle> {
   17|      0|        return try .init(try child(), parent: self)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from MultipleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: MultipleViewContent {
   25|       |    
   26|      0|    func toggle(_ index: Int) throws -> InspectableView<ViewType.Toggle> {
   27|      0|        return try .init(try child(at: index), parent: self, index: index)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Non Standard Children
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |extension ViewType.Toggle: SupplementaryChildrenLabelView {
   35|      0|    static var labelViewPath: String { "_label" }
   36|       |}
   37|       |
   38|       |// MARK: - Custom Attributes
   39|       |
   40|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   41|       |public extension InspectableView where View == ViewType.Toggle {
   42|       |    
   43|      0|    func labelView() throws -> InspectableView<ViewType.ClassifiedView> {
   44|      0|        return try View.supplementaryChildren(self).element(at: 0)
   45|      0|            .asInspectableView(ofType: ViewType.ClassifiedView.self)
   46|      0|    }
   47|       |    
   48|      0|    func tap() throws {
   49|      0|        try guardIsResponsive()
   50|      0|        try isOnBinding().wrappedValue.toggle()
   51|      0|    }
   52|       |    
   53|      0|    func isOn() throws -> Bool {
   54|      0|        return try isOnBinding().wrappedValue
   55|      0|    }
   56|       |    
   57|      0|    private func isOnBinding() throws -> Binding<Bool> {
   58|      0|        return try Inspector
   59|      0|            .attribute(label: "__isOn", value: content.view, type: Binding<Bool>.self)
   60|      0|    }
   61|       |}
   62|       |
   63|       |// MARK: - Global View Modifiers
   64|       |
   65|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   66|       |public extension InspectableView {
   67|       |
   68|      0|    func toggleStyle() throws -> Any {
   69|      0|        let modifier = try self.modifier({ modifier -> Bool in
   70|      0|            return modifier.modifierType.hasPrefix("ToggleStyleModifier")
   71|      0|        }, call: "toggleStyle")
   72|      0|        return try Inspector.attribute(path: "modifier|style", value: modifier)
   73|      0|    }
   74|       |}
   75|       |
   76|       |// MARK: - ToggleStyle inspection
   77|       |
   78|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   79|       |public extension ToggleStyle {
   80|      0|    func inspect(isOn: Bool) throws -> InspectableView<ViewType.ClassifiedView> {
   81|      0|        let config = ToggleStyleConfiguration(isOn: isOn)
   82|      0|        let view = try makeBody(configuration: config).inspect()
   83|      0|        return try .init(view.content, parent: nil, index: nil)
   84|      0|    }
   85|       |}
   86|       |
   87|       |// MARK: - Style Configuration initializer
   88|       |
   89|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   90|       |internal extension ToggleStyleConfiguration {
   91|       |    private struct Allocator {
   92|       |        let binding: Binding<Bool>
   93|      0|        init(isOn: Bool) {
   94|      0|            self.binding = .init(wrappedValue: isOn)
   95|      0|        }
   96|       |    }
   97|      0|    init(isOn: Bool) {
   98|      0|        self = unsafeBitCast(Allocator(isOn: isOn), to: Self.self)
   99|      0|    }
  100|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/TouchBar.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct TouchBar: KnownViewType {
    7|       |        public static var typePrefix: String = "TouchBar"
    8|       |    }
    9|       |}
   10|       |
   11|       |#if os(macOS)
   12|       |
   13|       |// MARK: - Content Extraction
   14|       |
   15|       |@available(macOS 10.15, *)
   16|       |@available(iOS, unavailable)
   17|       |@available(tvOS, unavailable)
   18|       |extension ViewType.TouchBar: SingleViewContent {
   19|       |    
   20|       |    public static func child(_ content: Content) throws -> Content {
   21|       |        let view = try Inspector.attribute(label: "content", value: content.view)
   22|       |        let medium = content.medium.resettingViewModifiers()
   23|       |        return try Inspector.unwrap(view: view, medium: medium)
   24|       |    }
   25|       |}
   26|       |
   27|       |// MARK: - Custom Attributes
   28|       |
   29|       |@available(macOS 10.15, *)
   30|       |@available(iOS, unavailable)
   31|       |@available(tvOS, unavailable)
   32|       |public extension InspectableView where View == ViewType.TouchBar {
   33|       |    
   34|       |    func touchBarID() throws -> String {
   35|       |        return try Inspector
   36|       |            .attribute(path: "container|id", value: content.view, type: String.self)
   37|       |    }
   38|       |}
   39|       |
   40|       |// MARK: - Global View Modifiers
   41|       |
   42|       |@available(macOS 10.15, *)
   43|       |@available(iOS, unavailable)
   44|       |@available(tvOS, unavailable)
   45|       |public extension InspectableView {
   46|       |    
   47|       |    func touchBar() throws -> InspectableView<ViewType.TouchBar> {
   48|       |        return try contentForModifierLookup.touchBar(parent: self)
   49|       |    }
   50|       |    
   51|       |    func touchBarItemPrincipal() throws -> Bool {
   52|       |        return try modifierAttribute(
   53|       |            modifierName: "TouchBarItemPrincipalTraitKey", path: "modifier|value",
   54|       |            type: Bool.self, call: "touchBarItemPrincipal")
   55|       |    }
   56|       |    
   57|       |    func touchBarCustomizationLabel() throws -> InspectableView<ViewType.Text> {
   58|       |        let view = try modifierAttribute(
   59|       |            modifierName: "TouchBarCustomizationLabelTraitKey", path: "modifier|value",
   60|       |            type: Any.self, call: "touchBarCustomizationLabel")
   61|       |        return try .init(try Inspector.unwrap(content: Content(view)), parent: self)
   62|       |    }
   63|       |    
   64|       |    func touchBarItemPresence() throws -> TouchBarItemPresence {
   65|       |        return try modifierAttribute(
   66|       |            modifierName: "TouchBarItemPresenceTraitKey", path: "modifier|value|some",
   67|       |            type: TouchBarItemPresence.self, call: "touchBarItemPresence")
   68|       |    }
   69|       |}
   70|       |
   71|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   72|       |internal extension Content {
   73|       |    func touchBar(parent: UnwrappedView) throws -> InspectableView<ViewType.TouchBar> {
   74|       |        let rootView = try modifierAttribute(
   75|       |            modifierName: "_TouchBarModifier", path: "modifier|touchBar",
   76|       |            type: Any.self, call: "touchBar")
   77|       |        let content = try Inspector.unwrap(content: Content(rootView))
   78|       |        return try .init(content, parent: parent, call: "touchBar()")
   79|       |    }
   80|       |}
   81|       |#else
   82|       |
   83|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   84|       |internal extension Content {
   85|      0|    func touchBar(parent: UnwrappedView) throws -> InspectableView<ViewType.TouchBar> {
   86|      0|        throw InspectionError.notSupported("Not supported on this platform")
   87|      0|    }
   88|       |}
   89|       |#endif

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/TreeView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |internal extension ViewType {
    5|       |    struct TreeView {}
    6|       |}
    7|       |
    8|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    9|       |extension ViewType.TreeView: SingleViewContent {
   10|       |
   11|      0|    static func child(_ content: Content) throws -> Content {
   12|      0|        let view = try Inspector.attribute(path: "root|content", value: content.view)
   13|      0|        return try Inspector.unwrap(view: view, medium: content.medium)
   14|      0|    }
   15|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/TupleView.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct TupleView: KnownViewType {
    7|       |        public static let typePrefix: String = "TupleView"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.TupleView: MultipleViewContent {
   15|       |    
   16|     23|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|     23|        let tupleViews = try Inspector.attribute(label: "value", value: content.view)
   18|     23|        let childrenCount = Mirror(reflecting: tupleViews).children.count
   19|     46|        return LazyGroup(count: childrenCount) { index in
   20|     46|            let child = try Inspector.attribute(label: ".\(index)", value: tupleViews)
   21|     46|            let medium = content.medium.resettingViewModifiers()
   22|     46|            return try Inspector.unwrap(content: Content(child, medium: medium))
   23|     46|        }
   24|     23|    }
   25|       |}
   26|       |
   27|       |// MARK: - Extraction from MultipleViewContent parent
   28|       |
   29|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   30|       |public extension InspectableView where View: MultipleViewContent {
   31|       |    
   32|      0|    func tupleView(_ index: Int) throws -> InspectableView<ViewType.TupleView> {
   33|      0|        return try .init(try child(at: index, isTupleExtraction: true), parent: self, index: index)
   34|      0|    }
   35|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/VStack.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |
    6|       |    struct VStack: KnownViewType {
    7|       |        public static let typePrefix: String = "VStack"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.VStack: MultipleViewContent {
   15|       |
   16|      9|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      9|        return try ViewType.HStack.children(content)
   18|      9|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from SingleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: SingleViewContent {
   25|       |
   26|      1|    func vStack() throws -> InspectableView<ViewType.VStack> {
   27|      1|        return try .init(try child(), parent: self)
   28|      1|    }
   29|       |}
   30|       |
   31|       |// MARK: - Extraction from MultipleViewContent parent
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |public extension InspectableView where View: MultipleViewContent {
   35|       |
   36|      0|    func vStack(_ index: Int) throws -> InspectableView<ViewType.VStack> {
   37|      0|        return try .init(try child(at: index), parent: self, index: index)
   38|      0|    }
   39|       |}
   40|       |
   41|       |// MARK: - Custom Attributes
   42|       |
   43|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   44|       |public extension InspectableView where View == ViewType.VStack {
   45|       |
   46|      0|    func spacing() throws -> CGFloat? {
   47|      0|        return try Inspector.attribute(
   48|      0|            path: "spacing", value: vStackLayout(), type: CGFloat?.self)
   49|      0|    }
   50|       |
   51|      0|    func alignment() throws -> HorizontalAlignment? {
   52|      0|        return try Inspector.attribute(
   53|      0|            path: "alignment", value: vStackLayout(), type: HorizontalAlignment?.self)
   54|      0|    }
   55|       |
   56|      0|    private func vStackLayout() throws -> Any {
   57|      0|        return try Inspector.attribute(path: "_tree|root", value: content.view)
   58|      0|    }
   59|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/SwiftUI/ZStack.swift:
    1|       |import SwiftUI
    2|       |
    3|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    4|       |public extension ViewType {
    5|       |    
    6|       |    struct ZStack: KnownViewType {
    7|       |        public static let typePrefix: String = "ZStack"
    8|       |    }
    9|       |}
   10|       |
   11|       |// MARK: - Content Extraction
   12|       |
   13|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   14|       |extension ViewType.ZStack: MultipleViewContent {
   15|       |    
   16|      0|    public static func children(_ content: Content) throws -> LazyGroup<Content> {
   17|      0|        return try ViewType.HStack.children(content)
   18|      0|    }
   19|       |}
   20|       |
   21|       |// MARK: - Extraction from SingleViewContent parent
   22|       |
   23|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   24|       |public extension InspectableView where View: SingleViewContent {
   25|       |    
   26|      0|    func zStack() throws -> InspectableView<ViewType.ZStack> {
   27|      0|        return try .init(try child(), parent: self)
   28|      0|    }
   29|       |}
   30|       |
   31|       |// MARK: - Extraction from MultipleViewContent parent
   32|       |
   33|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   34|       |public extension InspectableView where View: MultipleViewContent {
   35|       |    
   36|      0|    func zStack(_ index: Int) throws -> InspectableView<ViewType.ZStack> {
   37|      0|        return try .init(try child(at: index), parent: self, index: index)
   38|      0|    }
   39|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/ViewHosting.swift:
    1|       |import SwiftUI
    2|       |#if canImport(UIKit)
    3|       |import UIKit
    4|       |#endif
    5|       |
    6|       |public struct ViewHosting { }
    7|       |
    8|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    9|       |public extension ViewHosting {
   10|       |    
   11|       |    struct ViewId: Hashable {
   12|       |        let function: String
   13|       |    }
   14|       |    
   15|     26|    static func host<V>(view: V, size: CGSize? = nil, function: String = #function) where V: View {
   16|     26|        let viewId = ViewId(function: function)
   17|     26|        let medium = { () -> Content.Medium in
   18|     26|            guard let unwrapped = try? Inspector.unwrap(view: view, medium: .empty)
   19|     26|            else { return .empty }
   20|     26|            if !unwrapped.isCustomView {
   21|      2|                return unwrapped.medium.removingCustomViewModifiers()
   22|     24|            }
   23|     24|            return unwrapped.medium
   24|     26|        }()
   25|     26|        let parentVC = rootViewController
   26|     26|        let childVC = hostVC(view)
   27|     26|        let size = size ?? parentVC.view.bounds.size
   28|     26|        store(Hosted(viewController: childVC, medium: medium), viewId: viewId)
   29|     26|        childVC.view.translatesAutoresizingMaskIntoConstraints = false
   30|     26|        childVC.view.frame = parentVC.view.frame
   31|     26|        willMove(childVC, to: parentVC)
   32|     26|        parentVC.addChild(childVC)
   33|     26|        parentVC.view.addSubview(childVC.view)
   34|     26|        NSLayoutConstraint.activate([
   35|     26|            childVC.view.leadingAnchor.constraint(equalTo: parentVC.view.leadingAnchor),
   36|     26|            childVC.view.topAnchor.constraint(equalTo: parentVC.view.topAnchor),
   37|     26|            childVC.view.widthAnchor.constraint(equalToConstant: size.width).priority(.defaultHigh),
   38|     26|            childVC.view.heightAnchor.constraint(equalToConstant: size.height).priority(.defaultHigh)
   39|     26|        ])
   40|     26|        didMove(childVC, to: parentVC)
   41|     26|        window.layoutIfNeeded()
   42|     26|    }
   43|       |    
   44|     26|    static func expel(function: String = #function) {
   45|     26|        let viewId = ViewId(function: function)
   46|     26|        guard let hosted = expel(viewId: viewId) else { return }
   47|     26|        let childVC = hosted.viewController
   48|     26|        willMove(childVC, to: nil)
   49|     26|        childVC.view.removeFromSuperview()
   50|     26|        childVC.removeFromParent()
   51|     26|        didMove(childVC, to: nil)
   52|     26|    }
   53|       |    
   54|     31|    internal static func medium(function: String = #function) -> Content.Medium {
   55|     31|        let viewId = ViewHosting.ViewId(function: function)
   56|      4|        return hosted[viewId]?.medium ?? .empty
   57|     31|    }
   58|       |}
   59|       |
   60|       |// MARK: - Private
   61|       |
   62|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   63|       |private extension ViewHosting {
   64|       |    
   65|       |    struct Hosted {
   66|       |        #if os(macOS)
   67|       |        let viewController: NSViewController
   68|       |        #else
   69|       |        let viewController: UIViewController
   70|       |        #endif
   71|       |        let medium: Content.Medium
   72|       |    }
   73|       |    private static var hosted: [ViewId: Hosted] = [:]
   74|       |    #if os(macOS)
   75|       |    static var window: NSWindow = makeWindow()
   76|       |    #else
   77|       |    static var window: UIWindow = makeWindow()
   78|       |    #endif
   79|       |    
   80|       |    // MARK: - Window construction
   81|       |    
   82|       |    #if os(macOS)
   83|       |    static func makeWindow() -> NSWindow {
   84|       |        let window = NSWindow(
   85|       |            contentRect: NSRect(x: 0, y: 0, width: 200, height: 200),
   86|       |            styleMask: [.titled, .resizable, .miniaturizable, .closable],
   87|       |            backing: .buffered,
   88|       |            defer: false)
   89|       |        window.contentViewController = RootViewController()
   90|       |        window.makeKeyAndOrderFront(window)
   91|       |        window.layoutIfNeeded()
   92|       |        return window
   93|       |    }
   94|       |    #else
   95|      1|    static func makeWindow() -> UIWindow {
   96|      1|        let window = UIWindow(frame: UIScreen.main.bounds)
   97|      1|        window.rootViewController = UIViewController()
   98|      1|        window.rootViewController?.view.translatesAutoresizingMaskIntoConstraints = false
   99|      1|        window.makeKeyAndVisible()
  100|      1|        window.layoutIfNeeded()
  101|      1|        return window
  102|      1|    }
  103|       |    #endif
  104|       |    
  105|       |    // MARK: - ViewControllers
  106|       |    
  107|       |    #if os(macOS)
  108|       |    static var rootViewController: NSViewController {
  109|       |        window.contentViewController!
  110|       |    }
  111|       |    static func hostVC<V>(_ view: V) -> NSHostingController<V> where V: View {
  112|       |        NSHostingController(rootView: view)
  113|       |    }
  114|       |    #else
  115|     26|    static var rootViewController: UIViewController {
  116|     26|        window.rootViewController!
  117|     26|    }
  118|     26|    static func hostVC<V>(_ view: V) -> UIHostingController<V> where V: View {
  119|     26|        UIHostingController(rootView: view)
  120|     26|    }
  121|       |    #endif
  122|       |    
  123|       |    // MARK: - WillMove & DidMove
  124|       |    
  125|       |    #if os(macOS)
  126|       |    static func willMove(_ child: NSViewController, to parent: NSViewController?) {
  127|       |    }
  128|       |    static func didMove(_ child: NSViewController, to parent: NSViewController?) {
  129|       |    }
  130|       |    #else
  131|     52|    static func willMove(_ child: UIViewController, to parent: UIViewController?) {
  132|     52|        child.willMove(toParent: parent)
  133|     52|    }
  134|     52|    static func didMove(_ child: UIViewController, to parent: UIViewController?) {
  135|     52|        child.didMove(toParent: parent)
  136|     52|    }
  137|       |    #endif
  138|       |    
  139|       |    // MARK: - ViewController identification
  140|       |    
  141|     26|    static func store(_ hosted: Hosted, viewId: ViewId) {
  142|     26|        self.hosted[viewId] = hosted
  143|     26|    }
  144|       |    
  145|     26|    static func expel(viewId: ViewId) -> Hosted? {
  146|     26|        return hosted.removeValue(forKey: viewId)
  147|     26|    }
  148|       |}
  149|       |
  150|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  151|       |private extension NSLayoutConstraint {
  152|       |    #if os(macOS)
  153|       |    func priority(_ value: NSLayoutConstraint.Priority) -> NSLayoutConstraint {
  154|       |        priority = value
  155|       |        return self
  156|       |    }
  157|       |    #else
  158|     52|    func priority(_ value: UILayoutPriority) -> NSLayoutConstraint {
  159|     52|        priority = value
  160|     52|        return self
  161|     52|    }
  162|       |    #endif
  163|       |}
  164|       |
  165|       |// MARK: - RootViewController for macOS
  166|       |
  167|       |#if os(macOS)
  168|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  169|       |private class RootViewController: NSViewController {
  170|       |
  171|       |   override func loadView() {
  172|       |      view = NSView()
  173|       |   }
  174|       |
  175|       |   init() {
  176|       |      super.init(nibName: nil, bundle: nil)
  177|       |   }
  178|       |
  179|       |   required init?(coder: NSCoder) {
  180|       |      fatalError()
  181|       |   }
  182|       |}
  183|       |#endif
  184|       |
  185|       |// MARK: - UIView lookup
  186|       |
  187|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  188|       |internal extension ViewHosting {
  189|       |    #if os(macOS)
  190|       |    static func lookup<V>(_ view: V.Type) throws -> V.NSViewType
  191|       |        where V: Inspectable & NSViewRepresentable {
  192|       |            let name = Inspector.typeName(type: view)
  193|       |            let viewHost = rootViewController.view.descendant(nameTraits: ["ViewHost", name])
  194|       |            guard let view = viewHost?.subviews.compactMap({ $0 as? V.NSViewType }).first else {
  195|       |                throw InspectionError.viewNotFound(parent: name)
  196|       |            }
  197|       |            return view
  198|       |    }
  199|       |    
  200|       |    static func lookup<V>(_ viewController: V.Type) throws -> V.NSViewControllerType
  201|       |        where V: Inspectable & NSViewControllerRepresentable {
  202|       |            let name = Inspector.typeName(type: viewController)
  203|       |            let hostVC = rootViewController.descendant(nameTraits: ["NSHostingController", name])
  204|       |            if let vc = hostVC?.descendants.compactMap({ $0 as? V.NSViewControllerType }).first {
  205|       |                return vc
  206|       |            }
  207|       |            let viewHost = rootViewController.view.descendant(nameTraits: ["ViewHost"])
  208|       |            guard let vc = viewHost?.subviews
  209|       |                .compactMap({ $0.nextResponder as? V.NSViewControllerType }).first
  210|       |            else { throw InspectionError.viewNotFound(parent: name) }
  211|       |            return vc
  212|       |    }
  213|       |    #else
  214|       |    static func lookup<V>(_ view: V.Type) throws -> V.UIViewType
  215|      0|        where V: Inspectable & UIViewRepresentable {
  216|      0|            let name = Inspector.typeName(type: view)
  217|      0|            let viewHost = window.descendant(nameTraits: ["ViewHost", name])
  218|      0|            guard let view = viewHost?.subviews.compactMap({ $0 as? V.UIViewType }).first else {
  219|      0|                throw InspectionError.viewNotFound(parent: name)
  220|      0|            }
  221|      0|            return view
  222|      0|    }
  223|       |    
  224|       |    static func lookup<V>(_ viewController: V.Type) throws -> V.UIViewControllerType
  225|      0|        where V: Inspectable & UIViewControllerRepresentable {
  226|      0|            let name = Inspector.typeName(type: viewController)
  227|      0|            let hostVC = window.rootViewController?.descendant(nameTraits: ["UIHostingController", name])
  228|      0|            guard let vc = hostVC?.descendants.compactMap({ $0 as? V.UIViewControllerType })
  229|      0|                .first else { throw InspectionError.viewNotFound(parent: name) }
  230|      0|            return vc
  231|      0|    }
  232|       |    #endif
  233|       |}
  234|       |
  235|       |#if os(macOS)
  236|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  237|       |private extension NSView {
  238|       |    func descendant(nameTraits: [String]) -> NSView? {
  239|       |        let name = Inspector.typeName(value: self)
  240|       |        if !nameTraits.contains(where: { !name.contains($0) }) {
  241|       |            return self
  242|       |        }
  243|       |        return subviews.lazy
  244|       |            .compactMap { $0.descendant(nameTraits: nameTraits) }
  245|       |            .first
  246|       |    }
  247|       |}
  248|       |
  249|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  250|       |private extension NSViewController {
  251|       |    func descendant(nameTraits: [String]) -> NSViewController? {
  252|       |        let name = Inspector.typeName(value: self)
  253|       |        if !nameTraits.contains(where: { !name.contains($0) }) {
  254|       |            return self
  255|       |        }
  256|       |        return descendants.lazy
  257|       |            .compactMap { $0.descendant(nameTraits: nameTraits) }
  258|       |            .first
  259|       |    }
  260|       |    
  261|       |    var descendants: [NSViewController] {
  262|       |        let presented = presentedViewControllers ?? []
  263|       |        return presented + children
  264|       |    }
  265|       |}
  266|       |#else
  267|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  268|       |private extension UIView {
  269|      0|    func descendant(nameTraits: [String]) -> UIView? {
  270|      0|        let name = Inspector.typeName(value: self)
  271|      0|        if !nameTraits.contains(where: { !name.contains($0) }) {
  272|      0|            return self
  273|      0|        }
  274|      0|        return subviews.lazy
  275|      0|            .compactMap { $0.descendant(nameTraits: nameTraits) }
  276|      0|            .first
  277|      0|    }
  278|       |}
  279|       |
  280|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  281|       |private extension UIViewController {
  282|      0|    func descendant(nameTraits: [String]) -> UIViewController? {
  283|      0|        let name = Inspector.typeName(value: self)
  284|      0|        if !nameTraits.contains(where: { !name.contains($0) }) {
  285|      0|            return self
  286|      0|        }
  287|      0|        return descendants.lazy
  288|      0|            .compactMap { $0.descendant(nameTraits: nameTraits) }
  289|      0|            .first
  290|      0|    }
  291|       |    
  292|      0|    var descendants: [UIViewController] {
  293|      0|        let navChildren = (self as? UINavigationController)?.viewControllers ?? []
  294|      0|        let tabChildren = (self as? UITabBarController)?.viewControllers ?? []
  295|      0|        let presented = [presentedViewController].compactMap { $0 }
  296|      0|        return navChildren + tabChildren + presented + children
  297|      0|    }
  298|       |}
  299|       |#endif

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/ViewSearch.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Search namespace and types
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |public struct ViewSearch {
    7|       |    public enum Relation {
    8|       |        case child
    9|       |        case parent
   10|       |    }
   11|       |    public enum Traversal {
   12|       |        case depthFirst
   13|       |        case breadthFirst
   14|       |    }
   15|       |    public typealias Condition = (InspectableView<ViewType.ClassifiedView>) throws -> Bool
   16|       |}
   17|       |
   18|       |// MARK: - Public search API
   19|       |
   20|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
   21|       |public extension InspectableView {
   22|       |    
   23|       |    /**
   24|       |     Searches for a `Text` view containing the specified string
   25|       |
   26|       |      - Parameter text: The string to look up for
   27|       |      - Parameter locale: The locale for the string extraction.
   28|       |     Defaults to `testsDefault` (i.e. `Locale(identifier: "en")`)
   29|       |      - Throws: An error if the view cannot be found
   30|       |      - Returns: A found `Text` view
   31|       |     */
   32|       |    func find(text: String,
   33|       |              locale: Locale = .testsDefault
   34|      5|    ) throws -> InspectableView<ViewType.Text> {
   35|      5|        return try find(textWhere: { value, _ in value == text }, locale: locale)
   36|      5|    }
   37|       |    
   38|       |    /**
   39|       |     Searches for a `Text` view matching a given condition, based on its string and attributes
   40|       |
   41|       |      - Parameter textWhere: The condition closure for detecting a matching `Text`.
   42|       |     Thrown errors are interpreted as "this view does not match"
   43|       |      - Parameter locale: The locale for the string extraction.
   44|       |     Defaults to `testsDefault` (i.e. `Locale(identifier: "en")`)
   45|       |      - Throws: An error if the view cannot be found
   46|       |      - Returns: A found `Text` view
   47|       |     */
   48|       |    func find(textWhere condition: (String, ViewType.Text.Attributes) throws -> Bool,
   49|       |              locale: Locale = .testsDefault
   50|      5|    ) throws -> InspectableView<ViewType.Text> {
   51|      5|        return try find(ViewType.Text.self, where: {
   52|      5|            try condition(try $0.string(locale: locale), try $0.attributes())
   53|      5|        })
   54|      5|    }
   55|       |    
   56|       |    /**
   57|       |     Searches for a `Button` view with matching title
   58|       |
   59|       |      - Parameter button: The title to look up for
   60|       |      - Parameter locale: The locale for the title extraction.
   61|       |     Defaults to `testsDefault` (i.e. `Locale(identifier: "en")`)
   62|       |      - Throws: An error if the view cannot be found
   63|       |      - Returns: A found `Button` view
   64|       |     */
   65|       |    func find(button title: String,
   66|       |              locale: Locale = .testsDefault
   67|      3|    ) throws -> InspectableView<ViewType.Button> {
   68|      3|        return try find(ViewType.Button.self, containing: title, locale: locale)
   69|      3|    }
   70|       |    
   71|       |    /**
   72|       |     Searches for a `Link` view with matching `URL` parameter
   73|       |
   74|       |      - Parameter link: The `URL` to look up for
   75|       |      - Throws: An error if the view cannot be found
   76|       |      - Returns: A found `Link` view
   77|       |     */
   78|       |    @available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   79|      0|    func find(link url: URL) throws -> InspectableView<ViewType.Link> {
   80|      0|        return try find(ViewType.Link.self, where: { view in
   81|      0|            try view.url() == url
   82|      0|        })
   83|      0|    }
   84|       |    
   85|       |    /**
   86|       |     Searches for a `Link` view with matching label parameter
   87|       |
   88|       |      - Parameter link: The string to look up for as Link's label
   89|       |      - Parameter locale: The locale for the label extraction.
   90|       |     Defaults to `testsDefault` (i.e. `Locale(identifier: "en")`)
   91|       |      - Throws: An error if the view cannot be found
   92|       |      - Returns: A found `Link` view
   93|       |     */
   94|       |    @available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
   95|       |    func find(link label: String,
   96|       |              locale: Locale = .testsDefault
   97|      0|    ) throws -> InspectableView<ViewType.Link> {
   98|      0|        return try find(ViewType.Link.self, containing: label, locale: locale)
   99|      0|    }
  100|       |    
  101|       |    /**
  102|       |     Searches for a `NavigationLink` view with matching label parameter
  103|       |
  104|       |      - Parameter navigationLink: The string to look up for
  105|       |      - Parameter locale: The locale for the label extraction.
  106|       |     Defaults to `testsDefault` (i.e. `Locale(identifier: "en")`)
  107|       |      - Throws: An error if the view cannot be found
  108|       |      - Returns: A found `NavigationLink` view
  109|       |     */
  110|       |    func find(navigationLink string: String,
  111|       |              locale: Locale = .testsDefault
  112|      0|    ) throws -> InspectableView<ViewType.NavigationLink> {
  113|      0|        return try find(ViewType.NavigationLink.self, containing: string, locale: locale)
  114|      0|    }
  115|       |    
  116|       |    /**
  117|       |     Searches for a view with given `id`
  118|       |
  119|       |      - Parameter viewWithId: The `id` to look up for
  120|       |      - Throws: An error if the view cannot be found
  121|       |      - Returns: A found view
  122|       |     */
  123|      0|    func find(viewWithId id: AnyHashable) throws -> InspectableView<ViewType.ClassifiedView> {
  124|      0|        return try find { try $0.id() == id }
  125|      0|    }
  126|       |    
  127|       |    /**
  128|       |     Searches for a view with given `tag`
  129|       |
  130|       |      - Parameter viewWithTag: The `tag` to look up for
  131|       |      - Throws: An error if the view cannot be found
  132|       |      - Returns: A found view
  133|       |     */
  134|      0|    func find(viewWithTag tag: AnyHashable) throws -> InspectableView<ViewType.ClassifiedView> {
  135|      0|        return try find { try $0.tag() == tag }
  136|      0|    }
  137|       |    
  138|       |    /**
  139|       |     Searches for a view of a specific type that matches a given condition
  140|       |
  141|       |      - Parameter inspectable: Your custom `Inspectable` view type. For example: `ContentView.self`
  142|       |      - Parameter relation: The direction of the search. Defaults to `.child`
  143|       |      - Parameter where: The condition closure for detecting a matching view.
  144|       |     Thrown errors are interpreted as "this view does not match"
  145|       |      - Throws: An error if the view cannot be found
  146|       |      - Returns: A found view
  147|       |     */
  148|       |    func find<V>(_ inspectable: V.Type,
  149|       |                 relation: ViewSearch.Relation = .child,
  150|     11|                 where condition: (InspectableView<ViewType.View<V>>) throws -> Bool = { _ in true }
  151|     11|    ) throws -> InspectableView<ViewType.View<V>> where V: Inspectable {
  152|     11|        return try find(ViewType.View<V>.self, relation: relation, where: condition)
  153|     11|    }
  154|       |    
  155|       |    /**
  156|       |     Searches for a view of a specific type, which enclosed hierarchy contains a `Text` with the provided string
  157|       |
  158|       |      - Parameter inspectable: Your custom `Inspectable` view type. For example: `ContentView.self`
  159|       |      - Parameter containing: The string to look up for
  160|       |      - Parameter locale: The locale for the text extraction.
  161|       |     Defaults to `testsDefault` (i.e. `Locale(identifier: "en")`)
  162|       |      - Throws: An error if the view cannot be found
  163|       |      - Returns: A found view
  164|       |     */
  165|       |    func find<V>(_ inspectable: V.Type,
  166|       |                 containing string: String,
  167|       |                 locale: Locale = .testsDefault
  168|      0|    ) throws -> InspectableView<ViewType.View<V>> {
  169|      0|        return try find(ViewType.View<V>.self, containing: string, locale: locale)
  170|      0|    }
  171|       |    
  172|       |    /**
  173|       |     Searches for a view of a specific type, which enclosed hierarchy contains a `Text` with the provided string
  174|       |
  175|       |      - Parameter viewType: The type of the view. For example: `ViewType.HStack.self`
  176|       |      - Parameter containing: The string to look up for
  177|       |      - Parameter locale: The locale for the text extraction.
  178|       |     Defaults to `testsDefault` (i.e. `Locale(identifier: "en")`)
  179|       |      - Throws: An error if the view cannot be found
  180|       |      - Returns: A found view
  181|       |     */
  182|       |    func find<T>(_ viewType: T.Type,
  183|       |                 containing string: String,
  184|       |                 locale: Locale = .testsDefault
  185|      3|    ) throws -> InspectableView<T> {
  186|      2|        return try find(ViewType.Text.self, where: { text in
  187|      2|            try text.string(locale: locale) == string
  188|      0|            && (try? text.find(T.self, relation: .parent)) != nil
  189|      2|        }).find(T.self, relation: .parent)
  190|      3|    }
  191|       |    
  192|       |    /**
  193|       |     Searches for a view of a specific type that matches a given condition
  194|       |
  195|       |      - Parameter viewType: The type of the view. For example: `ViewType.HStack.self`
  196|       |      - Parameter relation: The direction of the search. Defaults to `.child`
  197|       |      - Parameter traversal: The algorithm for view hierarchy traversal. Defaults to `.breadthFirst`
  198|       |      - Parameter skipFound: How many matching views to skip. Defaults to `0`
  199|       |      - Parameter where: The condition closure for detecting a matching view.
  200|       |     Thrown errors are interpreted as "this view does not match"
  201|       |      - Throws: An error if the view cannot be found
  202|       |      - Returns: A found view of the given type.
  203|       |     */
  204|       |    func find<T>(_ viewType: T.Type,
  205|       |                 relation: ViewSearch.Relation = .child,
  206|       |                 traversal: ViewSearch.Traversal = .breadthFirst,
  207|       |                 skipFound: Int = 0,
  208|     28|                 where condition: (InspectableView<T>) throws -> Bool = { _ in true }
  209|     47|    ) throws -> InspectableView<T> where T: KnownViewType {
  210|    168|        let view = try find(relation: relation, traversal: traversal, skipFound: skipFound, where: { view -> Bool in
  211|    168|            let typedView = try view.asInspectableView(ofType: T.self)
  212|    168|            return try condition(typedView)
  213|    168|        })
  214|     47|        return try view.asInspectableView(ofType: T.self)
  215|     47|    }
  216|       |    
  217|       |    /**
  218|       |     Searches for a view that matches a given condition
  219|       |
  220|       |      - Parameter relation: The direction of the search. Defaults to `.child`
  221|       |      - Parameter traversal: The algorithm for view hierarchy traversal. Defaults to `.breadthFirst`
  222|       |      - Parameter skipFound: How many matching views to skip. Defaults to `0`
  223|       |      - Parameter where: The condition closure for detecting a matching view.
  224|       |     Thrown errors are interpreted as "this view does not match"
  225|       |      - Throws: An error if the view cannot be found
  226|       |      - Returns: A found view of the given type.
  227|       |     */
  228|       |    func find(relation: ViewSearch.Relation = .child,
  229|       |              traversal: ViewSearch.Traversal = .breadthFirst,
  230|       |              skipFound: Int = 0,
  231|       |              where condition: ViewSearch.Condition
  232|     47|    ) throws -> InspectableView<ViewType.ClassifiedView> {
  233|     47|        precondition(skipFound >= 0)
  234|     47|        switch relation {
  235|     47|        case .child:
  236|     47|            return try findChild(condition: condition, traversal: traversal, skipFound: skipFound)
  237|      0|        case .parent:
  238|      0|            return try findParent(condition: condition, skipFound: skipFound)
  239|     47|        }
  240|     47|    }
  241|       |    
  242|       |    /**
  243|       |     Searches for all the views of a specific type that match a given condition.
  244|       |     The hierarchy is traversed in depth-first order, meaning that you'll get views
  245|       |     ordered top-to-bottom as they appear in the code, regardless of their nesting depth.
  246|       |
  247|       |      - Parameter inspectable: Your custom `Inspectable` view type. For example: `ContentView.self`
  248|       |      - Parameter where: The condition closure for detecting a matching view.
  249|       |     Thrown errors are interpreted as "this view does not match"
  250|       |      - Returns: An array of all matching views or an empty array if none are found.
  251|       |     */
  252|       |    func findAll<V>(_ inspectable: V.Type,
  253|      0|                    where condition: (InspectableView<ViewType.View<V>>) throws -> Bool = { _ in true }
  254|      0|    ) -> [InspectableView<ViewType.View<V>>] where V: Inspectable {
  255|      0|        return findAll(ViewType.View<V>.self, where: condition)
  256|      0|    }
  257|       |    
  258|       |    /**
  259|       |     Searches for all the views of a specific type that match a given condition.
  260|       |     The hierarchy is traversed in depth-first order, meaning that you'll get views
  261|       |     ordered top-to-bottom as they appear in the code, regardless of their nesting depth.
  262|       |
  263|       |      - Parameter viewType: The type of the view. For example: `ViewType.HStack.self`
  264|       |      - Parameter where: The condition closure for detecting a matching view.
  265|       |     Thrown errors are interpreted as "this view does not match"
  266|       |      - Returns: An array of all matching views or an empty array if none are found.
  267|       |     */
  268|       |    func findAll<T>(_ viewType: T.Type,
  269|      0|                    where condition: (InspectableView<T>) throws -> Bool = { _ in true }
  270|      0|    ) -> [InspectableView<T>] where T: KnownViewType {
  271|      0|        return findAll(where: { view in
  272|      0|            guard let typedView = try? view.asInspectableView(ofType: T.self)
  273|      0|            else { return false }
  274|      0|            return try condition(typedView)
  275|      0|        }).compactMap({ try? $0.asInspectableView(ofType: T.self) })
  276|      0|    }
  277|       |    
  278|       |    /**
  279|       |     Searches for all the views that match a given condition.
  280|       |     The hierarchy is traversed in depth-first order, meaning that you'll get views
  281|       |     ordered top-to-bottom as they appear in the code, regardless of their nesting depth.
  282|       |
  283|       |      - Parameter where: The condition closure for detecting a matching view.
  284|       |     Thrown errors are interpreted as "this view does not match"
  285|       |      - Returns: An array of all matching views or an empty array if none are found.
  286|       |     */
  287|      0|    func findAll(where condition: ViewSearch.Condition) -> [InspectableView<ViewType.ClassifiedView>] {
  288|      0|        var results: [InspectableView<ViewType.ClassifiedView>] = []
  289|      0|        depthFirstTraversal(condition, stopOnFoundMatch: { view in
  290|      0|            if let view = try? view.asInspectableView() {
  291|      0|                results.append(view)
  292|      0|            }
  293|      0|            return false
  294|      0|        }, identificationFailure: { _ in })
  295|      0|        return results
  296|      0|    }
  297|       |}
  298|       |
  299|       |// MARK: - Search
  300|       |
  301|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  302|       |private extension UnwrappedView {
  303|       |    
  304|       |    func findParent(condition: ViewSearch.Condition, skipFound: Int
  305|      0|    ) throws -> InspectableView<ViewType.ClassifiedView> {
  306|      0|        var current = parentView
  307|      0|        var counter = skipFound + 1
  308|      0|        while let parent = try? current?.asInspectableView() {
  309|      0|            if (try? condition(parent)) == true {
  310|      0|                counter -= 1
  311|      0|            }
  312|      0|            if counter == 0 {
  313|      0|                return parent
  314|      0|            }
  315|      0|            current = parent.parentView
  316|      0|        }
  317|      0|        throw InspectionError.searchFailure(skipped: skipFound + 1 - counter, blockers: [])
  318|      0|    }
  319|       |    
  320|       |    func findChild(condition: ViewSearch.Condition,
  321|       |                   traversal: ViewSearch.Traversal,
  322|       |                   skipFound: Int
  323|     47|    ) throws -> InspectableView<ViewType.ClassifiedView> {
  324|     47|        var unknownViews: [Any] = []
  325|     47|        var result: UnwrappedView?
  326|     47|        var counter = skipFound + 1
  327|     43|        traversal.search(in: self, condition: condition, stopOnFoundMatch: { view -> Bool in
  328|     43|            counter -= 1
  329|     43|            if counter == 0 {
  330|     43|                result = view
  331|     43|                return true
  332|      0|            }
  333|      0|            return false
  334|      1|        }, identificationFailure: { content in
  335|      1|            unknownViews.append(content.view)
  336|      1|        })
  337|     43|        if let result = result {
  338|     43|            return try result.asInspectableView()
  339|      4|        }
  340|      4|        let blockers = blockersDescription(unknownViews)
  341|      4|        throw InspectionError.searchFailure(skipped: skipFound + 1 - counter, blockers: blockers)
  342|     47|    }
  343|       |    
  344|      4|    func blockersDescription(_ views: [Any]) -> [String] {
  345|      1|        return views.map { view -> String in
  346|      1|            let name = Inspector.typeName(value: view, prefixOnly: false)
  347|      1|            if name.hasPrefix("EnvironmentReaderView") {
  348|      0|                return "navigationBarItems"
  349|      1|            }
  350|      1|            if name.hasPrefix("PopoverPresentationModifier") {
  351|      0|                return "popover"
  352|      1|            }
  353|      1|            if let inspectable = view as? Inspectable {
  354|      1|                let missingObjects = inspectable.missingEnvironmentObjects
  355|      1|                if missingObjects.count > 0 {
  356|      0|                    return InspectionError
  357|      0|                        .missingEnvironmentObjects(view: name, objects: missingObjects)
  358|      0|                        .localizedDescription
  359|      1|                }
  360|      1|            }
  361|      1|            return name
  362|      1|        }
  363|      4|    }
  364|       |    
  365|       |    func breadthFirstTraversal(_ condition: ViewSearch.Condition,
  366|       |                               stopOnFoundMatch: (UnwrappedView) -> Bool,
  367|     47|                               identificationFailure: (Content) -> Void) {
  368|     47|        var queue: [(isSingle: Bool, children: LazyGroup<UnwrappedView>)] = []
  369|     47|        queue.append((true, .init(count: 1, { _ in self })))
  370|    185|        while !queue.isEmpty {
  371|    181|            let (isSingle, children) = queue.remove(at: 0)
  372|    466|            for offset in 0..<children.count {
  373|    298|                guard let view = try? children.element(at: offset) else { continue }
  374|     84|                let viewIndex = view.inspectionIndex ?? 0
  375|    119|                let index = isSingle && viewIndex == 0 ? nil : viewIndex
  376|    168|                guard let (identity, instance) = ViewSearch
  377|    168|                        .identifyAndInstantiate(view, index: index)
  378|      6|                else {
  379|      6|                    if (try? condition(try view.asInspectableView())) == true,
  380|      5|                       stopOnFoundMatch(view) {
  381|      5|                        return
  382|      1|                    }
  383|      1|                    identificationFailure(view.content)
  384|      1|                    continue
  385|    162|                }
  386|    162|                if (try? condition(try instance.asInspectableView())) == true,
  387|     38|                   stopOnFoundMatch(instance) {
  388|     38|                    return
  389|    124|                }
  390|    124|                if let descendants = try? identity.children(instance),
  391|     95|                   descendants.count > 0 {
  392|     63|                    let isSingle = (identity.viewType is SingleViewContent.Type) && descendants.count == 1
  393|     95|                    queue.append((isSingle, descendants))
  394|    124|                }
  395|    124|                if let descendants = try? identity.modifiers(instance),
  396|     63|                   descendants.count > 0 {
  397|     63|                    queue.append((true, descendants))
  398|    124|                }
  399|    124|                if let descendants = try? identity.supplementary(instance),
  400|     14|                   descendants.count > 0 {
  401|     14|                    queue.append((true, descendants))
  402|    124|                }
  403|    138|            }
  404|      4|        }
  405|      4|    }
  406|       |    
  407|       |    func depthFirstTraversal(_ condition: ViewSearch.Condition,
  408|       |                             stopOnFoundMatch: (UnwrappedView) -> Bool,
  409|      0|                             identificationFailure: (Content) -> Void) {
  410|      0|        var shouldContinue: Bool = true
  411|      0|        depthFirstRecursion(shouldContinue: &shouldContinue, isSingle: true, offset: 0,
  412|      0|                            condition: condition, stopOnFoundMatch: stopOnFoundMatch,
  413|      0|                            identificationFailure: identificationFailure)
  414|      0|    }
  415|       |    
  416|       |    func depthFirstRecursion(shouldContinue: inout Bool,
  417|       |                             isSingle: Bool, offset: Int,
  418|       |                             condition: ViewSearch.Condition,
  419|       |                             stopOnFoundMatch: (UnwrappedView) -> Bool,
  420|      0|                             identificationFailure: (Content) -> Void) {
  421|      0|        if (try? condition(try self.asInspectableView())) == true,
  422|      0|           stopOnFoundMatch(self) {
  423|      0|            shouldContinue = false
  424|      0|        }
  425|      0|        guard shouldContinue else { return }
  426|      0|        
  427|      0|        let index = isSingle ? nil : offset
  428|      0|        
  429|      0|        guard let (identity, instance) = ViewSearch
  430|      0|                .identifyAndInstantiate(self, index: index) else {
  431|      0|            identificationFailure(self.content)
  432|      0|            return
  433|      0|        }
  434|      0|        guard let descendants = try? identity.allDescendants(instance)
  435|      0|        else { return }
  436|      0|        
  437|      0|        let isSingle = (identity.viewType is SingleViewContent.Type)
  438|      0|            && descendants.count == 1
  439|      0|        
  440|      0|        for offset in 0..<descendants.count {
  441|      0|            guard let descendant = try? descendants.element(at: offset) else { continue }
  442|      0|            descendant.depthFirstRecursion(
  443|      0|                shouldContinue: &shouldContinue, isSingle: isSingle, offset: offset,
  444|      0|                condition: condition, stopOnFoundMatch: stopOnFoundMatch,
  445|      0|                identificationFailure: identificationFailure)
  446|      0|            guard shouldContinue else { return }
  447|      0|        }
  448|      0|    }
  449|       |}
  450|       |
  451|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  452|       |private extension ViewSearch.Traversal {
  453|       |    func search(in view: UnwrappedView,
  454|       |                condition: ViewSearch.Condition,
  455|       |                stopOnFoundMatch: (UnwrappedView) -> Bool,
  456|     47|                identificationFailure: (Content) -> Void) {
  457|     47|        switch self {
  458|     47|        case .breadthFirst:
  459|     47|            view.breadthFirstTraversal(condition, stopOnFoundMatch: stopOnFoundMatch,
  460|     47|                                       identificationFailure: identificationFailure)
  461|      0|        case .depthFirst:
  462|      0|            view.depthFirstTraversal(condition, stopOnFoundMatch: stopOnFoundMatch,
  463|      0|                                     identificationFailure: identificationFailure)
  464|     47|        }
  465|     47|    }
  466|       |}

/Users/aikesiero/Library/Developer/Xcode/DerivedData/CountriesSwiftUI-cmhadclklzwvgthbgeaahqohvrbx/SourcePackages/checkouts/ViewInspector/Sources/ViewInspector/ViewSearchIndex.swift:
    1|       |import SwiftUI
    2|       |
    3|       |// MARK: - Index
    4|       |
    5|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    6|       |internal extension ViewSearch {
    7|       |    
    8|      1|    private static var index: [String: [ViewIdentity]] = {
    9|      1|        let identities: [ViewIdentity] = [
   10|      1|            .init(ViewType.ActionSheet.self), .init(ViewType.Alert.self), .init(ViewType.AlertButton.self),
   11|      1|            .init(ViewType.AngularGradient.self), .init(ViewType.AnyView.self),
   12|      1|            .init(ViewType.Button.self),
   13|      1|            .init(ViewType.Color.self), .init(ViewType.ColorPicker.self),
   14|      1|            .init(ViewType.DatePicker.self), .init(ViewType.DisclosureGroup.self),
   15|      1|            .init(ViewType.Divider.self),
   16|      1|            .init(ViewType.EditButton.self), .init(ViewType.EmptyView.self),
   17|      1|            .init(ViewType.ForEach.self), .init(ViewType.Form.self),
   18|      1|            .init(ViewType.GeometryReader.self),
   19|      1|            .init(ViewType.Group.self), .init(ViewType.GroupBox.self),
   20|      1|            .init(ViewType.HSplitView.self), .init(ViewType.HStack.self),
   21|      1|            .init(ViewType.Image.self),
   22|      1|            .init(ViewType.Label.self),
   23|      1|            .init(ViewType.LazyHGrid.self), .init(ViewType.LazyHStack.self),
   24|      1|            .init(ViewType.LazyVGrid.self), .init(ViewType.LazyVStack.self),
   25|      1|            .init(ViewType.LinearGradient.self),
   26|      1|            .init(ViewType.Link.self), .init(ViewType.List.self),
   27|      1|            .init(ViewType.Map.self),
   28|      1|            .init(ViewType.Menu.self), .init(ViewType.MenuButton.self),
   29|      1|            .init(ViewType.NavigationLink.self), .init(ViewType.NavigationView.self),
   30|      1|            .init(ViewType.OutlineGroup.self),
   31|      1|            .init(ViewType.PasteButton.self), .init(ViewType.Picker.self),
   32|      1|            .init(ViewType.Popover.self), .init(ViewType.ProgressView.self),
   33|      1|            .init(ViewType.RadialGradient.self),
   34|      1|            .init(ViewType.ScrollView.self), .init(ViewType.ScrollViewReader.self),
   35|      1|            .init(ViewType.Section.self), .init(ViewType.SecureField.self),
   36|      1|            .init(ViewType.Sheet.self, genericTypeName: nil),
   37|      1|            .init(ViewType.Slider.self), .init(ViewType.Spacer.self), .init(ViewType.Stepper.self),
   38|      1|            .init(ViewType.StyleConfiguration.Label.self), .init(ViewType.StyleConfiguration.Content.self),
   39|      1|            .init(ViewType.StyleConfiguration.Title.self), .init(ViewType.StyleConfiguration.Icon.self),
   40|      1|            .init(ViewType.StyleConfiguration.CurrentValueLabel.self),
   41|      1|            .init(ViewType.TabView.self), .init(ViewType.Text.self),
   42|      1|            .init(ViewType.TextEditor.self), .init(ViewType.TextField.self),
   43|      1|            .init(ViewType.Toggle.self), .init(ViewType.TouchBar.self), .init(ViewType.TupleView.self),
   44|      1|            .init(ViewType.ViewModifierContent.self), .init(ViewType.VSplitView.self), .init(ViewType.VStack.self),
   45|      1|            .init(ViewType.ZStack.self)
   46|      1|        ]
   47|      1|        var index = [String: [ViewIdentity]](minimumCapacity: 26) // alphabet
   48|     64|        identities.forEach { identity in
   49|     64|            let letter = String(identity.viewType.typePrefix.prefix(1))
   50|     21|            var array = index[letter] ?? []
   51|     64|            array.append(identity)
   52|     64|            index[letter] = array
   53|     64|        }
   54|      1|        return index
   55|      1|    }()
   56|       |    
   57|    168|    private static func identify(_ content: Content) -> ViewIdentity? {
   58|      0|        if let customMapping = content.view as? CustomViewIdentityMapping {
   59|      0|            let viewType = customMapping.viewTypeForSearch
   60|      0|            let letter = String(viewType.typePrefix.prefix(1))
   61|      0|            return index[letter]?.first(where: { $0.viewType == viewType })
   62|    168|        }
   63|    168|        let shortPrefix = Inspector.typeName(value: content.view, prefixOnly: true)
   64|    168|        let longPrefix = Inspector.typeName(value: content.view, namespaced: true, prefixOnly: true)
   65|    168|        if shortPrefix.count > 0,
   66|    168|           let identity = index[String(shortPrefix.prefix(1))]?
   67|    496|            .first(where: { $0.viewType.namespacedPrefixes.contains(longPrefix) }) {
   68|    112|            return identity
   69|     56|        }
   70|     56|        if (try? content.extractCustomView()) != nil,
   71|     50|           let inspectable = content.view as? Inspectable {
   72|     50|            let name = Inspector.typeName(value: content.view, prefixOnly: true)
   73|     50|            switch inspectable.entity {
   74|     31|            case .view:
   75|     31|                return .init(ViewType.View<ViewType.Stub>.self, genericTypeName: name)
   76|     19|            case .viewModifier:
   77|     19|                return .init(ViewType.ViewModifier<ViewType.Stub>.self, genericTypeName: name)
   78|      0|            case .gesture:
   79|      0|                break
   80|     50|            }
   81|     50|            
   82|     56|        }
   83|     56|        return nil
   84|     56|    }
   85|       |    
   86|    168|    static func identifyAndInstantiate(_ view: UnwrappedView, index: Int?) -> (ViewIdentity, UnwrappedView)? {
   87|    168|        guard let identity = ViewSearch.identify(view.content),
   88|    162|              let instance = { () -> UnwrappedView? in
   89|    162|                    if view.isUnwrappedSupplementaryChild {
   90|      0|                        return view
   91|    162|                    }
   92|    162|                    return try? identity.builder(view.content, view.parentView, index)
   93|    162|                }()
   94|    162|        else { return nil }
   95|    162|        return (identity, instance)
   96|    168|    }
   97|       |}
   98|       |
   99|       |// MARK: - ViewType.Stub
  100|       |
  101|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  102|       |internal extension ViewType {
  103|       |    struct Stub: Inspectable {
  104|       |        var entity: Content.InspectableEntity
  105|      0|        func extractContent(environmentObjects: [AnyObject]) throws -> Any { () }
  106|       |    }
  107|       |}
  108|       |
  109|       |// MARK: - ViewIdentity
  110|       |
  111|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  112|       |internal protocol CustomViewIdentityMapping {
  113|       |    var viewTypeForSearch: KnownViewType.Type { get }
  114|       |}
  115|       |
  116|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  117|       |internal extension ViewSearch {
  118|       |    
  119|       |    struct ViewIdentity {
  120|       |        
  121|       |        typealias ChildrenBuilder = (UnwrappedView) throws -> LazyGroup<UnwrappedView>
  122|       |        typealias SupplementaryBuilder = (UnwrappedView) throws -> LazyGroup<SupplementaryView>
  123|       |        
  124|       |        let viewType: KnownViewType.Type
  125|       |        let builder: (Content, UnwrappedView?, Int?) throws -> UnwrappedView
  126|       |        let children: ChildrenBuilder
  127|       |        let modifiers: ChildrenBuilder
  128|       |        let supplementary: ChildrenBuilder
  129|       |        
  130|      0|        var allDescendants: ChildrenBuilder {
  131|      0|            return { try self.children($0) + self.supplementary($0) + self.modifiers($0) }
  132|      0|        }
  133|       |        
  134|       |        private init<T>(_ type: T.Type,
  135|       |                        genericTypeName: String?,
  136|      5|                        children: @escaping ChildrenBuilder = { _ in .empty },
  137|    110|                        supplementary: @escaping SupplementaryBuilder = { _ in .empty }
  138|    114|        ) where T: KnownViewType {
  139|    114|            viewType = type
  140|    162|            let callWithIndex: (Int?) -> String = { index in
  141|    112|                let base = type.inspectionCall(typeName: genericTypeName ?? "")
  142|    162|                return ViewType.inspectionCall(base: base, index: index)
  143|    162|            }
  144|    162|            builder = { content, parent, index in
  145|    162|                try InspectableView<T>(content, parent: parent, call: callWithIndex(index), index: index)
  146|    162|            }
  147|    114|            self.children = children
  148|    124|            self.supplementary = { parent in
  149|    124|                let descendants = try supplementary(parent)
  150|      4|                return .init(count: descendants.count) { index -> UnwrappedView in
  151|      4|                    var view = try descendants.element(at: index)
  152|      4|                    if !(view is InspectableView<ViewType.ClassifiedView>) {
  153|      0|                        view.isUnwrappedSupplementaryChild = true
  154|      0|                        return view
  155|      4|                    }
  156|      4|                    return try InspectableView<ViewType.ClassifiedView>(view.content, parent: view)
  157|      4|                }
  158|    124|            }
  159|    124|            self.modifiers = { parent in
  160|    124|                return parent.content.modifierDescendants(parent: parent)
  161|    124|            }
  162|    114|        }
  163|       |        
  164|      4|        init<T>(_ type: T.Type) where T: KnownViewType, T: SingleViewContent {
  165|     19|            self.init(type, genericTypeName: nil, children: { parent in
  166|     19|                try T.child(parent.content).descendants(parent)
  167|     19|            })
  168|      4|        }
  169|       |        
  170|      1|        init<T>(_ type: T.Type) where T: KnownViewType, T: SingleViewContent, T: SupplementaryChildren {
  171|      0|            self.init(type, genericTypeName: nil, children: { parent in
  172|      0|                try T.child(parent.content).descendants(parent)
  173|      0|            }, supplementary: { parent in
  174|      0|                try T.supplementaryChildren(parent)
  175|      0|            })
  176|      1|        }
  177|       |        
  178|     14|        init<T>(_ type: T.Type) where T: KnownViewType, T: MultipleViewContent {
  179|     23|            self.init(type, genericTypeName: nil, children: { parent in
  180|     23|                try T.children(parent.content).descendants(parent, indexed: true)
  181|     23|            })
  182|     14|        }
  183|       |        
  184|       |        init<T>(_ type: T.Type)
  185|      5|        where T: KnownViewType, T: MultipleViewContent, T: SupplementaryChildren {
  186|      9|            self.init(type, genericTypeName: nil, children: { parent in
  187|      9|                try T.children(parent.content).descendants(parent, indexed: true)
  188|      9|            }, supplementary: { parent in
  189|      9|                try T.supplementaryChildren(parent)
  190|      9|            })
  191|      5|        }
  192|       |        
  193|       |        init<T>(_ type: T.Type, genericTypeName: String? = nil)
  194|     51|        where T: KnownViewType, T: SingleViewContent, T: MultipleViewContent {
  195|     44|            self.init(type, genericTypeName: genericTypeName, children: { parent in
  196|     44|                try T.children(parent.content).descendants(parent, indexed: true)
  197|     44|            })
  198|     51|        }
  199|       |        
  200|     24|        init<T>(_ type: T.Type) where T: KnownViewType {
  201|     24|            self.init(type, genericTypeName: nil, children: { _ in .empty })
  202|     24|        }
  203|       |        
  204|     15|        init<T>(_ type: T.Type) where T: KnownViewType, T: SupplementaryChildren {
  205|      5|            self.init(type, genericTypeName: nil, supplementary: { parent in
  206|      5|                try T.supplementaryChildren(parent)
  207|      5|            })
  208|     15|        }
  209|       |    }
  210|       |}
  211|       |
  212|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  213|       |private extension LazyGroup where T == Content {
  214|     76|    func descendants(_ parent: UnwrappedView, indexed: Bool) -> LazyGroup<UnwrappedView> {
  215|     83|        return .init(count: count, { index in
  216|     83|            try InspectableView<ViewType.ClassifiedView>(
  217|     83|                try element(at: index), parent: parent, index: indexed ? index : nil)
  218|     83|        })
  219|     76|    }
  220|       |}
  221|       |
  222|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  223|       |private extension Content {
  224|     19|    func descendants(_ parent: UnwrappedView) -> LazyGroup<UnwrappedView> {
  225|     19|        return .init(count: 1) { _ in
  226|     19|            try InspectableView<ViewType.ClassifiedView>(self, parent: parent, index: nil)
  227|     19|        }
  228|     19|    }
  229|       |}
  230|       |
  231|       |// MARK: - ModifierIdentity
  232|       |
  233|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  234|       |internal extension ViewSearch {
  235|       |    
  236|       |    static private(set) var modifierIdentities: [ModifierIdentity] = [
  237|      0|        .init(name: "_OverlayModifier", builder: { parent, index in
  238|      0|            try parent.content.overlay(parent: parent)
  239|      0|        }),
  240|      0|        .init(name: "_BackgroundModifier", builder: { parent, index in
  241|      0|            try parent.content.background(parent: parent)
  242|      0|        }),
  243|      0|        .init(name: "PopoverPresentationModifier", builder: { parent, index in
  244|      0|            try parent.content.popover(parent: parent)
  245|      0|        }),
  246|      0|        .init(name: "_MaskEffect", builder: { parent, index in
  247|      0|            try parent.content.mask(parent: parent)
  248|      0|        }),
  249|      0|        .init(name: "_TraitWritingModifier<TabItemTraitKey>", builder: { parent, index in
  250|      0|            try parent.content.tabItem(parent: parent)
  251|      0|        }),
  252|      0|        .init(name: "_TraitWritingModifier<ListRowBackgroundTraitKey>", builder: { parent, index in
  253|      0|            try parent.content.listRowBackground(parent: parent)
  254|      0|        }),
  255|      0|        .init(name: "_TouchBarModifier", builder: { parent, index in
  256|      0|            try parent.content.touchBar(parent: parent)
  257|      0|        }),
  258|       |    ]
  259|       |    
  260|       |    struct ModifierIdentity {
  261|       |        typealias Builder = (UnwrappedView, Int?) throws -> UnwrappedView
  262|       |        let name: String
  263|       |        let builder: Builder
  264|       |        
  265|    349|        init(name: String, builder: @escaping Builder) {
  266|    349|            self.name = name
  267|    294|            self.builder = { parent, index in
  268|    294|                let view = try builder(parent, index)
  269|    294|                if view.isTransitive {
  270|      0|                    return try InspectableView<ViewType.ClassifiedView>(
  271|      0|                        view.content, parent: view, index: index)
  272|    294|                } else {
  273|    294|                    return view
  274|      0|                }
  275|      0|            }
  276|    349|        }
  277|       |    }
  278|       |}
  279|       |
  280|       |@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  281|       |internal extension Content {
  282|       |    
  283|    124|    func modifierDescendants(parent: UnwrappedView) -> LazyGroup<UnwrappedView> {
  284|    114|        let modifierNames = modifiersMatching({ _ in true })
  285|    114|                .map { $0.modifierType }
  286|    124|        let identities = ViewSearch.modifierIdentities
  287|    868|            .filter({ identity -> Bool in
  288|    798|                modifierNames.contains(where: { $0.hasPrefix(identity.name) })
  289|    868|            })
  290|    124|        let sheets = sheetModifierDescendants(parent: parent)
  291|    124|        let customModifiers = customViewModifiers()
  292|      0|        return .init(count: identities.count, { index -> UnwrappedView in
  293|      0|            try identities[index].builder(parent, nil)
  294|     19|        }) + sheets + .init(count: customModifiers.count, { index -> UnwrappedView in
  295|     19|            let modifier = customModifiers[index]
  296|     19|            let name = Inspector.typeName(value: modifier)
  297|     19|            let thisTypeModifiersCount = customModifiers
  298|     19|                .reduce(0, { $0 + (Inspector.typeName(value: $1) == name ? 1 : 0) })
  299|     19|            let index = thisTypeModifiersCount > 1 ? index : nil
  300|     19|            let medium = self.medium.resettingViewModifiers()
  301|     19|            let content = try Inspector.unwrap(view: modifier, medium: medium)
  302|     19|            
  303|     19|            let base = ViewType.ViewModifier<ViewType.Stub>
  304|     19|                .inspectionCall(typeName: name)
  305|     19|            let call = ViewType.inspectionCall(base: base, index: index)
  306|     19|            return try InspectableView<ViewType.ViewModifier<ViewType.Stub>>(
  307|     19|                content, parent: parent, call: call, index: index)
  308|     19|        })
  309|    124|    }
  310|       |    
  311|    124|    private func sheetModifierDescendants(parent: UnwrappedView) -> LazyGroup<UnwrappedView> {
  312|    124|        let sheetModifiers = sheetsForSearch()
  313|    124|        #if os(macOS)
  314|    124|        let actionSheetModifiers: [ViewSearch.ModifierIdentity] = []
  315|    124|        #else
  316|    124|        let actionSheetModifiers = actionSheetsForSearch()
  317|    124|        #endif
  318|    124|        let alertModifiers = alertsForSearch()
  319|     98|        return .init(count: sheetModifiers.count, { index -> UnwrappedView in
  320|     98|            try sheetModifiers[index].builder(parent, index)
  321|     98|        }) + .init(count: actionSheetModifiers.count, { index -> UnwrappedView in
  322|     98|            try actionSheetModifiers[index].builder(parent, index)
  323|     98|        }) + .init(count: alertModifiers.count, { index -> UnwrappedView in
  324|     98|            try alertModifiers[index].builder(parent, index)
  325|     98|        })
  326|    124|    }
  327|       |}

